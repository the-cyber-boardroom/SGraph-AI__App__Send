# Explorer Team: Brief — Interactive Encrypted Data Workflows

**version** v0.4.4  
**date** 16 Feb 2026  
**from** Human (project lead)  
**to** Explorer team via Conductor  
**status** Exploration brief — research and prototype  

---

## The Insight

Right now, SG/Send transfers data as opaque blobs. You encrypt a file or text, the recipient decrypts it, and they see… a file or text. The transfer is a dumb pipe — encrypted content goes in, encrypted content comes out.

But what if the transfer was smart? What if the recipient didn't just see raw text or JSON, but saw a **form, a set of buttons, a review interface** — dynamically generated from the content — all while the data remains encrypted on the client?

This turns SG/Send from a file transfer tool into an **encrypted workflow platform.**

---

## The Core Concept: JSON In → JSON Out, Via Nice Interfaces

### How It Works

```
SENDER                              RECIPIENT
──────                              ─────────

Structures data as JSON             Receives encrypted JSON
   ↓                                    ↓
Encrypts on client                  Decrypts on client
   ↓                                    ↓
Sends via SG/Send                   JSON includes a UI schema
                                        ↓
                                    Browser renders a dynamic UI
                                    (forms, buttons, review panels)
                                        ↓
                                    Recipient interacts with the UI
                                    (approves, edits, selects, fills in)
                                        ↓
                                    Response is structured as JSON
                                        ↓
                                    Encrypted on client
                                        ↓
                                    Sent back via SG/Send
```

The key: **all data is encrypted on the client.** The server never sees the content. The server never sees the form. The server never sees the response. It's just encrypted bytes flowing through the pipe. But on both ends, the user sees a rich, interactive experience.

### What the JSON Contains

The sender's JSON includes two things:

1. **Data** — the actual content (translations to review, a form to fill, a survey to complete, a document to approve)
2. **UI schema** — a description of how to render the data as an interactive interface

The UI schema could be:
- A well-defined set of **browser UI elements** (text inputs, dropdowns, checkboxes, radio buttons, approval buttons, comment fields)
- A **layout definition** (how elements are arranged on the page)
- **Validation rules** (required fields, format constraints, allowed values)
- **Conditional logic** (show this field only if that checkbox is checked)

The recipient's browser reads the schema, renders the UI, and lets the user interact. When they're done, the responses are serialised back to JSON, encrypted, and sent back.

### Dynamic UI Generation via LLM

Here's where it gets powerful: the UI schema doesn't have to be hand-crafted. An LLM can generate it.

Given:
- A set of well-defined UI component types (text input, checkbox, dropdown, approval button, comment field, diff viewer, side-by-side comparison, etc.)
- The data structure being sent
- The intended workflow (review, approve, fill in, compare, etc.)

An LLM can dynamically generate the appropriate UI schema. The sender describes what they want ("I need the recipient to review these 20 translation strings and approve or edit each one"), and the LLM produces the schema that renders the right interface.

This means: **any structured data exchange can be turned into an interactive workflow, on the fly, without pre-built forms.**

---

## Use Case 1: Translation Review (The Translator's Workflow)

This is the immediate, concrete use case that prompted this exploration.

### Current (Manual) Workflow

1. Translator produces translations
2. Sends a JSON/spreadsheet file to the human reviewer
3. Reviewer opens it in an editor, makes corrections
4. Sends the corrected file back
5. Translator incorporates corrections manually

### Future (Interactive) Workflow

1. Translator produces translations
2. Packages them as encrypted JSON with a review UI schema:
```json
{
  "workflow": "translation_review",
  "source_language": "en",
  "target_language": "pt-BR",
  "strings": [
    {
      "id": "hero.tagline",
      "original": "Your files, your keys, your privacy",
      "proposed": "Seus arquivos, suas chaves, sua privacidade",
      "context": "Main page hero section tagline",
      "status": "pending_review"
    },
    {
      "id": "upload.button",
      "original": "Encrypt & Send",
      "proposed": "Criptografar e Enviar",
      "context": "Primary action button on upload page",
      "status": "pending_review"
    }
  ]
}
```
3. Sends via SG/Send to the human reviewer
4. Reviewer opens the link, decrypts on their device, and sees:

```
┌─────────────────────────────────────────────────────────┐
│  Translation Review: English → Brazilian Portuguese      │
│  20 strings to review                                    │
│                                                          │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ hero.tagline                                         │ │
│  │ EN: "Your files, your keys, your privacy"            │ │
│  │ PT: "Seus arquivos, suas chaves, sua privacidade"    │ │
│  │                                                       │ │
│  │ [✓ Approve]  [✎ Edit]  [✗ Reject]                   │ │
│  │                                                       │ │
│  │ Comment: ________________________________             │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                          │
│  ┌─────────────────────────────────────────────────────┐ │
│  │ upload.button                                        │ │
│  │ EN: "Encrypt & Send"                                 │ │
│  │ PT: "Criptografar e Enviar"                          │ │
│  │                                                       │ │
│  │ [✓ Approve]  [✎ Edit]  [✗ Reject]                   │ │
│  │                                                       │ │
│  │ Comment: ________________________________             │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                          │
│  Progress: 0/20 reviewed                                 │
│                                                          │
│  [Submit Review]                                         │
└─────────────────────────────────────────────────────────┘
```

5. Reviewer approves, edits, or rejects each string, adds comments
6. Clicks "Submit Review"
7. The response JSON is encrypted on their device and sent back via SG/Send:
```json
{
  "workflow": "translation_review_response",
  "reviewer": "Maria Silva",
  "reviewed_at": "2026-02-16T10:30:00Z",
  "strings": [
    {
      "id": "hero.tagline",
      "status": "approved",
      "final": "Seus arquivos, suas chaves, sua privacidade"
    },
    {
      "id": "upload.button",
      "status": "edited",
      "original_proposed": "Criptografar e Enviar",
      "final": "Criptografar & Enviar",
      "comment": "Keep the ampersand - it's used in Brazilian tech UIs"
    }
  ]
}
```
8. Translator automatically incorporates the approved/edited translations

The entire workflow is encrypted end-to-end. The server never sees the translation strings. The reviewer never needs special software — just a browser and their SG/Send token.

---

## Use Case 2: Client-Side Translation as a Product Feature

Building on the Translator role's evolution toward customer-facing features:

### The Concept

When a user sends a file or text through SG/Send, they can optionally request that the recipient receive it in a different language. The translation happens:

**Option A: Client-side LLM** — the recipient's browser translates the content using a local/WASM LLM. Maximum privacy — the untranslated content is never sent to any server, and neither is the translated version.

**Option B: LLM API call** — the recipient's browser sends the decrypted content to a translation API (Claude, GPT, or a language-specific model) for higher-quality translation. The user consents to this — they know the content leaves their browser for translation.

**Option C: Pre-translated by sender** — the sender uses the Translator pipeline to pre-translate the content before sending. The recipient receives both the original and the translation, encrypted together.

### Why This Matters

- The sender writes in English, the recipient reads in Portuguese — seamlessly
- The content is still encrypted in transit and at rest on the server
- Translation is a value-add feature that users would pay for (P&L for the Translator role)
- Positions SG/Send not just as "secure file transfer" but as "secure cross-language communication"

**The enterprise dimension**: for corporate customers, translation goes beyond language. A multinational with subsidiaries and acquired companies needs content translated not just into French or Japanese, but into each entity's specific **brand voice and cultural identity**. An acquired company in Brazil that retained its brand doesn't want mothership-tone communications — they want their own voice. SG/Send can offer per-entity **translation profiles** (language + culture + brand voice + glossary), turning every corporate entity into a billable translation target. The interactive encrypted workflow pattern (Use Case 1) is how the translation review and approval process works across these entities — all encrypted, all tracked. See the Translator role definition for the full corporate translation vision.

### Architecture Notes

The translation feature is a callback on top of the transfer engine — just like encryption. The pipeline is:

```
upload → compress → encrypt → transfer → decrypt → decompress → [translate] → display
```

Translation is optional, pluggable, and happens after decryption on the client. The transfer engine doesn't know or care about translation — it just delivers bytes.

---

## Use Case 3: General-Purpose Encrypted Workflows

The translation review is one specific case of a general pattern: **structured data exchange with interactive UIs, all encrypted.**

Other workflows this enables:

- **Document approval**: send a contract, recipient sees a review interface with approve/reject/comment per section
- **Survey/feedback collection**: send a structured questionnaire, recipient fills it in, response comes back encrypted
- **Code review**: send a diff, recipient sees a side-by-side view with inline comments
- **Data collection forms**: send a form schema, recipient fills in the fields, structured data comes back
- **Multi-party approval**: send to multiple recipients, collect all approvals, aggregate results — all encrypted
- **Corporate translation review**: headquarters sends content, each subsidiary/acquired company reviews in their specific brand voice and language, corrections flow back — per-entity translation profiles with accumulated glossaries
- **Customer support**: structured support ticket form (see Villager brief for the `support` token concept)

### The UI Component Library

For this to work, we need a **well-defined set of browser UI components** that the schema can reference:

| Component | Purpose |
|---|---|
| `text-input` | Single-line text entry |
| `text-area` | Multi-line text entry |
| `dropdown` | Select from a list |
| `checkbox` | Boolean toggle |
| `radio-group` | Select one from options |
| `approval-buttons` | Approve / Edit / Reject pattern |
| `diff-viewer` | Side-by-side text comparison |
| `comment-field` | Contextual comment attached to another element |
| `progress-bar` | Shows completion (X of Y reviewed) |
| `file-upload` | Attach a file to the response |
| `rating` | Star rating or numeric scale |
| `date-picker` | Date selection |
| `signature` | Digital signature / confirmation |

The components are standard HTML/CSS/JS — no framework required. They render from the JSON schema. They're styled with the same theme system the main site uses (Aurora, Glacier, Ember, etc.).

**The LLM dynamic generation**: given a data structure and a workflow description, an LLM generates the appropriate schema using these components. The schema is deterministic (same input always produces the same UI), but the generation is flexible (the LLM can create novel layouts from the component library).

---

## Security Model

This all works because of one key property: **the server is a dumb pipe.**

- The server stores encrypted bytes. It doesn't know if those bytes are a file, text, JSON, or a UI schema.
- The UI rendering happens on the client, after decryption.
- The response is encrypted on the client before being sent back.
- The server never sees the content, the form, or the response.

The security model is identical to a normal SG/Send transfer. The "interactive workflow" is entirely a client-side concern — the server's job doesn't change at all.

### The Trust Model

The recipient trusts the UI schema because:
1. It was encrypted by the sender (same trust model as any SG/Send transfer)
2. The UI components are from a known, audited component library (no arbitrary code execution)
3. The schema is declarative, not executable — it describes what to render, not what to run
4. The browser renders it in a sandboxed context

This is important: the schema should NEVER include executable JavaScript. It's a declarative description. The renderer interprets it. This prevents injection attacks via the schema.

**AppSec**: review this security model. Specifically: how do we ensure the schema can't be used to exfiltrate decrypted data? The renderer must be carefully sandboxed.

---

## Research Tasks

| Task | Owner(s) | Priority |
|---|---|---|
| Design the UI component library (component types, properties, schema format) | Architect, Designer | **P2** |
| Prototype: render a simple form from a JSON schema (encrypted round-trip) | Dev | **P2** |
| Prototype: translation review workflow using the interactive form pattern | Dev, Translator | **P2** |
| Research: client-side LLMs for translation (WASM models, quality, performance) | Architect | **P3** |
| Research: LLM-generated UI schemas (can Claude/GPT reliably produce valid schemas from descriptions?) | Architect, Dev | **P3** |
| Security review: schema injection risks, renderer sandboxing | AppSec | **P2** |
| Design: how does JSON in → JSON out interact with the transfer manifest? | Architect | **P3** |

---

## For the Conductor

This is a medium-term exploration, not an immediate build. But the research should start now because:

1. The **translation review workflow** (Use Case 1) is needed soon — the Translator role is live and will need human reviewers
2. The **UI component library** has value beyond this feature — it's useful for the admin dashboard, the SA visualisations, and the landing page
3. The **client-side translation** concept (Use Case 2) is a potential revenue feature with P&L implications — the Translator role's evolution depends on it
4. The **security model** needs early review — if AppSec identifies fundamental issues, we want to know before investing in implementation

Start with Use Case 1 (translation review). It's the most concrete, most immediately useful, and smallest in scope. If it works for translation review, the pattern works for everything else.

The general insight: **SG/Send is not just a file transfer tool. It's an encrypted communication platform. Structured data with interactive UIs is just one way communication can work.**
