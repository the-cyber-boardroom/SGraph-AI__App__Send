# Daily Brief: 13 February 2026

**version** v0.2.16  
**date** 13 Feb 2026  
**from** Human (project lead)  
**to** All roles via Conductor  

---

## The Big News

Yesterday we shipped our first proper MVP. The domain is live, the waiting list is enabled, and the flow is happening. This is real. We had our first actual user use the product — and I was watching.

---

## First User Feedback

Overall impression: **positive**. Once the user saw the end-to-end flow working, the reaction was "this is quite useful, this is cool." That's the right signal.

But — predictably — the user got stuck on some of the actions. Here's what I observed:

### What Worked
- Typing `send.sgraph.ai` was easy and intuitive
- The file upload worked nicely
- Once the user understood the flow end-to-end, the value was clear

### Where the User Got Stuck

**"What do I do? What is this for?"** — the page doesn't explain itself well enough. The user had a moment of confusion before understanding what the service does. We need to add clear, simple explanation content to the page — maybe a diagram or two, maybe an image. The core message: **you're sending a file**. That's the feature. The fact that it's secure and browser-based is what builds trust, but it's not the headline. The headline is: send a file. Securely. Simply.

**Too many steps in the current workflow** — right now the user has to: drag and drop a file, copy the link, copy the key, send both to the recipient separately. That's too much friction for early users. We need to simplify this dramatically (see the hash-in-URL proposal below).

**The download link** — once the file was uploaded, the link to download worked, but the drag-and-drop of the link itself would make this easier (from the page). The link from Chrome's download pane worked really well.

### The Domain Question

Interesting feedback: the user immediately asked **"why .ai? What are you doing with AI behind the scenes?"** This is a product built BY an agentic AI team, but it doesn't use AI inline — it's a zero-knowledge encryption service. The .ai domain creates an expectation we're not meeting.

I have both `sgraph.ai` and `sgraph.com`. We should add this to our user research questionnaire:
- Which domain has more trust?
- Which do users prefer: `send.sgraph.ai` or `send.sgraph.com`?
- Does .ai create confusion about what the product does?

**Advocate + Sherpa**: capture this as a persona/user research question. **Ambassador**: this has positioning implications — does the .ai domain help or hurt our market positioning for a privacy/security product?

---

## Priority UX Changes

### 1. Hash Fragment for One-Click File Access

This is the single most impactful UX improvement we can make right now.

Instead of requiring the user to copy a link AND a key separately, we put the decryption key in the URL hash fragment (the `#` part of the URL). The hash fragment never leaves the client — it's not sent to the server in the HTTP request. This means:

- The user gets a single link they can share
- The recipient clicks the link and sees the file immediately
- The key stays client-side — our zero-knowledge promise is maintained

**Architect + AppSec**: review this approach. Confirm that the hash fragment genuinely doesn't leave the client (my understanding is it doesn't, but let's verify). Assess any security implications. This is a significant change to the trust model — get it right.

**Dev**: once confirmed, implement this. It should dramatically simplify the sharing workflow from "copy link + copy key + send both" to "copy one link + send it."

### 2. Add a Text Input

Right now you can only send files. We should also allow sending text — paste text, encrypt it, share it.

Why this matters:
- It makes testing trivially easy (send "hello world" instead of creating a file to upload)
- First-time users want to verify the system works before trusting it with real files — a text "hello world" is the perfect first experience
- Small messages, notes, passwords, credentials — lots of use cases that don't require a file

**Dev + Designer**: add a text input alongside the file drag-and-drop. The user can send files, text, or both.

### 3. Explain What the Service Does

The landing page needs clear, simple content that answers "what is this?" in seconds:
- What it does (send a file securely)
- How it works (browser-side encryption, zero-knowledge)
- How to use it (1-2-3 steps)
- Maybe a diagram or illustration showing the flow

Don't over-explain. Don't lead with the security angle. Lead with the utility: **send a file**. The security is what makes it trustworthy, not what makes it useful.

**Designer + Journalist**: collaborate on this. Designer does the layout and visual elements. Journalist writes the copy. **Advocate**: review it — does this explain the product in a way our personas would understand in 10 seconds?

### 4. Fix Drag-and-Drop of the Download Link

The download link should be draggable (into an email compose window, into a chat, etc.). Check if this is broken and fix it.

**Dev**: investigate and fix.

---

## Admin Tokens

We need to start building the admin interface. Priority: the token system that lets us invite users from the waiting list.

### What's Needed

**Token creation UI**: admin interface to generate invitation tokens. Same visual coding style as the existing UI.

**Token visualisation UI**: see all created tokens — which are active, which have been used, when they were used.

**Token sharing UI**: easy way to share tokens with waiting list users. This should generate a URL with the token embedded (not in the hash this time — we want the backend to know when the page is opened, to measure adoption and activation).

**Backend storage**: index by token. Each token becomes a key in the storage — makes it easy to filter, manage, and track the lifecycle of each invitation.

### The Flow

1. Admin creates a batch of tokens
2. Admin gets shareable links (one per token, with the token in the URL)
3. Admin sends links to waiting list users
4. When user opens the link, we know (backend sees the token in the URL)
5. We can track: how many tokens created, how many links opened, how many resulted in actual usage

**Architect**: design the token storage schema (indexed by token). **Dev**: implement the creation, visualisation, and sharing UIs. **Sherpa**: this is a key onboarding moment — the first time a waiting list user activates. Track the trail.

---

## Observability: Start Collecting Everything

This is a major theme for today. We need to start capturing data from all available sources. I'm going to share example code to build on.

### The Architecture: Collect → Store → Visualise

**Collector pattern** (load, extract, save):
- A collector that can run individually, on demand, or on schedule
- Goes to each data source (AWS logs, Google Analytics, application events)
- Saves to a folder structure in S3
- Is intelligent: tracks when it last fetched data from each source, doesn't fetch the same data twice
- Eventually we'll parse this with the M graph database / memory FS / caching — but for now, just grab the data and save it

**S3 as the offline data lake**:
- Build an offline copy of all collectible data in S3
- Folder structure by source and time period
- Keep track of high-water marks (last timestamp fetched per source)
- This becomes the foundation for all analytics, trail observation, and dashboards

**Visualisation layer**:
- UI to explore the collected data
- Dashboards for key metrics
- Eventually feeds the sherpa's trail observation

### What to Collect

**DevOps**: I need a comprehensive brief on every AWS setting I should be enabling for logging and observability. CloudFront access logs, Lambda execution logs, S3 access logs, API Gateway logs, WAF logs — everything. What's available? What's currently enabled? What should we turn on? What will it cost?

**Google Analytics**: we already have GA wired up. Can we pull the GA data into our S3 data lake as well? I want all the data in one place.

**Application events**: we already log events (file created, file viewed, file downloaded, etc.). These should also flow into the collection pipeline.

### UI: Expose Event Data to Users

We already have event data for each file (created, viewed, downloaded, etc.). We should expose this in the UI — show the user how many times their file was viewed, how many times it was downloaded, all the events we track.

This is both a useful feature (the sender gets visibility into what happened to their file) and a trust-building feature (transparency about what we track).

**Dev + Designer**: add an event log / activity view to the file page. **Sherpa**: this is trail data made visible to the user — review from a UX perspective. **DPO**: review from a data protection perspective — are we showing the right data? Are we exposing anything we shouldn't?

---

## Multilingual, Themes, and Sharing (From Previous Briefs)

These are covered in detail in earlier documents but I want to flag them as active priorities — they should be moving forward alongside today's UX and observability work.

### Multilingual Website

We need to start decoupling content from UI. Every piece of user-facing text should be externalized into a translation layer so we can support multiple languages. This isn't a "nice to have later" — it's an architectural decision that gets harder to retrofit the more UI we build.

Start with English (en) and Portuguese (pt) as the first two languages. The synthetic user definitions already anticipate this (`user_friendly_en`, `user_friendly_pt`). The content layer should support adding new languages without touching the UI code.

**Architect + Dev**: design the i18n approach now, before we add more UI content (the explanatory landing page text, the admin token UI, the event log view — all of it should go through the translation layer from day one). **Journalist**: you'll be authoring a lot of the user-facing copy. It needs to be authored into the translation system, not hardcoded.

### Multiple Themes

We need theme support with at least five variants:

- **Accessibility: Dark Mode** — for low-light environments and user preference
- **Accessibility: High Contrast** — for colour-blind users and visual impairment (maps to the `user_friendly_colourblind` synthetic user)
- **Aurora** — a clean, modern default theme
- **Glacier** — a cool, minimal, trust-evoking theme (blues, whites — lean into the security positioning)
- **Ember** — a warm, approachable theme (warmer palette — lean into the "easy to use" positioning)

The theme system should be CSS-variable-based so switching themes is a single class change. The synthetic users will test each theme variant, so the sherpa can compare trail data across themes (do users with high-contrast mode have different friction points?).

**Designer**: define the five theme palettes and the CSS variable system. **Dev**: implement the theme switching mechanism. **QA**: ensure synthetic user scripts cover each theme variant. **Advocate**: which themes should be the default for which personas?

### Email Sharing: Copy Text and Gmail Link

The sharing flow needs two email-friendly options:

- **Copy as text**: copies a pre-formatted message to clipboard that the user can paste into any email client. Should include the link, a brief explanation of what it is, and basic instructions for the recipient ("click to access your secure file").
- **Open in Gmail**: a `mailto:` or Gmail compose link that pre-populates the email with the same formatted message. One click from our UI → Gmail compose window with everything ready to send.

Both should use the new hash-in-URL format (once confirmed safe) so the recipient gets a single link to click.

**Dev + Designer**: implement both sharing options. **Journalist**: write the email template text — this is the first impression for recipients who've never seen SGraph Send. **Ambassador**: this is a viral loop touchpoint — every shared email is a potential new user acquisition. **Sherpa**: track which sharing method users prefer (copy text vs Gmail link).

---

## Task Summary

| Priority | Task | Owner(s) |
|----------|------|----------|
| **P1** | Review hash-fragment approach for one-click file access | Architect, AppSec |
| **P1** | Implement hash-in-URL once confirmed safe | Dev |
| **P1** | Add text input for sending text (not just files) | Dev, Designer |
| **P1** | DevOps brief on all AWS observability settings | DevOps |
| **P2** | Add explanatory content to landing page | Designer, Journalist, Advocate |
| **P2** | Build admin token creation/visualisation/sharing UI | Dev, Architect |
| **P2** | Fix drag-and-drop of download link | Dev |
| **P2** | Start building the collector pipeline (S3 data lake) | Dev, DevOps |
| **P2** | Expose file event data in the UI | Dev, Designer |
| **P2** | Design i18n / translation layer (decouple content from UI) | Architect, Dev |
| **P2** | Implement theme system (5 themes: Dark, High Contrast, Aurora, Glacier, Ember) | Designer, Dev |
| **P2** | Add "copy as text" and "open in Gmail" sharing options | Dev, Designer |
| **P2** | Write email sharing template text | Journalist, Ambassador |
| **P3** | Add domain preference question to user research | Advocate, Sherpa, Ambassador |
| **P3** | DPO review of event data exposure in UI | DPO |
| **P3** | Pull Google Analytics data into S3 collection | DevOps |

---

## For the Conductor

Yesterday was a milestone — first real MVP, first real user. Today's theme is twofold: **simplify the UX** (hash-in-URL, text input, explanatory content) and **build the observability pipeline** (collect everything, store in S3, start visualising).

In parallel, three architectural investments need to start moving: **i18n** (decouple content from UI before we add more content), **themes** (five variants including accessibility), and **email sharing** (copy text + Gmail link — viral loop touchpoint).

The UX changes are user-facing and urgent — every new user we invite from the waiting list will hit the same friction points. The i18n decision is architecturally urgent — the longer we wait, the more content gets hardcoded. The observability pipeline is infrastructure that enables the sherpa, the dashboards, and all future analytics.

Sequence accordingly. The hash-in-URL review is the gating item — nothing else in the UX track can move faster than the architect and AppSec confirming the approach is safe. The i18n architecture decision should be made before the designer and journalist produce the new landing page content — that content should go through the translation layer from the start.

Let's have an exciting day.
