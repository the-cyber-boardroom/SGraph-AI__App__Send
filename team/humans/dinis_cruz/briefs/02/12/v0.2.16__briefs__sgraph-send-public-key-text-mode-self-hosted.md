# SGraph Send: Public Key Encryption, Text Mode, and Self-Hosted Scenarios

**version** v0.2.16  
**date** 12 Feb 2026  

## The Core Question

**How do I send something to somebody that only THAT person can read?**

Right now, SGraph Send creates a symmetric key for each file. Anyone who sees the key can decrypt it. That's fine for many use cases, but it doesn't solve the "only the intended recipient can read this" problem.

---

## Feature 1: Public/Private Key Support

### How it works

Standard public key infrastructure, implemented in JavaScript (client-side, zero-knowledge stays intact):

1. The recipient has a public/private key pair
2. The recipient shares their public key (on their profile page, in a directory, via GPG keyservers — wherever)
3. The sender encrypts the file/message using the recipient's public key
4. Only the recipient can decrypt it with their private key
5. The encrypted content can travel through any channel — email, chat, public internet — and it doesn't matter who sees it

### The website integration

If the recipient has a page on the SGraph Send website, that page can:

- Display their public key (for people who want to use it manually)
- Provide a **"Send message here" box** — the sender just types or uploads, the page encrypts with the recipient's public key automatically, and delivers

The sender doesn't even need to understand public key crypto. They just go to the person's page and send. The encryption happens transparently.

### SGraph Send as an entity

SGraph Send itself should have a public key and a "send us a message" page. Dogfooding again — use our own product for receiving feedback, interview results, bug reports, anything users want to send us securely.

### GPG compatibility

GPG already has key directories and a well-established ecosystem. We should explore interoperability — can we import GPG public keys? Can we participate in the existing web of trust? This isn't a must-have for MVP, but worth understanding the landscape.

---

## Feature 2: Pre-Shared Recipient Key

### A simpler variation

Instead of full public/private key infrastructure, there's a simpler mode: the recipient shares their decryption key with the sender out of band. Then the sender uses that key for ALL messages to that recipient.

### The workflow

1. Recipient generates a key (or we generate one for them)
2. Recipient shares it with the sender (once, out of band — in person, via secure channel, whatever)
3. From then on, the sender uses that key to encrypt anything they send to that recipient
4. The recipient uses the same key to decrypt

### Why this might be simpler

- No public key infrastructure needed
- The key exchange happens once, then it's reused
- Could still be symmetric encryption (simpler implementation)
- Feels more intuitive: "here's my key, use it to send me stuff"

### Trade-offs vs public/private key

- Less secure if the pre-shared key is compromised (all past and future messages are exposed)
- Requires a secure out-of-band channel for the initial key exchange
- Doesn't provide sender authentication (anyone with the key can send)

### Discovery through usage

We don't need to decide which model is "right" — we can ship both and see which users prefer. Market research and actual usage will tell us.

---

## Feature 3: Text Mode

### The simple ask

Sometimes you don't want to share a file. You just want to send some text — paste some information, share an interview result, send a snippet. Right now, SGraph Send only does file upload.

Add a **text box** alongside file upload. The user pastes text, it gets encrypted and shared the same way as a file. Simple.

### Use case that triggered this

The interview workflow we're building — someone completes a voice-mode interview in ChatGPT, has the results as text, wants to share them back securely. They should just paste the text into SGraph Send, not save it as a file first.

### Implementation

This should be straightforward. The text becomes the content to encrypt — same pipeline as a file, just the input mode is different.

---

## The Educational Angle

There's an interesting opportunity here: as we add features like public/private key support and explain how they work, SGraph Send becomes **educational**. Users learn how encryption actually works. The help pages and guidance become a gentle introduction to:

- Symmetric vs asymmetric encryption
- Why zero-knowledge matters
- How public/private keys work
- What "only you can read this" actually means technically

This aligns with the open source nature of the project. It's not a black box — users can understand, verify, and trust the system because they can see how it works.

---

## The Self-Hosted Angle

Because SGraph Send is open source and deployable anywhere, these features become even more powerful:

- **Run it locally** — spin up a Docker container on your laptop. Load it up only when you have a message to decrypt. Nothing persistent, nothing exposed.
- **Run it inside a company** — deploy internally for sharing secrets between teams. No data leaves the network.
- **Run it as a personal decryption station** — your public key is published, people send you encrypted messages to the hosted service, you decrypt locally on your own machine.

The Docker/local scenario is interesting for high-security users: you only run the decryption service when you need it, on hardware you control. No always-on server to attack.

---

## Priority and Sequencing

| Feature | Complexity | Value | Suggested order |
|---------|-----------|-------|----------------|
| Text mode | Low | High (immediate usability win) | **First** |
| Pre-shared recipient key | Medium | Medium (simpler workflow) | Second |
| Public/private key support | Higher | High (the real "only you can read" solution) | Third |
| "Send message here" page | Medium | High (great UX for recipients) | After public key support |
| GPG interoperability | Medium | Medium (ecosystem integration) | Later |
| Self-hosted Docker mode | Low-Medium | Medium (power users) | Can be parallel |

Text mode is the quick win — minimal implementation, immediate value. Ship it with the friendlies MVP.

---

## For the Agents

- **Architect**: design the public/private key workflow. What JavaScript crypto libraries do we need? How does key generation, storage, and exchange work client-side? How does this integrate with the existing symmetric encryption pipeline? Also: is the pre-shared key mode just a UX layer on top of the existing symmetric approach?
- **Dev**: text mode first — add a text input alongside file upload, same encryption pipeline. This should be shippable quickly.
- **AppSec**: threat model both new encryption modes. For public/private key: what are the risks of client-side key generation in JavaScript? For pre-shared key: what are the implications of key reuse across multiple messages? Also review the "send message here" page concept — any risks in having a public submission endpoint?
- **Designer**: UX for the three input modes (file upload, text paste, "send to recipient" via public key). How do we present these without overwhelming the user? The educational angle needs design thought too — how do we explain encryption simply?
- **Marketing**: the "only you can read this" pitch and the self-hosted angle are strong differentiators. How do these features change the positioning? Which personas care most about public key support vs simplicity?
- **QA**: test the encryption round-trip for text mode (encrypt text → share → decrypt → verify identical). For public/private key: test key generation, encryption with public key, decryption with private key, cross-browser compatibility.
