# Villager Team: First Brief

**version** v0.3.2  
**date** 14 Feb 2026  
**from** Human (project lead)  
**to** Villager team via Conductor  
**note** This brief is for the Villager team only. The Explorer team does not need to read this — they're focused on their next phase of development.  

---

## Context

This is the first brief directed specifically at the Villager team. From now on, daily briefs will be team-specific — the Explorer team gets Explorer briefs, the Villager team gets Villager briefs. They don't need to be shared between teams unless there's a cross-team dependency.

The Explorer team has produced its first set of components that are mature enough to pinch. The Villager team's first mission: **productise these into the first production release.**

---

## What You're Productising

Four modules are ready to move from Explorers to Villagers (as documented in the Wardley Maps brief):

1. **Browser-side encryption flow** — the client-side encrypt/decrypt using Web Crypto API
2. **File upload/download flow** — drag-and-drop upload, S3 storage, download via link
3. **S3 storage backend** — Lambda functions, API Gateway, S3 bucket operations
4. **Token/invitation system** — token creation, validation, usage tracking

These four modules together form the end-to-end MVP: a user can log in with a token, upload a file, encrypt it, share a link, and the recipient can download and decrypt it.

Your job: take these four modules and produce a production-ready release.

---

## The Production Pipeline

You are running the **production pipeline**. This is fundamentally different from the Explorer's development pipeline:

- This is the code that ships to real users
- This is the code that needs to run all the time
- This is the code that must never be impacted by normal development activity
- This pipeline will have its own Dev → QA → Prod stages, but all within the Villager's domain

You still have Dev, QA, and Prod environments — but they're YOUR Dev, QA, and Prod. Completely separate from the Explorer's environments. No cross-contamination.

---

## The IFD Release Process

### How Versioning Works

The Explorer team has been creating minor versions — incremental iterations where each version builds on the previous one. They might be at version 0.2.17 with dozens of small files loaded incrementally.

The Villager's job is to **consolidate** those minor versions into a major version (release). Here's the versioning scheme:

```
EXPLORER (minor versions, incremental)          VILLAGER (major versions, consolidated)
──────────────────────────────────────          ────────────────────────────────────────

0.2.1  (first iteration)                        
0.2.2  (adds feature A)                         
0.2.3  (adds feature B)                         
0.2.4  (fixes bug in A)                         
  ...                                           
0.2.7  ◄── agreed: this is mature enough ──►    0.3.0 (consolidated release of 0.2.7)
  ...                                           
0.2.9  (Explorer keeps going)                   
0.2.12                                          
0.2.15 ◄── next agreed handover ──────────►     0.4.0 (consolidated release of 0.2.15)
```

Key points:

- **The handover version is chosen deliberately.** It might not be the latest Explorer version. In this example, we agreed that 0.2.7 is good enough to release, even though the Explorer team has already moved on to 0.2.9 or 0.2.15. The version that gets productised is the one that's been agreed as stable, not necessarily the most recent.
- **The Villager's release gets the next major version number.** The Explorer's 0.2.7 becomes the Villager's 0.3.0 (the first production release of the 0.3 series).
- **The first digit is the production version.** Major launches increment the first number. We're still at 0.x, so everything is pre-1.0.

### What Consolidation Means

The Explorer phase optimises for **ease of change and blast radius understanding**. This means lots of small files — 20, 30, 50 files for a single component. Each minor version adds files incrementally. It's fine to load many files because the priority is being able to change one thing without breaking another.

The Villager phase optimises for **performance and reliability**. This means consolidation:

- **JavaScript**: all the incremental JS files get consolidated into a single (or minimal set of) files. No loading 50 separate scripts. One file with everything, optimised for delivery.
- **HTML**: same principle. Consolidated into clean, minimal HTML files.
- **CSS**: consolidated and optimised.
- **API endpoints**: the Explorer might have five versions of a utility function accumulated over iterations. The Villager consolidates to one.
- **Backend Lambda functions**: review, consolidate, remove dead code, ensure clean single-purpose functions.

Think of it as: the Explorer creates a branch with many small commits. The Villager squashes, refactors, and consolidates into a clean codebase that's feature-identical but structurally optimised.

You might even package everything into a deployable bundle — one file with all the JavaScript, one with all the HTML, one with all the building blocks. Maximise for download performance and runtime efficiency.

### A Caveat for This First Release

This is the first time we're doing this. There will be more coding involved than in future releases, because:

- We're establishing the consolidation process for the first time
- We're refactoring incremental code into consolidated code for the first time
- We're setting up the production infrastructure for the first time
- We're building the deployment pipeline for the first time

By the second, third, fourth release, this will be much tighter. The process will be established, the pipeline will exist, and each release will be a smoother handover. But this first one is foundational work — expect it to take more effort.

---

## Unit Tests: The Feature Equivalence Guarantee

This is critical. Unit tests are how we prove that the Villager's consolidated code is **feature-equivalent** to the Explorer's incremental code.

### The Principle

The unit tests from the Explorer's version (the one being productised) should run against the Villager's consolidated version **with minimal or no changes**.

```
EXPLORER version 0.2.7                    VILLAGER version 0.3.0
─────────────────────────                  ──────────────────────

  Code: 50 incremental files      ──►     Code: 5 consolidated files
  Tests: test suite for 0.2.7     ──►     Tests: same suite, same assertions
                                          
  All tests pass ✓                        All tests must pass ✓
```

If the Explorer's tests pass against the Explorer's code AND against the Villager's code, we know the consolidation preserved functionality. The tests are the proof.

### What Gets Tested

- Unit tests from the Explorer version
- Use case tests (end-to-end user flows)
- Browser automation tests (Playwright synthetic users)
- Any existing test suite from the Explorer phase

All of these should pass against the Villager's consolidated code. If a test fails, it means the consolidation changed behaviour — which is not allowed. Fix the consolidation, not the test.

### Tests as Bellwether

Over time, as tests get better and more comprehensive, they become the definitive quality gate for releases. If all previous tests pass, all use cases pass, all browser automation passes — we know we have feature equivalence. This is the Villager's primary quality assurance mechanism.

---

## Git Strategy

### Separate Repo

The Villager team operates in a **separate repository** from the Explorer team. This is necessary because:

- The role definitions are different (Villager-mode roles, not Explorer-mode roles)
- The infrastructure configuration is different (production vs development)
- The deployment pipeline is different
- The file structure is different (consolidated vs incremental)
- We need clean separation to avoid cross-contamination

### Bringing Explorer Code In

When a handover occurs, the Explorer's code needs to be brought into the Villager's repo. The process:

1. The agreed Explorer version (e.g., 0.2.7) is identified
2. The code is brought into the Villager repo — effectively a pull request from the Explorer codebase
3. The Villager team consolidates and refactors
4. The result is committed as the new Villager release version

**Research needed (DevOps + Architect):** what's the cleanest Git workflow for this? Options to evaluate:

- **Git subtree or submodule**: bring Explorer code in as a subtree, then consolidate in-repo
- **Manual import with hash references**: copy the code, reference the Explorer commit hash for provenance
- **Fork-and-squash**: fork the Explorer repo at the agreed version, squash and consolidate, then maintain as independent repo
- **Cherry-pick**: selectively bring in commits from the Explorer repo

The key requirements:
- **Provenance**: we must be able to trace every line of Villager code back to the Explorer commit it came from. This is a security requirement — the commit chain is part of our integrity guarantee.
- **Clean history**: the Villager repo's history should tell the story of releases, not the story of exploration. Keep it clean.
- **Repeatability**: the process should work the same way for every future handover, not just this first one.

### The Return Path: Villager → Explorer

After the Villager produces a consolidated release, that code needs to come back to the Explorer repo. This is the synchronisation step:

```
EXPLORER                          VILLAGER
────────                          ────────

0.2.7  ──── handover ────────►   receives 0.2.7
0.2.8  (keeps going)             consolidates...
0.2.9  (keeps going)             0.3.0 release ✓
  │                                    │
  │◄──── pull request ────────────────┘
  │      (bring consolidated code back)
  │
0.2.10 (now based on consolidated code + new work)
```

The Explorer team receives a pull request from the Villager repo containing the consolidated code. This ensures:

- The Explorer codebase is synchronised with what's in production
- Future Explorer work builds on the clean, consolidated foundation
- There's no drift between what the Explorer thinks is in production and what actually is

If the Explorer team made no changes since the handover (unlikely but possible), there should be zero difference between the Explorer and Villager codebases after the PR. In practice, there will be Explorer changes that need to be reconciled — but the PR process handles that.

### Measuring Handover Overhead

We should measure how much effort each handover takes. The goal is to reduce this over time:

- **First handover** (this one): significant effort. Establishing the process, first consolidation, first infrastructure setup. This is expected.
- **Second handover**: should be meaningfully less effort. Process is established, infrastructure exists, we know the pitfalls.
- **Third+ handover**: should be routine. The overhead of pinching should be minimal and predictable.

If the handover overhead isn't decreasing, something is wrong with the process. Track it, measure it, improve it.

---

## Infrastructure Setup

The Villager team needs its own AWS infrastructure. This is the first task:

### What's Needed

- **Separate AWS account or environment** (isolated from Explorer)
- **S3 buckets** for production file storage
- **Lambda functions** for production API
- **CloudFront distribution** for production content delivery
- **API Gateway** for production API endpoints
- **Monitoring and alerting** (CloudWatch, or whatever we establish as the observability stack)
- **Deployment pipeline** (CI/CD from the Villager repo to production)

### Configuration Principles

- **Infrastructure as code**: every piece of infrastructure should be defined in code, committed to the Villager repo. No manual AWS console configuration.
- **Reproducible**: the entire production environment should be recreatable from the repo. If we lose everything, we can rebuild from code.
- **Monitored**: full observability from day one. We don't deploy to production and then add monitoring later.
- **Separate domains**: production should be on its own domain/subdomain, distinct from any Explorer development URLs.

**DevOps**: this is your primary workstream. Set up the production AWS environment, the deployment pipeline, and the monitoring. This is foundational — nothing else ships until this exists.

---

## Task Summary

| Priority | Task | Owner(s) |
|----------|------|----------|
| **P1** | Set up Villager repo (separate from Explorer) | DevOps, Conductor |
| **P1** | Set up production AWS infrastructure (separate environment) | DevOps |
| **P1** | Research Git workflow for Explorer → Villager code transfer (with provenance) | DevOps, Architect |
| **P1** | Build production deployment pipeline (CI/CD) | DevOps |
| **P1** | Consolidate Explorer 0.2.x code into Villager 0.3.0 (JS, HTML, CSS, Lambda) | Dev |
| **P1** | Run Explorer test suite against consolidated code — all must pass | QA, Dev |
| **P2** | Set up production monitoring and alerting | DevOps |
| **P2** | Create production runbooks (deployment, rollback, incident response) | DevOps, CISO |
| **P2** | Security review of consolidated code for production deployment | AppSec, CISO |
| **P2** | DPO review of production data handling | DPO |
| **P2** | Research Git workflow for Villager → Explorer return path (PR back) | DevOps, Architect |
| **P3** | Measure and document handover overhead (baseline for improvement) | Conductor |
| **P3** | GRC compliance check for production release | GRC |

---

## For the Conductor

This is the Villager team's first mission. The primary deliverable is **version 0.3.0** — the first consolidated production release.

The critical path is: repo setup → infrastructure setup → code consolidation → test verification → security review → deploy.

The Git workflow research (how to transfer code between repos with provenance) is a gating decision — resolve it before starting the consolidation, so we don't have to redo the work.

Expect this first release to take more effort than future ones. That's fine. We're building the pipeline. By release 0.4.0, this should be significantly smoother.

The Explorer team continues independently. They don't need to wait for us, and we don't need to wait for them (beyond receiving the agreed handover version). The synchronisation happens after we produce the release, via the return PR.

Let's build the production pipeline and ship the first release.
