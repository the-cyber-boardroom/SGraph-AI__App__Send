# Architecture Brief: Identity Spectrum and Friendly Key Search

**version** v0.5.10  
**date** 21 Feb 2026  
**from** Human (project lead)  
**to** Architect (lead), AppSec, Ambassador  
**type** Architecture brief â€” identity model and search  

---

## The Problem: Friendly Search vs Zero Plaintext

We have a working key registry where users look up public keys by short codes (e.g., `DC-7X4F`). This works, but it's not friendly. What users actually want is to search by name â€” "find Dinis Cruz" â€” and get the right public key.

The constraint: **no plaintext on the server.** The server stores only encrypted blobs and Obj_Ids. So how do you search for a name if no names exist on the server?

### Options

| Approach | How It Works | Trade-Off |
|---|---|---|
| **Client-side search** | The entire directory is downloaded (encrypted), decrypted in the browser, and searched locally. Name search happens entirely on the client. | Works within zero-knowledge model. Requires the user to have the data room key (which grants access to the directory). Doesn't scale to a global public registry. |
| **Hashed name index** | Server stores `sha256("dinis cruz")` mapped to the public key Obj_Id. Client hashes the search query and sends the hash. Server matches. | Server can't enumerate names. But rainbow table attacks on common names are trivial. Salting breaks searchability. |
| **Encrypted search index** | Homomorphic or searchable encryption schemes. Server searches encrypted data without decrypting. | Computationally expensive. Research-stage for practical use. Future option. |
| **Scoped directories** | No global search. Search is always within a data room directory (which you've already unlocked with your key). | Practical for data rooms. Doesn't solve the global "find anyone" problem. |

**Recommendation for now**: client-side search within data room directories. The user unlocks a data room (with their key), the directory is decrypted locally, and search is local. This preserves zero-knowledge completely. Global public search across all users is a future problem â€” and may require a deliberately different trust model (a public registry where users opt in to being discoverable).

---

## Identity as a Spectrum

Not all identities carry the same weight. An identity claim is only as strong as its verification. The system should track and display the verification level of every identity.

### Verification Levels

| Level | Verification Method | Strength | What It Proves |
|---|---|---|---|
| **0 â€” Self-Asserted** | User typed their name when creating a persona | None | Someone claims to be this person |
| **1 â€” Email Verified** | User received and responded to an email at the claimed address | Low | Someone controls this email address |
| **2 â€” OAuth / SSO** | User authenticated via Google, GitHub, Microsoft, etc. | Medium | An identity provider attests this is a real account |
| **3 â€” LinkedIn Verified** | User authenticated via LinkedIn OAuth, profile data matches | Medium | A professional network attests this identity and employment |
| **4 â€” Organisation Verified** | A data room admin (with admin key) added this persona to the directory | Medium-High | An organisation attests this person is their member |
| **5 â€” KYC / Government** | Identity verified by a KYC provider (Onfido, Jumio, etc.) or government-backed digital identity (eID, GOV.UK Verify) | High | A regulated entity attests this is a real person with verified documents |

### How This Appears in the UI

Each persona in a directory shows its verification level:

```
ðŸ‘¤  Dinis Cruz
    Key: sha256:3a7f...c891
    Identity: âœ“âœ“âœ“ Organisation verified (Investor Group X)
    
ðŸ‘¤  Alice Smith  
    Key: sha256:8b2e...f443
    Identity: âœ“âœ“ LinkedIn verified
    
ðŸ‘¤  Unknown User
    Key: sha256:c44a...b118
    Identity: âœ“ Email verified (a***@gmail.com)
```

The verification level is metadata attached to the persona in the data room directory. It's stored in the GitHub repo (as part of the persona JSON) and synced encrypted to S3.

### Identity Squatting and Impersonation

As the system scales beyond closed data rooms to broader use, impersonation becomes a risk. Someone creates a persona called "Dinis Cruz" with their own key pair â€” how does a sender know it's the real person?

**Mitigations by verification level:**

- Level 0 (self-asserted): no protection. The name is meaningless without verification.
- Level 1-2 (email/OAuth): the email address or OAuth identity provides a verifiable anchor. Two personas can't have the same verified email.
- Level 3 (LinkedIn): professional identity is harder to fake. LinkedIn profiles are public and verifiable.
- Level 4 (organisation): the data room admin vouches for the identity. Trust is delegated to the admin.
- Level 5 (KYC): government-grade verification. Strongest available.

**For data rooms** (the current product): impersonation is controlled by the admin. Only the admin can add personas to the directory. This is Level 4 by default â€” organisation-verified.

**For a future public registry**: the verification level becomes the primary trust signal. Users should be warned when communicating with low-verification identities.

### KYC Partners

KYC (Know Your Customer) companies are a natural integration point. They already have verified identity databases. Integration options:

- **Onfido, Jumio, Veriff**: identity verification APIs. User submits a government ID + selfie. Provider returns a verified identity.
- **GOV.UK Verify, eIDAS**: government-backed digital identity schemes.
- **Banks**: banks have strong KYC on their customers. A bank-verified identity is Level 5.

These providers could also be **customers** â€” they deal in identity and confidential documents. A KYC provider using SG/Send data rooms for document exchange is both a customer and a trust anchor.

---

## Implementation Notes

### Phase 1 (Current â€” Data Rooms)

- Identity is scoped to data rooms
- Admin adds personas to the directory with whatever verification they've done
- Search is client-side within the decrypted directory
- Verification level is a metadata field in the persona JSON (admin sets it)

### Phase 2 (Future â€” Broader Discovery)

- Public registry where users opt in to being discoverable
- Verification level becomes the primary ranking/trust signal
- KYC integration for Level 5 verification
- Anti-impersonation controls for public-facing identities

### For AppSec

| Risk | Mitigation |
|---|---|
| Name squatting in public registry | Require email verification minimum. Display verification level prominently. |
| Impersonation within data rooms | Admin-only persona creation. Admin is the trust anchor. |
| Rainbow table attacks on hashed name search | Don't use hashed names for now. Use client-side search within decrypted directories. |
| Identity provider compromise (OAuth, LinkedIn) | Display which provider verified the identity. Allow users to require higher verification levels. |

---

This document is released under the Creative Commons Attribution 4.0 International licence (CC BY 4.0). You are free to share and adapt this material for any purpose, including commercially, as long as you give appropriate credit.
