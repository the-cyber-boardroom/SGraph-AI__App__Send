# Architecture Research: Browser Pod ‚Äî Client-Side Secure Enclave

**version** v0.5.10  
**date** 21 Feb 2026  
**from** Human (project lead)  
**to** Architect (lead), AppSec, Developer  
**type** Architecture research ‚Äî security model exploration  

---

## The Concept

A "pod" that runs inside the browser, holds secrets (API keys, credentials), and acts on behalf of the page ‚Äî without the page ever having direct access to the secrets. The page is treated as **hostile**. Everything outside the pod is considered untrusted.

This is the server-side Secure Pod architecture (v0.4.12) brought into the browser. Same principle: the pod decrypts, acts, and the consumer never holds the secret.

### The Immediate Use Case

The admin agent chat page needs API keys for cloud LLM providers (Anthropic, OpenAI, OpenRouter). Storing these keys in the page's JavaScript is dangerous ‚Äî any XSS, malicious extension, or compromised dependency can exfiltrate them. The browser pod holds the keys and proxies LLM calls.

### The General Pattern

Any web page that needs to use a secret (API key, auth token, credential) without exposing it to the page's JavaScript. This is a reusable open-source utility ‚Äî but we build it for the specific agent chat use case first, then generalise.

---

## Security Requirements

| Requirement | Description |
|---|---|
| **Confidentiality** | The page's JavaScript cannot read the pod's secrets (API keys, usage metrics). |
| **Integrity** | The page cannot modify the pod's state without going through the pod's message API. |
| **Budget enforcement** | The pod limits how many times a secret can be used (rate limits, daily caps). |
| **Nukeable** | It's acceptable (and expected) for the page to be able to destroy the pod and all data inside it. This is how updates work ‚Äî nuke and recreate. |
| **Traffic visibility** | It's acceptable for JavaScript to see and intercept traffic TO the pod (the requests). The secret is the API key inside the pod, not the request payload. The LLM prompt is not a secret ‚Äî the API key is. |
| **PKI-gated access** | The pod can use PKI to verify that only authorised code is making requests. Encrypted responses ensure only the intended recipient reads the result. |

---

## Implementation: Service Worker Only

The browser pod is implemented entirely as a **Service Worker**. No Web Worker needed. The SW provides three capabilities in a single component:

1. **Transparent network interception** ‚Äî inject credentials into outbound requests, strip them from responses
2. **Message API** ‚Äî explicit request/response interface for pod operations (budget checks, usage stats, LLM calls)
3. **Persistent state** ‚Äî budgets, metrics, and encrypted secrets in IndexedDB, surviving page reloads and tab close

### Why Service Worker, Not Web Worker

| Property | Service Worker | Web Worker |
|---|---|---|
| **Transparent interception** | ‚úì Intercepts `fetch` ‚Äî page code needs ZERO changes | ‚úó Page must explicitly send messages to the Worker |
| **Persistence** | ‚úì Survives page reload, navigation, tab close | ‚úó Dies when page closes |
| **One per scope** | ‚úì Only one SW per scope ‚Äî no chaining, replacement is detectable | ‚úó Multiple Workers can coexist |
| **Message API** | ‚úì Supports `postMessage` with `MessageChannel` for request/response | ‚úì Same |
| **IndexedDB access** | ‚úì | ‚úì |
| **crypto.subtle access** | ‚úì | ‚úì |

The Service Worker does everything a Web Worker does, plus transparent interception and persistence. There is no need for a second component.

### The Killer Property: Zero Client Code Changes

The page makes a standard `fetch` call with no credentials:

```javascript
const response = await fetch("https://api.anthropic.com/v1/messages", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ model: "claude-sonnet-4-5-20250514", messages: [...] })
});
```

No `Authorization` header. No API key anywhere in the page's JavaScript. The SW intercepts the outbound request, injects the credential, forwards it to the provider, receives the response, strips any sensitive headers, and returns it to the page.

**The page developer doesn't need to know the pod exists.** The code is identical to what you'd write if the API required no authentication. Add the pod ‚Äî zero code changes. Remove the pod ‚Äî zero code changes. Swap providers ‚Äî zero code changes (the SW can even rewrite the URL).

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Page JavaScript  ‚îÇ    fetch(url)      ‚îÇ  Service Worker  ‚îÇ     fetch(url + auth)
‚îÇ                    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  (the pod)       ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫  Cloud LLM
‚îÇ   No API key       ‚îÇ                    ‚îÇ                  ‚îÇ     API key injected
‚îÇ   No auth headers  ‚îÇ    response        ‚îÇ  - Injects creds ‚îÇ     into headers
‚îÇ   No pod awareness ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ  - Checks budget ‚îÇ
‚îÇ                    ‚îÇ    (clean)          ‚îÇ  - Logs usage    ‚îÇ ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ                    ‚îÇ                    ‚îÇ  - Strips secrets‚îÇ     response
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Network Interception

The SW intercepts requests matching known LLM provider URLs:

```javascript
// In the Service Worker
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Check if this is a request to a known LLM provider
  const provider = matchProvider(url);
  if (!provider) return; // not an LLM call ‚Äî pass through unchanged
  
  event.respondWith(handleLLMRequest(event.request, provider));
});

async function handleLLMRequest(request, provider) {
  // 1. Check budget
  const budget = await getBudget(provider);
  if (budget.remaining <= 0) {
    return new Response(JSON.stringify({
      error: "budget_exceeded",
      limit: budget.limit,
      used: budget.used,
      resets_at: budget.resets_at
    }), { status: 429 });
  }
  
  // 2. Get the API key from encrypted storage
  const apiKey = await getSecret(provider);
  
  // 3. Clone the request and inject the credential
  const headers = new Headers(request.headers);
  if (provider === "anthropic") {
    headers.set("x-api-key", apiKey);
    headers.set("anthropic-version", "2023-06-01");
  } else {
    headers.set("Authorization", `Bearer ${apiKey}`);
  }
  
  const authedRequest = new Request(request, { headers });
  
  // 4. Make the actual call
  const response = await fetch(authedRequest);
  
  // 5. Log usage
  const body = await response.clone().json();
  await recordUsage(provider, body.usage);
  
  // 6. Strip any sensitive headers from the response
  const cleanHeaders = new Headers(response.headers);
  cleanHeaders.delete("x-api-key");
  
  // 7. Return clean response to the page
  return new Response(response.body, {
    status: response.status,
    headers: cleanHeaders
  });
}

function matchProvider(url) {
  if (url.hostname === "api.anthropic.com") return "anthropic";
  if (url.hostname === "api.openai.com") return "openai";
  if (url.hostname === "openrouter.ai") return "openrouter";
  return null; // Ollama and Chrome AI don't need interception ‚Äî no secrets
}
```

### Message API

For explicit pod operations (storing secrets, checking budgets, making LLM calls with provider routing), the SW accepts `postMessage` via `MessageChannel`:

```javascript
// In the Service Worker
self.addEventListener('message', async (event) => {
  const port = event.ports[0];
  if (!port) return;
  
  const { action, ...params } = event.data;
  
  switch (action) {
    case "store_secret":
      await storeSecret(params.id, params.value);
      port.postMessage({ ok: true });
      break;
      
    case "llm_call":
      const result = await makeLLMCall(params);
      port.postMessage(result);
      break;
      
    case "get_status":
      port.postMessage(await getStatus());
      break;
      
    case "get_budgets":
      port.postMessage(await getAllBudgets());
      break;
      
    case "get_usage":
      port.postMessage(await getUsage(params.period));
      break;
      
    case "set_budget":
      await setBudget(params.provider, params.limit_type, params.limit_value);
      port.postMessage({ ok: true });
      break;
      
    case "list_providers":
      port.postMessage(await listProviders());
      break;
      
    case "nuke":
      await nukeAllData();
      port.postMessage({ ok: true, message: "All pod data destroyed" });
      break;
      
    default:
      port.postMessage({ error: "unknown_action", action });
  }
});
```

The two interfaces (network interception and message API) serve different use cases:

| Interface | When to Use | How |
|---|---|---|
| **Network interception** | Page code makes a standard `fetch` to a provider URL. No pod awareness needed. | Transparent ‚Äî SW injects creds, page never knows. |
| **Message API** | Page needs explicit pod operations: store secrets, check budgets, route to provider by name, get usage stats. | Via `postMessage` ‚Äî page calls helper functions. |

Both work. Both coexist. The developer picks whichever suits the situation.

---

## The Client Helper Library: `sg-send.js`

A single JavaScript file that provides a domain-specific, console-friendly API. Loaded on any admin page. Registers global functions that talk to the SW pod.

### Core: SW Communication

```javascript
// sg-send.js

// Low-level: send a message to the SW and get a response
function sendToSW(message) {
  return new Promise((resolve, reject) => {
    if (!navigator.serviceWorker.controller) {
      reject(new Error("Pod not installed. Run pod__install() first."));
      return;
    }
    const channel = new MessageChannel();
    channel.port1.onmessage = (event) => resolve(event.data);
    navigator.serviceWorker.controller.postMessage(message, [channel.port2]);
  });
}
```

### LLM Calls

```javascript
// Direct LLM call (provider-agnostic)
async function llm(prompt, options = {}) {
  const response = await sendToSW({
    action: "llm_call",
    provider: options.provider || "anthropic",
    model: options.model || "claude-sonnet-4-5-20250514",
    messages: Array.isArray(prompt) 
      ? prompt 
      : [{ role: "user", content: prompt }],
    system: options.system || null
  });
  
  if (options.raw) return response;
  console.log(`\n${response.content}\n`);
  return response;
}
```

### Per-Agent Helpers

```javascript
// Context cache (per session, fetched once from GitHub Pages)
const _contextCache = {};
const _ghPagesBase = "https://{org}.github.io/{repo}";

async function _loadContext(role) {
  if (!_contextCache[role]) {
    const resp = await fetch(`${_ghPagesBase}/roles/${role}/context.md`);
    if (!resp.ok) throw new Error(`Failed to load context for ${role}`);
    _contextCache[role] = await resp.text();
  }
  return _contextCache[role];
}

async function _askAgent(role, question) {
  const context = await _loadContext(role);
  const response = await sendToSW({
    action: "llm_call",
    provider: getPreferredProvider(),
    messages: [
      { role: "system", content: context },
      { role: "user", content: question }
    ]
  });
  console.log(`\nü§ñ ${role.toUpperCase()}:\n\n${response.content}\n`);
  return response;
}

// One function per role ‚Äî autocomplete-friendly
async function ask__architect(q)   { return _askAgent("architect", q); }
async function ask__appsec(q)      { return _askAgent("appsec", q); }
async function ask__ambassador(q)  { return _askAgent("ambassador", q); }
async function ask__developer(q)   { return _askAgent("developer", q); }
async function ask__devops(q)      { return _askAgent("devops", q); }
async function ask__designer(q)    { return _askAgent("designer", q); }
async function ask__grc(q)         { return _askAgent("grc", q); }
async function ask__librarian(q)   { return _askAgent("librarian", q); }
async function ask__sherpa(q)      { return _askAgent("sherpa", q); }
async function ask__journalist(q)  { return _askAgent("journalist", q); }
async function ask__accountant(q)  { return _askAgent("accountant", q); }
async function ask__cartographer(q){ return _askAgent("cartographer", q); }
async function ask__alchemist(q)   { return _askAgent("alchemist", q); }
async function ask__explorer(q)    { return _askAgent("explorer", q); }
// ... all 19 roles
```

### Multi-Turn Conversations

```javascript
class AgentChat {
  constructor(role, options = {}) {
    this.role = role;
    this.provider = options.provider || getPreferredProvider();
    this.history = [];
    this.contextLoaded = false;
  }
  
  async ask(question) {
    if (!this.contextLoaded) {
      const context = await _loadContext(this.role);
      this.history.push({ role: "system", content: context });
      this.contextLoaded = true;
    }
    
    this.history.push({ role: "user", content: question });
    
    const response = await sendToSW({
      action: "llm_call",
      provider: this.provider,
      messages: [...this.history]
    });
    
    this.history.push({ role: "assistant", content: response.content });
    console.log(`\nü§ñ ${this.role.toUpperCase()}:\n\n${response.content}\n`);
    return response;
  }
}

// Usage:
// const chat = new AgentChat("architect");
// await chat.ask("What's the status of the trust graph?");
// await chat.ask("How does that connect to data rooms?");
// chat.history  // full conversation
```

### Pod Utilities

```javascript
// Pod management ‚Äî all available from console
async function pod__status()      { return sendToSW({ action: "get_status" }); }
async function pod__budget()      { return sendToSW({ action: "get_budgets" }); }
async function pod__usage(period) { return sendToSW({ action: "get_usage", period: period || "today" }); }
async function pod__providers()   { return sendToSW({ action: "list_providers" }); }
async function pod__nuke()        { return sendToSW({ action: "nuke" }); }

async function pod__store_key(provider, apiKey) {
  return sendToSW({ action: "store_secret", id: `${provider}-api-key`, value: apiKey });
}

async function pod__set_budget(provider, limitType, limitValue) {
  return sendToSW({ action: "set_budget", provider, limit_type: limitType, limit_value: limitValue });
}
```

### SW Health Check and Detection

```javascript
// Verify the pod is installed and no unexpected SWs exist
async function pod__verify() {
  const registrations = await navigator.serviceWorker.getRegistrations();
  
  const report = {
    pod_installed: false,
    unexpected_sw: [],
    pod_active: false
  };
  
  for (const reg of registrations) {
    const sw = reg.active || reg.installing || reg.waiting;
    if (sw && sw.scriptURL.includes("pod-sw.js")) {
      report.pod_installed = true;
      report.pod_active = !!(reg.active);
    } else if (sw) {
      report.unexpected_sw.push(sw.scriptURL);
    }
  }
  
  if (report.unexpected_sw.length > 0) {
    console.warn("‚ö† Unexpected Service Workers detected:", report.unexpected_sw);
  }
  
  if (!report.pod_installed) {
    console.warn("‚ö† Pod not installed. Run pod__install() to set up.");
  }
  
  return report;
}

// Install the pod SW
async function pod__install() {
  const reg = await navigator.serviceWorker.register("/pod-sw.js", { scope: "/" });
  console.log("‚úì Pod installed. Waiting for activation...");
  
  await new Promise((resolve) => {
    if (reg.active) { resolve(); return; }
    const sw = reg.installing || reg.waiting;
    sw.addEventListener("statechange", () => {
      if (sw.state === "activated") resolve();
    });
  });
  
  console.log("‚úì Pod active. Store your API keys with pod__store_key('anthropic', 'sk-...')");
}
```

### The Console Experience

```
> await pod__install()
‚úì Pod installed. Waiting for activation...
‚úì Pod active. Store your API keys with pod__store_key('anthropic', 'sk-...')

> await pod__store_key("anthropic", "sk-ant-api03-xxxxx")
{ ok: true }

> await pod__set_budget("anthropic", "calls_per_day", 100)
{ ok: true }

> await ask__librarian("where can I find the PKI architecture briefs?")

ü§ñ LIBRARIAN:

The PKI architecture briefs are in the v0.4.12 series:
- v0.4.12__architecture__chain-of-trust-and-key-graphs.md ...
- v0.4.12__architecture__secure-pod-multi-user-encryption.md ...
...

> await ask__architect("should we use ECDH or RSA for the next phase?")

ü§ñ ARCHITECT:

Based on the key management brief, RSA-OAEP is the current 
implementation. For the next phase I'd recommend evaluating ECDH P-256...

> await pod__budget()
{ anthropic: { limit: 100, used: 2, remaining: 98, resets_at: "2026-02-22T00:00:00Z" } }

> const chat = new AgentChat("architect")
> await chat.ask("What's the status of the trust graph?")
> await chat.ask("How does that connect to data rooms?")
> chat.history.length
5  // system + 2 user + 2 assistant

> await pod__verify()
{ pod_installed: true, unexpected_sw: [], pod_active: true }
```

---

## Detecting Other Service Workers

Only ONE Service Worker can control a given scope. They cannot be chained. This is a security advantage:

- Our SW registered at scope `/` controls ALL requests from the origin
- Another SW cannot register at the same scope alongside ours ‚Äî the browser replaces, it doesn't chain
- If our SW is replaced, we can detect it

### Detection and Alerting

The `pod__verify()` function checks for unexpected SWs. Additionally, the page can run periodic checks:

```javascript
// Run every 30 seconds while the page is open
setInterval(async () => {
  const report = await pod__verify();
  
  if (report.unexpected_sw.length > 0) {
    showSecurityWarning("Unexpected security component detected.");
  }
  
  if (!report.pod_active) {
    showSecurityWarning("Security pod is not active. API keys are not protected.");
  }
}, 30000);
```

### What If Our SW Is Replaced?

If an attacker somehow registers a malicious SW (compromised server, compromised build pipeline), our SW would be replaced. The page-side check detects this because `sw.scriptURL` no longer matches the expected pod script URL.

The Service Worker trust anchor (v0.4.12 Layer 1) provides deeper protection: it hash-pins the SW script. Any modification to the served `pod-sw.js` is detected by the trust anchor before the browser even tries to install the update.

---

## Pod Data Model

The pod stores its data in IndexedDB, encrypted with the user's PKI key (non-extractable, already in IndexedDB from the admin PKI work):

```javascript
// IndexedDB database: "sg-send-pod"
// All values encrypted with user's PKI key

// Object store: "secrets"
{
  id: "anthropic-api-key",
  encrypted_value: "...",      // AES-GCM encrypted, key wrapped with PKI
  provider: "anthropic",
  created: "2026-02-21T10:00:00Z",
  last_used: "2026-02-21T14:30:00Z"
}

// Object store: "budgets"
{
  id: "anthropic-daily",
  provider: "anthropic",
  limit_type: "calls_per_day",
  limit_value: 100,
  current_usage: 47,
  reset_at: "2026-02-22T00:00:00Z"
}

// Object store: "usage_log"
{
  id: "auto-increment",
  timestamp: "2026-02-21T14:30:00Z",
  provider: "anthropic",
  model: "claude-sonnet-4-5-20250514",
  tokens_in: 1247,
  tokens_out: 892,
  page_origin: "send.sgraph.ai/admin/agent-chat.html"
}
```

Even if the main page reads IndexedDB directly (same origin), it gets only ciphertext. The encryption key is the user's non-extractable PKI private key ‚Äî it can decrypt but cannot be exported.

---

## Budget Controls

The pod enforces budgets per provider:

| Budget Type | What It Limits | Example |
|---|---|---|
| **Calls per day** | Number of API calls in a 24-hour period | 100 calls/day to Anthropic |
| **Tokens per day** | Total tokens (in + out) per day | 50,000 tokens/day |
| **Dollars per day** | Estimated cost per day (based on token pricing) | $5/day |
| **Calls per page** | Number of calls from a specific page in one session | 20 calls per page load |

When a budget is exceeded:
- **Network interception**: the SW returns a 429 response with budget details. The page receives a normal HTTP error.
- **Message API**: the SW returns a `budget_exceeded` message with details.

A compromised page burning through its budget is a detectable signal ‚Äî same principle as the server-side pod's micro-payment budget.

---

## Threat Model

| Threat | Pod's Defence | Residual Risk |
|---|---|---|
| **XSS on the page** | Attacker can trigger LLM calls via `fetch` (intercepted by SW) or `postMessage`, but can't read pod's internal state. Budget caps total usage. API key never exposed to the page. | Attacker can use the LLM within budget. Acceptable ‚Äî budget caps the damage. |
| **Malicious browser extension** | Extensions with elevated permissions may be able to intercept network traffic at a layer below the SW, or read IndexedDB. | Known limitation. Extensions are outside our trust boundary. Document as: "browser extensions with `<all_urls>` permission operate at a higher privilege level than Service Workers." |
| **Compromised pod script** | Service Worker trust anchor (v0.4.12) hash-pins `pod-sw.js`. Modified script is blocked and cached trusted version served instead. | If trust anchor itself is compromised (first visit / TOFU), the pod is compromised. Mitigated by trust anchor's TOFU mitigations. |
| **Another SW replaces ours** | Only one SW per scope. Replacement is detectable via `getRegistrations()` + periodic checks. Trust anchor prevents silent replacement. | If attacker compromises both the server and the trust anchor, the pod is compromised. This requires defeating multiple layers. |
| **User opens DevTools** | IndexedDB shows encrypted blobs. Console cannot access SW scope variables. `pod__status()` and `pod__budget()` show operational info (not secrets). | User can see encrypted data structure and usage metrics. No secret exposure. |
| **Page nukes the pod** | All pod data is destroyed. Expected and acceptable. | User must re-enter API keys. This is the update mechanism. |
| **Network observer (TLS proxy)** | HTTPS protects the API call. The SW adds auth headers inside its own `fetch`, not in the page's `fetch`. | If TLS is compromised (corporate proxy), the API key is in the request header ‚Äî visible to the proxy. Inherent to any browser-based API call. |

---

## Research Questions for AppSec

| Question | Why It Matters |
|---|---|
| Can a compromised main page read a SW's in-memory variables via any browser API? | If yes, secrets in SW memory (between fetch and inject) are exposed. Check: debugging APIs, performance observers, any side channels. |
| Can a browser extension intercept a SW's outbound `fetch` before it reaches the network? | Extensions operate at a different layer. If an extension can read the auth header after the SW injects it, the API key is exposed to the extension. |
| Can the main page read the response headers of a fetch that went through the SW? | The SW strips sensitive headers, but verify the page can't access the original response via any caching or timing mechanism. |
| Can `navigator.serviceWorker.getRegistrations()` be spoofed or intercepted? | If a compromised page can make `getRegistrations()` lie, the detection mechanism is defeated. |
| Does `crypto.subtle` work inside Service Workers in all target browsers? | Required for encrypting/decrypting pod state in IndexedDB. Verify Chrome, Firefox, Safari, Edge. |
| What happens if the user clears browser data? | SW is unregistered, IndexedDB is cleared. Pod is nuked. Next visit requires re-setup. This is acceptable by design ‚Äî document it clearly. |

---

## Connection to Existing Architecture

| Document | Relationship |
|---|---|
| **Service Worker Trust Anchor** (v0.4.12 AppSec research) | The trust anchor SW hash-pins the pod SW's code. Layers 1-3 (code integrity, content signing, source restriction) protect the pod from server-side code injection. Could be the same SW (trust anchor + pod in one) or separate SWs at different scopes. |
| **Secure Pod ‚Äî Multi-User Encryption** (v0.4.12 architecture) | Same architectural pattern, different deployment. Server-side pod: re-encrypts for multi-user access. Browser pod: holds secrets for client-side operations. Both treat their consumer as hostile. |
| **Secrets Manager ‚Äî Dogfooding** (v0.5.10) | The secrets manager stores deployment secrets in SG/Send's S3. The browser pod stores session secrets in the browser's IndexedDB. Same principle, different scope. |
| **Admin Agent Chat** (v0.5.10 dev brief) | First consumer of the browser pod. The agent chat page uses the pod (via `sg-send.js` helpers) to hold LLM API keys and route calls to providers. |
| **Agent Context Pages** (v0.5.10 brief) | Provides the `context.md` files that `sg-send.js` fetches for each agent. The pod proxies the LLM calls; the context pages provide what to say to the LLM. |

---

## File Structure

```
/admin/
‚îú‚îÄ‚îÄ pod-sw.js              ‚Üê The Service Worker (the pod itself)
‚îú‚îÄ‚îÄ sg-send.js             ‚Üê Client helper library (global functions, agent helpers)
‚îú‚îÄ‚îÄ agent-chat.html        ‚Üê Agent chat UI (uses sg-send.js)
‚îú‚îÄ‚îÄ agent-chat.js          ‚Üê Agent chat UI logic
‚îî‚îÄ‚îÄ ...
```

`sg-send.js` is loaded on every admin page via a `<script>` tag. This means every admin page has access to the console API (`ask__architect(...)`, `pod__status()`, etc.) ‚Äî not just the agent chat page.

---

## Implementation Roadmap

| Phase | What |
|---|---|
| 1 | **SW with in-memory secrets** (no IndexedDB persistence). Manual API key entry per session via `pod__store_key()`. Network interception for Anthropic/OpenAI/OpenRouter. Budget tracking in memory. `sg-send.js` with all agent helpers. Enough for the agent chat MVP. |
| 2 | **IndexedDB persistence** (encrypted with PKI key). Secrets survive page reloads. Budget state persists. |
| 3 | **SW detection and alerting**. Periodic checks for unexpected SWs. Page-level security warnings. |
| 4 | **Connect to Service Worker trust anchor** (v0.4.12) for code integrity verification of `pod-sw.js`. |
| 5 | **Generalise into a reusable library / open-source utility.** Extract the pod pattern into a standalone package. |

Phase 1 is the MVP ‚Äî `pod__install()`, `pod__store_key()`, `ask__architect()` from the console. Everything else builds on top.

---

This document is released under the Creative Commons Attribution 4.0 International licence (CC BY 4.0). You are free to share and adapt this material for any purpose, including commercially, as long as you give appropriate credit.
