# SGraph Send: DevOps Deployment Productization

**version** v0.2.4  
**date** 11 Feb 2026  

## Context

We have a working deployment of SGraph Send to AWS Lambda in a single region (US, London). The code works but it's custom, not productized. I want the DevOps agent to take what exists and make it repeatable, testable, destroyable, and deployable to any region from scratch.

We have a clean AWS account dedicated to SGraph Send — we can create, destroy, do whatever we want. No legacy constraints.

## The Goal

Create the tightest, most declarative, fully tested Lambda deployment possible. Programmatic creation, programmatic verification, programmatic destruction. Everything from scratch, everything tested.

### First success criteria

Can you deploy the exact same setup to a different region? And then delete it? That means creating everything from scratch: S3 buckets, Lambda function, IAM roles, CloudFront — everything except the final DNS entry (leave that for now, it needs to be done separately).

## Constraints and Framework

- **Use osbot-aws APIs** — do NOT use boto3 directly. There's a lot of functionality in osbot-aws already, and we can add more since I control that project.
- **Type_Safe classes** — all configuration and deployment classes must use Type_Safe patterns
- **Two Lambda deployments** — one for public/user endpoints, one for admin endpoints. These are the two standardised deployments to start with.

## Class Architecture

### Naming convention

`app__deploy__aws__<component>`

So: `app__deploy__aws__cloudfront`, `app__deploy__aws__lambda`, `app__deploy__aws__s3`, `app__deploy__aws__iam`, etc.

These might end up being generic enough to reuse across projects, not just SGraph Send.

### Configuration classes

Two layers:

1. **Base/common class** — project-wide configuration shared across both Lambda deployments (account ID, project name, common tags, shared settings)
2. **Specific class** — per-deployment configuration (function name, specific bucket names, endpoint-specific settings)

The public deployment and the admin deployment share the base config but have their own specific config.

### Common pattern for every component

Every deployment component class (S3, Lambda, IAM, CloudFront) should follow the same pattern:

| Method | Purpose |
|--------|---------|
| `create()` | Create the resource from scratch |
| `exists()` | Check if the resource exists |
| `verify()` | Verify the resource is correctly configured (not just exists, but RIGHT) |
| `lock_down()` | Apply security hardening / tighten permissions (where applicable) |
| `delete()` | Destroy the resource |
| `verify_deleted()` | Confirm the resource is actually gone |

This pattern repeats for every single component: bucket, Lambda function, IAM role, CloudFront distribution. Same methods, same lifecycle, same testability.

### The deployment orchestrator

A higher-level class that sequences the component classes:

1. Create IAM role
2. Verify IAM role
3. Create S3 buckets
4. Verify S3 buckets
5. Create Lambda function (with IAM role, pointing to S3)
6. Verify Lambda function
7. Create CloudFront distribution
8. Verify CloudFront
9. Run integration tests against the deployed stack
10. Report: everything deployed and verified ✓

And the inverse for destruction:

1. Delete CloudFront
2. Verify deleted
3. Delete Lambda
4. Verify deleted
5. Delete S3 buckets
6. Verify deleted
7. Delete IAM role
8. Verify deleted
9. Report: everything destroyed and verified ✓

## Testing Strategy

### Unit tests with LocalStack

Every component class should have a full mirror in unit tests using LocalStack. LocalStack supports S3, Lambda, IAM — should cover everything we need. If it doesn't support something, we'll find out and document it.

The unit tests should exercise the full lifecycle: create → verify → lock_down → delete → verify_deleted. All against LocalStack, no real AWS credentials needed.

### Integration tests with real AWS

A separate test mode that loads real AWS credentials and does the actual deployment. Same tests, same assertions, but against the real account. This is the "does it actually work?" check.

The integration tests should:

- Deploy the full stack to a test region
- Verify every component is correctly created
- Run functional tests against the deployed endpoints
- Destroy everything
- Verify everything is gone

### The create/delete round-trip

This is the key test: create everything from scratch → verify it works → delete everything → verify it's gone → create it again → verify it works again. If the round-trip works cleanly, the deployment is truly repeatable.

## Multi-Region

Once the single-region deployment works and the create/delete round-trip is clean, deploying to another region should be: change the region in the config, run the same orchestrator. Everything creates from scratch because nothing exists yet in the new region.

Eventually: deploy to N regions in parallel, with a matrix of which regions are active.

## What I'll Provide

- The existing deployment code (the genesis, custom-built version)
- The working installation on US/London
- The AWS account access

The DevOps agent takes this and productizes it into the class architecture described above.

## What Comes Next (Not This Brief)

- IAM permission tightening — lock down the deployment credentials to minimum required permissions
- API-driven verification — hit the actual endpoints and verify responses
- DNS/certificate management
- CI/CD pipeline integration
- Multi-account deployment (staging, production)

---

## For the Agents

- **DevOps**: this is your brief. Start by reading the existing deployment code I'll provide. Map every step it does to a component class. Build the class architecture with the common pattern (create/verify/lock_down/delete/verify_deleted). Get the round-trip working in one region first.
- **Dev**: the osbot-aws wrappers may need extensions for some of the deployment operations. Work with DevOps to identify gaps and add methods to osbot-aws as needed.
- **QA**: write the LocalStack test suite. Mirror every component class method. Also design the integration test that does the full create/delete round-trip against real AWS.
- **AppSec**: once the deployment works, the next brief will be about IAM tightening. Start thinking about: what's the minimum set of permissions needed to deploy? What's the minimum the Lambda function itself needs at runtime? We want the tightest IAM policies possible.
- **Architect**: review the class architecture before implementation. Is the common pattern right? Is the configuration split (base vs specific) clean? Does this generalise well for future non-Lambda deployments (ECS, EC2, GCP)?
