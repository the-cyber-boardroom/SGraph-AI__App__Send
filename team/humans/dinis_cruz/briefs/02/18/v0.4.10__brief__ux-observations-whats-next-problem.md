# Brief: UX Observations — The "What's Next?" Problem

**version** v0.4.10  
**date** 18 Feb 2026  
**from** Human (project lead) — based on direct user observation  
**to** Designer (lead), Sherpa, Architect, Developer  
**type** UX research brief — observed user behaviour  

---

## What Happened

The human sat with a user and watched them use SG/Send for the first time. The observation was unstructured — the user was given the product and minimal guidance. What follows are the UX problems observed in real time.

This is gold. We rarely get to watch someone use the product without preconceptions. Every observation here should be treated as high-priority signal.

---

## Observation 1: The Post-Typing Dead Zone

**What happened**: the user was guided to the text input area (which was fine — the text element is a reasonable starting point). The user typed a message. Then... nothing obvious happened. The user wasn't sure what to do next. The "send" or "encrypt" action wasn't immediately visible or obvious.

**The principle being violated**: after the user completes an action (typing a message), the next step should be unmissable. The UI should **react to the user's action** by making the next step prominent.

**Proposed solution**: progressive UI that responds to user input:

- Before typing: the interface shows the text area prominently, with the send/encrypt button in a neutral state
- As soon as the user starts typing: the send/encrypt button becomes **visually prominent** — larger, coloured, animated, or otherwise impossible to miss
- The principle: once content exists, the only thing that matters is the action to send it. Everything else should recede.

**Designer**: mock up a progressive disclosure model where the send button transitions from neutral to prominent as content is entered. Consider animation, colour change, size increase, or spatial repositioning.

---

## Observation 2: The Post-Encryption Page Is Too Busy

**What happened**: after the content was encrypted, the user landed on a page showing the link, the decryption key, and various options. The user was confused. They scrolled up and down. They couldn't immediately identify what to do next. It took them a noticeable amount of time to find the copy-link action and understand the two-channel sharing model.

**The diagnosis**: the page shows too much information at once. There's content relevant to power users (technical details, multiple sharing options, encryption metadata) mixed with the core action (share this link and key). For a first-time user, this is overwhelming.

**The principle**: the post-encryption page has ONE job — help the user share the encrypted content. Everything else is secondary.

**Proposed redesign approach**:

The page should present a clear binary choice:

```
┌─────────────────────────────────────────────┐
│                                             │
│   Your message is encrypted and ready.      │
│                                             │
│   ┌─────────────────────────────────────┐   │
│   │                                     │   │
│   │   QUICK SHARE                       │   │
│   │   Copy one link (includes key)      │   │
│   │   [ Copy Link ]                     │   │
│   │                                     │   │
│   └─────────────────────────────────────┘   │
│                                             │
│   ┌─────────────────────────────────────┐   │
│   │                                     │   │
│   │   SECURE SHARE                      │   │
│   │   Send link and key separately      │   │
│   │   (recommended for sensitive data)  │   │
│   │   [ Copy Link ] [ Copy Key ]        │   │
│   │                                     │   │
│   └─────────────────────────────────────┘   │
│                                             │
│   ▸ Show technical details                  │
│                                             │
└─────────────────────────────────────────────┘
```

Two clear options. One for speed ("just give me the link"), one for security ("send these separately"). Everything else collapsed behind a "Show details" expander.

**Security note for AppSec**: the "quick share" option (link includes key) is less secure — a single intercepted message compromises everything. The "secure share" option (two channels) is the recommended approach. We should default-highlight the secure option but not block the quick option. Make the trade-off visible, not invisible.

**Designer**: mock up both approaches. Sherpa to validate with future user tests.

---

## Observation 3: The Download Page Confusion

**What happened**: the download page was also too busy. The user wasn't immediately sure what to look at or what action to take.

**The same principle applies**: the download page has ONE job — let the recipient enter the key and get the content. Everything else is noise for first-time users.

**Designer**: apply the same progressive disclosure approach to the download page. Key entry field prominent. Decrypt button unmissable. Technical details collapsed.

---

## Observation 4: Facilitating the Two-Channel Send

**The insight**: once the user understood the concept (send link via one channel, key via another), the next friction point was: "okay, but HOW do I send these separately?"

**What we should do**: actively facilitate the sending, not just give them text to copy.

Near-term options:
- **"Send key via SMS"** button — opens the device's SMS app with the key pre-filled
- **"Send key via WhatsApp"** button — opens WhatsApp (desktop or mobile) with the key pre-filled
- **"Send link via email"** button — opens the default email client with the link in the body
- **Share sheet integration** — use the Web Share API (where available) to let the user choose their channel

**Research task for Architect**: can we detect if WhatsApp Desktop is installed? Can we use `whatsapp://` deep links? What about `sms:` URI scheme? How do these work across desktop vs mobile browsers?

---

## The Positive Signal

Despite the confusion, once the user understood the workflow: "Yeah, this is quite interesting, quite useful."

And critically, the user's mental model wasn't primarily about encryption. The hook was: **"this is a way for me to send information from A to B in a better way, and it doesn't require anything to be installed."**

This validates what User A said independently. The no-installation, no-account, browser-only model is the primary value proposition — not the encryption. The encryption is a "nice bonus" for many users. The convenience is the hook.

**Ambassador**: this should reshape our messaging. Lead with "send anything to anyone, no app required" — not "military-grade encryption."

---

## Feature Flags and A/B Testing

### The Problem

The current UI is locked in the current release. If we redesign the post-encryption page, we can't just push it to production — it might introduce bugs, confuse existing users, or be worse than what we have. We need a way to experiment safely.

### Feature Flags via localStorage

The human wants a feature flag system that:

1. Stores flags in localStorage (per-browser, per-user)
2. Allows the human (or any tester) to toggle flags in production without deploying new code
3. Enables A/B testing — some users see the new UI, some see the old
4. Can be controlled via a mini admin panel (a simple UI for flipping flags)
5. Can be controlled via URL parameters (for sharing specific configurations)

**Implementation approach**:

```javascript
// Feature flag system
const flags = {
  'ui.post-encrypt-v2': false,    // New post-encryption page
  'ui.progressive-send': false,    // Progressive send button
  'ui.download-simplified': false, // Simplified download page
  'tracking.mouse-movement': false // Mouse tracking (research only)
};

// Load from localStorage, override with URL params
function getFlag(name) {
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has(`flag.${name}`)) return urlParams.get(`flag.${name}`) === 'true';
  const stored = localStorage.getItem(`flag.${name}`);
  if (stored !== null) return stored === 'true';
  return flags[name]; // default
}
```

**This means**:
- The human can visit `send.sgraph.ai/?flag.ui.post-encrypt-v2=true` and see the new UI in production
- Other users see the old UI
- Once validated, the flag default is flipped to `true` and the old code is removed
- The mini admin panel (localStorage viewer) lets users with curiosity explore the flags

### A/B Testing via the Sherpa

When feature flags are in place, the Sherpa can:
- Assign random users to flag groups (e.g., 50% see new UI, 50% see old)
- Track which trails users take with each UI variant
- Report on which variant performs better (fewer confused scrolls, faster time-to-share, etc.)

---

## SPA Deep Linking

### The Problem

The current multi-page architecture means you can't deep-link to specific states. You can't send someone a URL that goes straight to the Portuguese version, or straight to a specific UI variant, or straight to a specific view.

### What's Needed

Convert to a single-page application (SPA) with path-based routing:

```
send.sgraph.ai/                     → Default landing
send.sgraph.ai/pt-br/               → Portuguese landing
send.sgraph.ai/send/                → Send page
send.sgraph.ai/download/{id}        → Download page
send.sgraph.ai/send/?theme=dark     → Send with dark theme
```

**The URL must stay in sync with the user's state.** Every action that changes the view should update the URL. Every URL should be refreshable and shareable.

**Architect**: design how SPA routing works within the IFD framework. The IFD model deploys immutable file sets — how does SPA routing coexist with that? Options include hash-based routing (`#/send/`) or CloudFront URL rewriting.

**Developer**: implement the SPA shell with path-based routing. Start with the language deep link (most immediately useful for sharing Portuguese versions).

---

## Mouse Movement Tracking (Research — DO NOT ENABLE YET)

### The Concept

To give the Sherpa deeper understanding of user behaviour, we could record mouse movements and scroll patterns (NOT keystrokes — explicitly no keylogging). This would show: where users hover, where they hesitate, where they scroll looking for something, where they click wrong.

### Privacy and Security Constraints

This is sensitive. The human explicitly stated:

- **No keylogging.** Period. Some companies do this. We don't.
- **Mouse movements only** — cursor position and scroll position over time
- **Opt-in only** — only for users who explicitly consent, or only on specific deployments (e.g., beta instances, not production)
- **Feature flag controlled** — the tracking code should be behind a flag. On production, the flag is off. On beta, it can be turned on.
- **Code-level control** — for maximum security, we should have a deployment variant where the tracking code doesn't even exist in the bundle. The flag is moot if the code isn't shipped.

**DPO**: review the privacy implications. Even mouse tracking has GDPR considerations (it's personal data if it can be linked to a user). Define the consent model.

**AppSec**: review the security implications. Mouse tracking data in transit and at rest — how is it protected? Who can access it?

**Architecture principle**: feature flags control runtime behaviour, but for sensitive features, the code itself should be excluded from certain builds. Configuration controls "is it on?" — build configuration controls "does it even exist?"

---

## Summary of Deliverables

| Task | Owner | Priority |
|---|---|---|
| Mock up progressive send button (neutral → prominent on input) | Designer | P2 |
| Mock up simplified post-encryption page (two clear options + collapsed details) | Designer | P2 |
| Mock up simplified download page | Designer | P2 |
| Research Web Share API, SMS URI, WhatsApp deep links for send facilitation | Architect | P3 |
| Design and implement feature flag system (localStorage + URL params) | Developer, Architect | P2 |
| Design mini admin panel for flag management | Developer, Designer | P3 |
| Design SPA routing within IFD framework | Architect | P2 |
| Implement SPA shell with language deep linking | Developer | P3 |
| Research mouse movement tracking (privacy, security, implementation) | DPO, AppSec, Developer | P4 |
| Validate new UX with future user tests | Sherpa | Ongoing |

---

## For the Designer

The core insight from this observation: **the user's journey through SG/Send has moments of "now what?"** — and those moments are where we lose people. The fix is progressive disclosure: show only what matters at each step, make the next action unmissable, and hide everything else behind expandable details.

The user who struggled with our UI still said "this is quite interesting, quite useful." Imagine what they'd say if the UI guided them seamlessly.
