# Brief: User Feedback â€” Encrypted Chat and Real-Time Transfer Visibility

**version** v0.4.10  
**date** 18 Feb 2026  
**from** Human (project lead) â€” captured during conversation with a user  
**to** Architect (lead), Developer, Sherpa, Ambassador  
**type** Feature brief â€” roadmap addition based on direct user feedback  

---

## The User's Insight

The human was talking to a user about how they send sensitive information today. The user's answer: **WhatsApp** â€” and the reason wasn't the encryption. It was the **thread history**.

WhatsApp provides context. You can say "here's what I'm working on," then "here's the file," then "did you get it?", then "here's the updated version." The conversation is the container for the files. The files make sense because they exist within a conversation.

SG/Send, by contrast, is atomic. Each transfer is isolated. There's no context, no thread, no "this file relates to that message." For one-off transfers this is fine. For ongoing relationships â€” an accountant and their client, a team sharing documents over a project â€” it's a real limitation.

---

## Proposed Feature: Encrypted Mini Chat

### The Concept

If two people share a key, they already have a secure channel. A "chat" is just a sequence of small encrypted files (messages) associated with that shared key.

The architecture:

```
Shared key "alice-bob-2026"
    â”‚
    â”œâ”€â”€ Message: "Here's the Q4 draft" (text, encrypted)
    â”œâ”€â”€ File: Q4-report-draft.pdf (encrypted)
    â”œâ”€â”€ Message: "Can you review section 3?" (text, encrypted)
    â”œâ”€â”€ File: Q4-report-v2.pdf (encrypted)
    â”œâ”€â”€ Message: "Looks good, approved" (text, encrypted)
    â””â”€â”€ ...
```

Each message/file is independently encrypted with the shared key. The "chat" is just a chronological list of encrypted payloads associated with a key identifier. The server sees a sequence of encrypted blobs â€” it doesn't know whether they're messages or files, who sent them, or what they contain.

### Why This Works for Zero-Knowledge

The zero-knowledge model holds:
- The server stores encrypted blobs in chronological order
- The server knows which blobs belong to the same key identifier (so it can list them)
- The server does NOT know the key, the content, or who the participants are
- Both participants decrypt locally using the shared key
- New messages appear when either participant refreshes (or via polling/WebSocket)

### What This Is NOT

This is not a full chat application. We are not building WhatsApp. Specifically:

- No user accounts (still browser-based, no sign-up)
- No presence indicators ("Alice is online")
- No read receipts (initially â€” could add later)
- No message editing or deletion (initially)
- No group chat (initially â€” two-party only with a shared key)
- No push notifications

It's closer to a **shared encrypted notepad with file attachments** than a chat app. But from the user's perspective, it feels like a conversation â€” and that's what they want.

### User Experience

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Secure Channel: [shared key entered]    â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚                                          â”‚
â”‚  [14:32] Here's the Q4 draft             â”‚
â”‚  [14:32] ğŸ“ Q4-report-draft.pdf (2.3MB) â”‚
â”‚                                          â”‚
â”‚  [15:15] Can you review section 3?       â”‚
â”‚                                          â”‚
â”‚  [16:42] ğŸ“ Q4-report-v2.pdf (2.4MB)    â”‚
â”‚  [16:42] Updated with your comments      â”‚
â”‚                                          â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Type a message or drag a file...        â”‚
â”‚  [Send]                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Both participants see the same view. Messages appear in chronological order. Files can be downloaded inline. The shared key unlocks everything.

---

## Proposed Feature: Real-Time Upload Visibility

### The Insight

The user made another observation: when someone sends a large file, the recipient is in the dark. They refresh, refresh, refresh. "Is it uploading? Did it fail? How long do I wait?"

### The Feature

The recipient should see the upload happening in real time:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                          â”‚
â”‚  [16:42] Updated with your comments      â”‚
â”‚                                          â”‚
â”‚  [16:45] ğŸ“ Uploading: project-data.zip  â”‚
â”‚          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  52% (127MB)   â”‚
â”‚          ~45 seconds remaining            â”‚
â”‚                                          â”‚
â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
```

**Before the upload finishes**, the recipient knows:
- A file is being sent
- How big it is
- How far along the upload is
- Approximately how long until they can download it

### Even Better: Start Downloading Before Upload Finishes

For large files (50MB, 100MB, 500MB), the killer feature:

**Stream the download as the upload progresses.** The sender uploads chunk by chunk. Each chunk is encrypted and stored. The recipient can start downloading and decrypting chunks that have already arrived â€” before the sender finishes uploading.

This is like watching a video that's still buffering â€” you don't wait for the whole thing. You start consuming as it arrives.

**Architecture implications**: this requires chunked upload/download (already on our roadmap for the resilient large file transfer feature) and a signalling mechanism so the recipient knows when new chunks are available.

### Implementation Options for Real-Time Signalling

| Approach | Complexity | Latency | Notes |
|---|---|---|---|
| **Polling** | Low | 2â€“5 seconds | Recipient polls server every few seconds for new messages/chunks. Simple, works everywhere. |
| **Server-Sent Events (SSE)** | Medium | Sub-second | Server pushes updates to the recipient's browser. One-way, simpler than WebSocket. |
| **WebSocket** | High | Real-time | Full-duplex communication. Most responsive but most complex. Requires persistent connection. |
| **WebRTC (P2P)** | Very High | Real-time | Peer-to-peer, no server needed for data transfer. Already on the future roadmap. |

**Architect recommendation**: start with polling (simplest, no infrastructure changes). Move to SSE when the UX demands it. WebSocket and WebRTC are future considerations.

---

## Roadmap Placement

| Feature | Priority | Complexity | Dependencies |
|---|---|---|---|
| Encrypted mini chat (shared key â†’ message thread) | P3 | Medium | Shared/custom encryption keys (already on roadmap) |
| Upload progress visibility for recipient | P3 | Medium | Chunked upload (already on roadmap) |
| Stream download before upload completes | P4 | High | Chunked upload + download + signalling |
| Real-time signalling (SSE/WebSocket) | P4 | Medium | Infrastructure change (persistent connections vs serverless) |

### Note on Architecture

The current serverless architecture (Lambda) is stateless â€” each request is independent. Real-time features (WebSocket, SSE) require persistent connections, which don't fit naturally in Lambda. Options:

- **API Gateway WebSocket API** â€” AWS supports WebSocket connections through API Gateway, backed by Lambda. This keeps us serverless but adds complexity.
- **Hybrid** â€” serve the WebSocket/SSE endpoint from a small always-on service (ECS Fargate, EC2), while keeping everything else serverless.
- **Polling** â€” avoids the problem entirely. Less responsive but zero infrastructure change.

**Architect**: evaluate these options. The choice affects the partner deployment model too (one-click deploy is harder if we need persistent services).

---

## Connection to the Post-Encryption UX (Doc 1)

The encrypted chat feature partially solves the "what's next?" problem from the UX observations brief. Instead of:

1. Encrypt â†’ copy link â†’ send link â†’ copy key â†’ send key â†’ done (isolated, transactional)

The flow becomes:

1. Open shared channel â†’ type message â†’ attach file â†’ send â†’ done (conversational, contextual)

The user's mental model shifts from "I'm performing a secure file transfer" to "I'm having a conversation and sharing files within it." The encryption is invisible. The experience is natural.

---

## For the Sherpa

This feedback came directly from a user conversation. The Sherpa should:

1. Record this as a validated use case (thread-based encrypted sharing)
2. Track the user's specific scenario (what are they sharing? With whom? How often?)
3. Add to the interview questions (if the user agrees to be interviewed): "Walk me through a typical week of file sharing. How many people do you regularly exchange files with? How important is the conversation context around those files?"
4. Validate the real-time upload visibility concept with other users â€” is this a common pain point?

---

## For the Ambassador

The messaging angle: "SG/Send isn't just secure file transfer. It's a secure channel for ongoing collaboration â€” no app required, no account required, just a shared key and a browser."

This is a significant evolution of the value proposition. It moves SG/Send from a utility (send a file) to a relationship tool (ongoing secure communication with someone). That's a much stickier product.

---

This document is released under the Creative Commons Attribution 4.0 International licence (CC BY 4.0). You are free to share and adapt this material for any purpose, including commercially, as long as you give appropriate credit.
