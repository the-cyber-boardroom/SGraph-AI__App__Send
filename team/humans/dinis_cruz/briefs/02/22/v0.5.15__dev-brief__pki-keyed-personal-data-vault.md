# Developer Brief: PKI-Keyed Personal Data Vault

**version** v0.5.15  
**date** 22 Feb 2026  
**from** Human (project lead)  
**to** Developer (lead), Architect  
**type** Developer brief â€” next step for PKI infrastructure  

---

## What to Build

A personal file system on the server that belongs to a specific PKI key pair. The user's public key hash deterministically derives a storage location. The user can create folders, store files, and retrieve them â€” all addressed by their key identity.

This is the stepping stone from "send data to someone else" (current model) to "save and organise data in my own space" (beginning of the data room).

---

## The Core Idea

Today, SG/Send is about sending: encrypt a file, get a link, someone else downloads it. But the user has no persistent space of their own. No file system. No "my files."

The insight: the user already has a PKI key pair. The hash of their public key is a unique, deterministic identifier. Use it to derive a storage root in S3. Everything under that root belongs to that key pair.

```
User's public key
    â”‚
    â–¼
sha256(public_key) = "3a7f...c891"
    â”‚
    â–¼
Cache ID: sha256("3a7f...c891" + "/filesystem")
    â”‚
    â–¼
S3 location: this is the root of the user's personal data vault
```

The user doesn't need to register, create an account, or provide any identity. The key pair IS the identity. If you have the private key, you can access your vault. If you don't, you can't.

---

## Deriving the Storage Root

The cache service already supports deterministic cache IDs. We use this to create a predictable storage location from the user's key:

```javascript
// Client side â€” derive the cache ID for this user's vault
const publicKeyHash = await crypto.subtle.digest(
  "SHA-256", 
  await crypto.subtle.exportKey("raw", publicKey)
);
const hashHex = Array.from(new Uint8Array(publicKeyHash))
  .map(b => b.toString(16).padStart(2, '0')).join('');

// Append a namespace to avoid collisions with other uses of the key hash
const vaultCacheId = sha256(hashHex + "/filesystem");

// This cache ID locates the vault root in S3
```

### Why Append a Namespace

The raw key hash might already be used for other purposes (key registry lookups, trust graph references). By appending `/filesystem` (or `/datastore`, `/vault`, etc.) before hashing, we create a separate namespace. This also allows future expansion:

| Namespace | Purpose |
|---|---|
| `{keyHash}/filesystem` | Personal file vault (this brief) |
| `{keyHash}/inbox` | Messages received (future) |
| `{keyHash}/contacts` | Directory of known public keys (future) |
| `{keyHash}/settings` | User preferences (future) |

Each namespace derives a different cache ID from the same key. All belong to the same identity.

---

## The Vault Structure

### Root File

The vault root is a single cache entry containing a JSON file â€” the vault manifest:

```json
{
  "type": "vault_root",
  "created": "2026-02-22T10:00:00Z",
  "key_fingerprint": "sha256:3a7f...c891",
  "root_folder": "b4e2d903"
}
```

The `root_folder` is the GUID of the top-level folder. Everything hangs off this.

### Folders

A folder is a JSON file stored as a cache entry (its own GUID as the cache ID):

```json
{
  "type": "folder",
  "id": "b4e2d903",
  "children": [
    { "id": "c5f3e014", "type": "folder" },
    { "id": "d6g4f125", "type": "file" },
    { "id": "e7h5g236", "type": "file" }
  ]
}
```

**No names. No metadata. Just GUIDs and types.** The server sees a JSON file containing meaningless IDs. It has no idea what the folders are called, what the files contain, or what the structure represents.

### Files

A file is an encrypted blob stored as a cache entry (its own GUID as the cache ID). Exactly the same as current SG/Send file storage. The encrypted blob is opaque to the server.

### Where Do Names Live?

On the **client side only.** The client maintains a local index (in IndexedDB or in an encrypted metadata file in the vault itself) that maps GUIDs to human-readable names:

```json
{
  "b4e2d903": { "name": "My Documents", "type": "folder" },
  "c5f3e014": { "name": "Investor Materials", "type": "folder" },
  "d6g4f125": { "name": "NDA - Mutual.pdf", "type": "file", "size": 245000 },
  "e7h5g236": { "name": "Term Sheet v2.pdf", "type": "file", "size": 189000 }
}
```

Option A: store this index in the browser's IndexedDB (fast, local, lost if browser data cleared).

Option B: store this index AS a file in the vault itself â€” encrypted, stored at a well-known GUID derived from the vault root. This way the index is persistent and recoverable from any browser that has the private key.

**Recommendation**: Option B â€” store the encrypted index in the vault. On first access from a new browser, the client fetches and decrypts the index, then caches it locally in IndexedDB for speed. Self-contained. No data loss on browser clear.

### The Index File

The index is a special file in the vault with a deterministic GUID:

```javascript
const indexCacheId = sha256(vaultCacheId + "/index");
```

Contents (encrypted, stored as a normal cache entry):

```json
{
  "type": "vault_index",
  "updated": "2026-02-22T14:30:00Z",
  "entries": {
    "b4e2d903": { "name": "My Documents", "type": "folder", "parent": null },
    "c5f3e014": { "name": "Investor Materials", "type": "folder", "parent": "b4e2d903" },
    "d6g4f125": { "name": "NDA - Mutual.pdf", "type": "file", "parent": "b4e2d903", 
                   "size": 245000, "uploaded": "2026-02-22T10:05:00Z" },
    "e7h5g236": { "name": "Term Sheet v2.pdf", "type": "file", "parent": "c5f3e014",
                   "size": 189000, "uploaded": "2026-02-22T10:10:00Z" }
  }
}
```

This is the only file that contains human-readable names. It's encrypted. The server sees ciphertext.

---

## The Complete Storage Layout

```
S3 (what the server sees):
â”‚
â”œâ”€â”€ {vaultCacheId}           â† vault root manifest (JSON, unencrypted â€” contains only GUIDs)
â”œâ”€â”€ {indexCacheId}           â† vault index (encrypted â€” contains names and structure)
â”œâ”€â”€ {guid_1}                 â† folder JSON (children list, GUIDs only)
â”œâ”€â”€ {guid_2}                 â† folder JSON
â”œâ”€â”€ {guid_3}                 â† encrypted file blob
â”œâ”€â”€ {guid_4}                 â† encrypted file blob
â””â”€â”€ {guid_5}                 â† encrypted file blob

The server sees: a collection of cache entries with hex IDs.
It has no idea which are folders, which are files, what anything is called,
or how they relate to each other.
```

---

## API Integration

This uses **existing cache service endpoints**. No new API routes required:

| Operation | How | Endpoint |
|---|---|---|
| **Create vault** | Store vault root manifest at derived cache ID | `POST /api/cache/{vaultCacheId}` (existing) |
| **Create folder** | Generate GUID, store folder JSON, update parent folder and index | `POST /api/cache/{guid}` (existing) |
| **Upload file** | Generate GUID, encrypt file, store blob, update parent folder and index | `POST /api/cache/{guid}` (existing) |
| **List folder contents** | Fetch folder JSON by GUID, read children IDs, look up names in local index | `GET /api/cache/{guid}` (existing) |
| **Download file** | Fetch encrypted blob by GUID, decrypt with private key | `GET /api/cache/{guid}` (existing) |
| **Update index** | Re-encrypt and overwrite the index file | `PUT /api/cache/{indexCacheId}` (existing) |

The vault is built entirely on top of the existing cache infrastructure. The server doesn't know it's serving a file system.

---

## The Client-Side Flow

### First Visit (Creating the Vault)

```
1. User has PKI key pair in browser (from existing admin PKI page)
2. Client derives vaultCacheId from public key hash + "/filesystem"
3. Client calls GET /api/cache/{vaultCacheId}
   â”œâ”€â”€ 404: vault doesn't exist yet
   â”‚   â”œâ”€â”€ Generate root folder GUID
   â”‚   â”œâ”€â”€ Create vault root manifest â†’ POST /api/cache/{vaultCacheId}
   â”‚   â”œâ”€â”€ Create empty root folder JSON â†’ POST /api/cache/{rootFolderGuid}
   â”‚   â”œâ”€â”€ Create empty index â†’ POST /api/cache/{indexCacheId}
   â”‚   â””â”€â”€ Vault created. Show empty file manager.
   â”‚
   â””â”€â”€ 200: vault exists
       â”œâ”€â”€ Read root folder GUID from manifest
       â”œâ”€â”€ Fetch and decrypt index â†’ GET /api/cache/{indexCacheId}
       â”œâ”€â”€ Cache index in IndexedDB
       â””â”€â”€ Show file manager with folder/file structure
```

### Uploading a File

```
1. User selects file to upload
2. Client generates GUID for the file
3. Client encrypts file with vault encryption key
4. Client stores encrypted blob â†’ POST /api/cache/{fileGuid}
5. Client updates parent folder JSON (add child entry) â†’ PUT /api/cache/{parentGuid}
6. Client updates index (add name/metadata entry) â†’ PUT /api/cache/{indexCacheId}
7. File appears in the UI
```

### Creating a Folder

```
1. User creates folder "Investor Materials"
2. Client generates GUID for the folder
3. Client stores empty folder JSON â†’ POST /api/cache/{folderGuid}
4. Client updates parent folder JSON (add child entry) â†’ PUT /api/cache/{parentGuid}
5. Client updates index (add name entry) â†’ PUT /api/cache/{indexCacheId}
6. Folder appears in the UI
```

---

## Encryption Key for the Vault

Two options for what encrypts the vault's contents:

| Option | How | Trade-Off |
|---|---|---|
| **PKI key pair** | Each file encrypted with user's public key, decrypted with private key | Standard PKI. Non-extractable private key means only this browser can decrypt (unless key is shared). |
| **Derived symmetric key** | Derive an AES key from the PKI key pair (or from a passphrase). Symmetric encryption for files. | Faster for bulk files. Can be shared (give someone the symmetric key to access the vault â€” this is the data room key from the v0.5.10 product brief). |

**Recommendation**: derived symmetric key. This is consistent with the data room model (enter a key to access the room). The symmetric key can be derived from the PKI key pair or set independently. For the personal vault, derive it from the PKI key. For shared data rooms, it's a separate shared key.

---

## Relationship to Data Rooms

The personal vault IS a data room with one user. The same structure (folders as GUID-addressed JSON, files as encrypted blobs, index as encrypted metadata) scales directly to shared data rooms:

| Personal Vault | Data Room |
|---|---|
| One user's key derives the storage root | Data room ID derives the storage root |
| One user's key encrypts/decrypts | Shared symmetric key encrypts/decrypts (or pod-mediated for revocable access) |
| Index has one user's folder names | Index has shared folder structure visible to all authorised users |
| Vault root is private | Data room root is shared among authorised users |

Building the personal vault first means the data room gets the same infrastructure for free.

---

## UI: File Manager Page

New admin page: `/admin/vault.html`

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Admin  â€º  My Vault                                            â”‚
â”‚                                                                 â”‚
â”‚  Key: sha256:3a7f...c891                  [Create Folder]       â”‚
â”‚                                            [Upload File]        â”‚
â”‚                                                                 â”‚
â”‚  ğŸ“ My Documents                                                â”‚
â”‚  â”œâ”€â”€ ğŸ“ Investor Materials                                      â”‚
â”‚  â”‚   â”œâ”€â”€ ğŸ“„ Term Sheet v2.pdf              245 KB    [â†“] [ğŸ—‘]  â”‚
â”‚  â”‚   â””â”€â”€ ğŸ“„ Financial Model.xlsx           189 KB    [â†“] [ğŸ—‘]  â”‚
â”‚  â”œâ”€â”€ ğŸ“„ NDA - Mutual.pdf                  112 KB    [â†“] [ğŸ—‘]  â”‚
â”‚  â””â”€â”€ ğŸ“„ Welcome Pack.md                    8 KB     [â†“] [ğŸ—‘]  â”‚
â”‚                                                                 â”‚
â”‚  Storage: 4 files, 554 KB encrypted                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Acceptance Criteria

| # | Criterion |
|---|---|
| 1 | Vault storage root is deterministically derived from user's public key hash |
| 2 | Creating a vault requires only an existing PKI key pair (no registration) |
| 3 | Can create folders (GUID-addressed, server sees only GUIDs) |
| 4 | Can upload files (encrypted, stored as cache entries) |
| 5 | Can list folder contents (names resolved from encrypted index, not from server) |
| 6 | Can download and decrypt files |
| 7 | Vault index is stored encrypted in the vault itself (recoverable from any browser with the key) |
| 8 | Server sees only cache entries with hex IDs â€” no names, no structure, no metadata |
| 9 | No new API routes â€” built entirely on existing cache service |
| 10 | Vault structure is compatible with data room architecture (same folder/file model) |

---

This document is released under the Creative Commons Attribution 4.0 International licence (CC BY 4.0). You are free to share and adapt this material for any purpose, including commercially, as long as you give appropriate credit.
