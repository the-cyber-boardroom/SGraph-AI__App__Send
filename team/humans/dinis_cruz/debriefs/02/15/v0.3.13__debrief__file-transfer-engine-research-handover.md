# Debrief & Handover: File Transfer Engine Research

**Version:** v0.3.13
**Date:** 15 February 2026
**From:** Explorer session (`SGraph-AI__App__Send` / `claude/explorer-session-dev-y132s`)
**To:** Explorer session on `SGraph-AI__JS__Send` (the new JavaScript transfer engine repo)
**Status:** Research complete, ready for implementation

---

## Executive Summary

This session produced a **comprehensive research and architecture pack** for building a pure JavaScript file transfer engine — the core component that will power SGraph Send's upload/download flow. The research covers 10 topics across P1-P3 priority, plus 4 architecture design documents.

**Key decision:** Build the transfer engine from scratch as a standalone, multi-runtime JavaScript package. No existing library (tus, Uppy, Resumable.js) covers more than 3 of our 7 hard requirements.

All documents are self-contained in `library/sgraph-send/file-transfer-engine/` and designed to be **portable** — copy the entire folder into the new repo's `library/` directory.

---

## What Was Produced

### Research Documents (10 files)

All in `library/sgraph-send/file-transfer-engine/research/`:

| # | File | Priority | Key Finding |
|---|------|----------|-------------|
| 01 | [S3 Multipart & Presigned URLs](../../../library/sgraph-send/file-transfer-engine/research/01-s3-multipart-and-presigned-urls.md) | P1 | Browser-direct multipart upload via per-part presigned URLs. Lambda never touches file data. Use `UploadPartCommand` (not `PutObjectCommand`) for part URLs. XHR for upload progress (Fetch has no upload progress). |
| 02 | [tus, Uppy, Resumable.js](../../../library/sgraph-send/file-transfer-engine/research/02-tus-uppy-resumable-js.md) | P1 | **Build from scratch.** Borrow patterns from tus (retry backoff, httpStack interface, middleware hooks) and Uppy's S3 plugin (presigned URL functions, `shouldUseMultipart`). Resumable.js and Flow.js are unmaintained. |
| 03 | [Browser Storage APIs](../../../library/sgraph-send/file-transfer-engine/research/03-browser-storage-apis.md) | P1 | **OPFS for binary chunks** (2-7x faster than IndexedDB), **IndexedDB for metadata** (via `idb` library, ~1 KB). localStorage is NOT viable (5-10 MB limit). OPFS supports random access — perfect for chunked resume. |
| 04 | [S3 Constraints & Costs](../../../library/sgraph-send/file-transfer-engine/research/04-s3-constraints-and-costs.md) | P1 | **Egress is 98-99% of per-transfer cost.** Dynamic chunk sizing: 5 MB for small files, up to ceil(file_size/9,500) for TB-scale. Hash-based prefix distribution (256 prefixes) for rate limit avoidance. Lifecycle policies critical for cleanup. |
| 05 | [Compression Algorithms](../../../library/sgraph-send/file-transfer-engine/research/05-compression-algorithms.md) | P2 | CompressionStream API (zero deps, gzip) as default. fflate (8 KB, streaming) as upgrade. zstd-wasm (300 KB) for strong compression. **Auto-skip** already-compressed files via magic bytes. Pipeline invariant: compress → encrypt → upload. |
| 06 | [Chunked Encryption Patterns](../../../library/sgraph-send/file-transfer-engine/research/06-chunked-encryption-patterns.md) | P1 | Per-chunk AES-256-GCM with **counter-derived IVs** (chunk index in last 4 bytes) and **AAD binding** (`{chunk_index, total_chunks, transfer_id}`). 28 bytes overhead per chunk. `crypto.subtle` works identically across all runtimes. |
| 07 | [Cloud Providers Comparison](../../../library/sgraph-send/file-transfer-engine/research/07-cloud-providers-comparison.md) | P2 | **R2 is 95x cheaper than S3** for downloads ($0.0005 vs $0.091 per 1 GB). A single S3 adapter covers 4 of 5 providers (AWS, R2, B2, GCS XML). Only Azure needs its own adapter. |
| 08 | [WebRTC P2P Transfer](../../../library/sgraph-send/file-transfer-engine/research/08-webrtc-p2p-transfer.md) | P2 | Phase 3 feature, not Phase 1. PeerJS or raw WebRTC API (simple-peer is unmaintained since 2022). TURN: Cloudflare Realtime at $0.05/GB. Hybrid approach: WebRTC when both online, S3 fallback always. |
| 09 | [Lambda Streaming Responses](../../../library/sgraph-send/file-transfer-engine/research/09-lambda-streaming-responses.md) | P3 | Streaming limit is now 200 MB (not 20 MB), but **2 MB/s bandwidth cap** makes it impractical. Mangum doesn't support streaming. **Not needed** — presigned URLs bypass Lambda entirely. |
| 10 | [Content-Addressable Storage](../../../library/sgraph-send/file-transfer-engine/research/10-content-addressable-storage.md) | P3 | CAS is safe for SGraph Send (operates on ciphertext, random keys). Phase 1: hash-based storage keys. Phase 4: content-defined chunking (FastCDC). Cross-transfer dedup conflicts with zero-knowledge — don't implement. |

### Architecture Documents (4 files)

All in `library/sgraph-send/file-transfer-engine/architecture/`:

| File | What It Contains |
|------|-----------------|
| [Adapter Interfaces](../../../library/sgraph-send/file-transfer-engine/architecture/adapter-interfaces.md) | Full interface design for 6 adapters: Storage, Transport, Crypto, Compression, Cache, Progress. JSDoc types, method signatures, example implementations for browser + Node.js. TransferEngine orchestrator class. |
| [Transfer Manifest Schema](../../../library/sgraph-send/file-transfer-engine/architecture/transfer-manifest-schema.md) | JSON schema v1 with full field reference. Status lifecycle (`pending → uploading → completed → expired`). Storage layout. Backward compatibility with current single-blob format. Security properties. |
| [Comparison Matrix](../../../library/sgraph-send/file-transfer-engine/architecture/comparison-matrix.md) | 12 architecture decisions across 7 categories. Build-vs-buy analysis. Cost comparisons. Provider feature matrices. Requirements scorecards. |
| [Recommendations](../../../library/sgraph-send/file-transfer-engine/architecture/recommendations.md) | 4 implementation phases with component lists. Critical path for Phase 1. What NOT to build yet. Risk register. Success criteria. |

---

## How to Use This in `SGraph-AI__JS__Send`

### Step 1: Copy the Folder

Copy the entire `library/sgraph-send/file-transfer-engine/` directory into the new repo:

```
SGraph-AI__JS__Send/
  library/
    file-transfer-engine/       ← copy this entire folder
      README.md
      research/
        01-s3-multipart-and-presigned-urls.md
        02-tus-uppy-resumable-js.md
        03-browser-storage-apis.md
        04-s3-constraints-and-costs.md
        05-compression-algorithms.md
        06-chunked-encryption-patterns.md
        07-cloud-providers-comparison.md
        08-webrtc-p2p-transfer.md
        09-lambda-streaming-responses.md
        10-content-addressable-storage.md
      architecture/
        adapter-interfaces.md
        transfer-manifest-schema.md
        comparison-matrix.md
        recommendations.md
```

### Step 2: Read in This Order

1. **`README.md`** — index and reading paths
2. **`architecture/recommendations.md`** — what to build, in what order, why
3. **`architecture/comparison-matrix.md`** — the 12 architecture decisions
4. **`architecture/adapter-interfaces.md`** — the pluggable adapter API design
5. **`architecture/transfer-manifest-schema.md`** — the manifest JSON schema

Then dive into individual research docs as needed during implementation.

### Step 3: Start Building Phase 1

The critical path for Phase 1 (from `recommendations.md`):

```
TransferEngine (orchestrator)
├── TransferManifest (state management)
├── ChunkManager (split file, track chunks)
├── S3StorageAdapter (presigned URLs, multipart)
├── FetchTransportAdapter (HTTP upload/download)
├── WebCryptoAdapter (per-chunk AES-256-GCM)
├── MemoryCacheAdapter (for tests)
└── ConsoleProgressAdapter (CLI output)
```

**Estimated scope:** ~2,000-3,000 lines of pure JavaScript + ~1,500 lines of tests.

**Success criteria:**
- Upload a 100 MB file from CLI to S3 in chunks with progress
- Download and verify integrity (SHA-256 match)
- Interrupt at 50%, resume, complete successfully
- Full test suite against in-memory storage (no AWS required)
- Same core engine code runs in Node.js and browser

---

## Key Architecture Decisions (Quick Reference)

| # | Decision | Choice |
|---|----------|--------|
| AD-1 | Upload library | Build from scratch (borrow tus/Uppy patterns) |
| AD-2 | Primary storage | AWS S3 via presigned URLs |
| AD-3 | Cost optimization | Cloudflare R2 (S3-compatible, zero egress) |
| AD-4 | Default compression | CompressionStream API (gzip, zero deps) |
| AD-5 | Browser storage | OPFS (binary) + IndexedDB (metadata) |
| AD-6 | Encryption | Per-chunk AES-256-GCM, counter IVs, AAD |
| AD-7 | Upload transport | Browser → S3 presigned URLs (bypass Lambda) |
| AD-8 | Download transport | S3/CloudFront signed URLs |
| AD-9 | P2P | Phase 3 — WebRTC with S3 fallback |
| AD-10 | Multi-runtime | Pure JS core, platform adapters injected |
| AD-11 | Transfer state | Transfer manifest JSON as single source of truth |
| AD-12 | Pipeline order | compress → encrypt → upload (invariant) |

---

## What's NOT in This Pack

- **No implementation code** — this is research and architecture only
- **No SGraph Send-specific logic** — the engine is generic, SGraph Send configures it
- **No deployment configuration** — that's the Villager's job
- **No UI design** — the three-level progress display needs Designer input

---

## Origin Brief

All research was driven by: `team/humans/dinis_cruz/briefs/02/15/v0.3.12__briefs__file-transfer-engine-architecture-and-research.md`

This brief defines the principles (maximum visibility, no data loss, reduce anxiety, minimize resources, respect user wishes) and the research agenda (10 items across P1-P3).

---

## Source Branch

All files are on branch `claude/explorer-session-dev-y132s` in `SGraph-AI__App__Send`.
