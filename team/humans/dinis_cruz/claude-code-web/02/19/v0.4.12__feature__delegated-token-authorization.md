# FEATURE: Delegated Token Authorization

**version** v0.4.12
**date** 19 Feb 2026
**from** Human (project lead)
**type** Feature request — born from incident
**origin** Access token leak incident (v0.4.12) — vuln converted to feature
**status** PROPOSED

---

## Context: From Vulnerability to Feature

The access token leak incident (19 Feb 2026) revealed that embedding the sender's auth token in shareable URLs was wrong as a security mechanism — but the *underlying need* was real: recipients need authorization to interact with shared content, and it's useful for them to be able to reply immediately.

The vulnerability pointed at a missing capability: **delegated authorization** — the ability for a token holder to grant limited, scoped access to others.

---

## The Feature

### Core Concept: Token Delegation as a Graph

Allow users to create tokens for other users, or to share their own token's authority in a controlled way. All token relationships form a graph:

- **Token A** creates **Token B** (delegation edge)
- **Token B**'s usage is tracked against both B and A (graph attribution)
- The creator of Token A can see usage flowing through tokens they delegated
- Recipients can reply/upload using delegated authority without holding the original credential

### Key Capabilities

1. **Sender delegates download access** — When sharing a link, the sender can optionally create a scoped, time-limited download token. This token is purpose-built for the recipient (not the sender's own credential).

2. **Recipient can reply** — A delegated token can optionally include upload permission, allowing the recipient to send an encrypted reply back. The reply is attributed to the delegated token, which traces back to the original sender's token.

3. **Token-creates-token** — Token holders can spawn child tokens with equal or lesser permissions. Each child token's usage rolls up to its parent. This creates a token graph.

4. **Usage attribution flows through the graph** — When Token B (delegated by Token A) is used, the usage event is recorded against:
   - Token B (direct usage)
   - Token A (delegated usage)
   - This enables "who did my tokens enable?" visibility

5. **Dual authorization for sensitive operations** — Some actions could require consent from both the token creator and the token holder (e.g., "allow this recipient to upload files using my quota"). This prevents unilateral delegation of expensive operations.

### Token Graph Model

```
Token: "dinis-main" (root, 1000 uses)
  ├── Token: "project-alpha-share" (delegated, 50 uses, download-only)
  │     ├── Token: "alice-reply" (delegated, 5 uses, upload+download)
  │     └── Token: "bob-download" (delegated, 10 uses, download-only)
  └── Token: "demo-day" (delegated, 100 uses, download-only, expires 2026-03-01)
```

Each edge carries:
- **Scope** — what the child token can do (download, upload, reply, delegate)
- **Quota** — usage limit (cannot exceed parent's remaining quota)
- **Expiry** — time limit (cannot exceed parent's expiry)
- **Attribution** — every use is visible to the parent token holder

---

## Why This Matters

1. **Recipients can interact immediately** — no separate onboarding, no separate token request. The sender controls the scope.

2. **"All of this is a graph"** — token delegation creates a social/authorization graph on top of the transfer graph. Who shared with whom, who replied to whom, who delegated to whom — all traceable.

3. **Zero-knowledge still holds** — the delegation graph is about *authorization*, not *content*. The server still never sees plaintext. Delegated tokens authorize encrypted transfers, not decrypted content.

4. **Solves the original design intent** — the v0.1.3 developer wanted recipients to have download authorization. Delegated tokens do this *correctly*: the recipient gets their own scoped token, not a copy of the sender's credential.

5. **Enterprise use cases** — a company admin creates tokens for teams, teams create tokens for external partners, usage rolls up through the hierarchy. The graph IS the org chart.

---

## Design Constraints

- **Token B can never exceed Token A's permissions** — delegation only narrows scope
- **Revocation cascades** — revoking Token A revokes all children (unless explicitly detached)
- **No credential forwarding** — the delegated token is a NEW token with its own identity, not a copy of the parent
- **Server-side only** — token delegation happens via API, not embedded in URLs
- **The hash fragment stays sacred** — decryption keys never leave the hash fragment, delegation tokens live in API headers or separate parameters

---

## Connection to Existing Architecture

| Component | Relevance |
|-----------|-----------|
| **AD-20 (Channel abstraction)** | Channels could have associated delegated tokens — "this channel's participants all have delegated download tokens" |
| **AD-23 (compare_and_swap)** | Atomic token operations needed for safe delegation quota tracking |
| **Token service (Admin Lambda)** | Needs parent_token_name field, delegation endpoint, graph query endpoint |
| **Accountant role** | Token graph enables cost attribution through delegation chains |
| **Encrypted chat (17 Feb brief)** | Chat participants could receive delegated tokens automatically when joining a channel |

---

## Phases

| Phase | Scope | Complexity |
|-------|-------|------------|
| **1. Scoped download tokens** | Sender creates a purpose-built download token for a specific transfer. Replaces the leaked-credential pattern. | Low — extends existing token model |
| **2. Reply tokens** | Download token can optionally carry upload permission for encrypted replies | Medium — new transfer type ("reply to transfer X") |
| **3. Token-creates-token** | Any token holder can delegate child tokens. Usage graph visible to parent. | Medium — new data model (parent_token, delegation edges) |
| **4. Dual authorization** | Sensitive delegations require consent from both parties | High — consent workflow, possibly async |

---

## For the Architect

Design the token delegation data model and API surface. Key questions:

1. How does delegation interact with the channel abstraction (AD-20)?
2. Should delegation be a property of the token model or a separate relationship model?
3. How does revocation cascade work with in-flight transfers?
4. What's the query model for "show me all usage attributed to my token graph"?

## For the Dev

Phase 1 is the immediate priority — replace the removed `?token=` pattern with a proper scoped download token. This directly addresses the incident: instead of leaking the sender's credential, create a new token scoped to that transfer.

---

*"Interesting that a vuln is then converted into a feature"* — the best security improvements come from understanding what the broken code was trying to do, then doing it properly.
