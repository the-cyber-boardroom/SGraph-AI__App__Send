# v0.2.15 -- SGraph Send MVP: Zero-Knowledge File Sharing, Built by an AI Team

**Version:** v0.2.15
**Date:** 12 February 2026
**Role:** Journalist
**Type:** Feature article -- MVP milestone
**LinkedIn:** https://www.linkedin.com/feed/update/urn:li:ugcPost:7427535451630276608/

---

## The headline

SGraph Send has achieved its first working end-to-end encrypted file transfer. A file was encrypted in a browser, uploaded to an AWS Lambda function, downloaded from a separate browser window, and decrypted -- with the server never seeing the original file, the file name, or the decryption key. The entire application was designed, built, and tested by a coordinated team of 10 AI agents.

---

## 1. What happened

On 12 February 2026, SGraph Send completed its MVP milestone: a full transfer cycle running live on AWS Lambda.

The sequence:

1. A user drops a file onto the upload page in their browser.
2. The browser generates a 256-bit AES-GCM encryption key and encrypts the file entirely client-side.
3. The encrypted blob is uploaded to the server. The server stores it -- but has no way to read it.
4. The user receives two things: a download link, and a decryption key. They are advised to share these via separate channels.
5. A second user opens the download link in a different browser, enters the key, and receives the original file -- decrypted entirely in their browser.

The server, at no point in this process, possesses the decryption key, the file name, or the plaintext content. It stores encrypted bytes and metadata. That is all.

This was verified live on AWS Lambda, deployed via the project's CI/CD pipeline. The pipeline runs unit tests, increments the version tag, and deploys both Lambda functions (user-facing and admin) automatically. From commit to live takes approximately 1.5 minutes.

**Source:** `team/humans/dinis_cruz/briefs/02/12/v0.2.10__review-of-user-site-mvp.md`, lines 99-104.

---

## 2. Zero-knowledge file sharing: what it means

"Zero-knowledge" is a term borrowed from cryptography. In the context of SGraph Send, it means one specific thing: **the server cannot read your files.** Not "we choose not to read them." Not "we promise not to read them." The server is architecturally incapable of reading them, because it never possesses the decryption key.

Here is what happens at each stage:

### What happens in your browser

Your browser uses the Web Crypto API -- a standard built into every modern browser -- to generate an AES-256-GCM encryption key. AES-256-GCM is a symmetric encryption algorithm that provides both confidentiality (nobody can read the data without the key) and integrity (any tampering is detected). The "256" refers to the key length in bits: 2^256 possible keys, a number larger than the estimated number of atoms in the observable universe.

The implementation is at `sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.0/js/crypto.js`. The key code is five lines:

```javascript
async generateKey() {
    return window.crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
}
```

Each file gets a fresh random 96-bit initialisation vector (IV). The encrypted output format is straightforward: the first 12 bytes are the IV, followed by the ciphertext and the GCM authentication tag. This format means decryption only needs two things: the encrypted blob and the key.

### What the server receives

The server receives an opaque binary blob. It stores that blob and some metadata: a hashed version of the sender's IP address (SHA-256), a timestamp, and the file size. It does not receive the file name, the decryption key, or any indication of what the file contains.

The server-side implementation is at `sgraph_ai_app_send/lambda__user/service/Transfer__Service.py`. When a transfer is completed, the service explicitly logs what it stored and what it did not:

```python
transparency = dict(
    ip             = meta['sender_ip_hash'],
    timestamp      = meta['created_at'],
    file_size_bytes= meta['file_size_bytes'],
    stored_fields  = ['ip_hash', 'file_size_bytes', 'created_at', 'content_type_hint'],
    not_stored     = ['file_name', 'decryption_key', 'raw_ip']
)
```

This transparency object is returned to the user and displayed in the browser.

### What happens if the server is compromised

If an attacker gains full access to the server -- every Lambda function, every storage location, every log file -- they get encrypted blobs. Without the decryption key (which exists only on the sender's device and wherever they chose to share it), those blobs are computationally useless. A complete server breach is, by design, a non-event for file confidentiality.

This is the core architectural choice that makes SGraph Send different from most file-sharing services, where the server holds the keys and could, in principle, read every file it stores.

---

## 3. Transparency by design

Most services tell users what they collect in a privacy policy -- a legal document that nobody reads, written after the product is built. SGraph Send takes a different approach: it shows users what the server knows, in real time, as part of the product itself.

After uploading a file, the sender sees a transparency panel that lists exactly what was captured:

- **Your IP address** (hashed with SHA-256)
- **Upload time**
- **File size**

And explicitly what was NOT captured:

- **File name** -- NOT stored
- **File content** -- Encrypted (we cannot read it)
- **Decryption key** -- NOT stored (only you have it)

Followed by: "That's everything. Nothing else is captured."

This is implemented as a Web Component (`send-transparency`) that renders the transparency data returned by the API. The component takes the server's response and displays it directly -- no client-side filtering, no selective presentation. What the server returns is what the user sees.

The transparency panel appears for both senders and receivers. When someone downloads a file, they see what the server captured about their download: their IP, the download timestamp, and their browser's user-agent string. They are also told that this information will be visible to the sender on the transfer's status page.

This is not a privacy policy. It is a live data receipt.

**Source:** `sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.0/components/send-transparency/send-transparency.js`

---

## 4. How an AI team built a working product

SGraph Send was not built by a single developer or a traditional development team. It was built by a system of 10 AI agent roles, coordinated through a structured workflow, with a human stakeholder (Dinis Cruz) providing direction and making final decisions.

### The team

| Role | Responsibility |
|------|----------------|
| **Conductor** | Orchestration, priority management, task routing |
| **Architect** | API contracts, data models, system topology |
| **Dev** | Backend and frontend implementation |
| **QA** | Test strategy, test execution, quality assurance |
| **DevOps** | CI/CD pipelines, deployment configuration |
| **AppSec** | Security review, threat modelling |
| **Librarian** | Knowledge base maintenance, documentation indexing |
| **Cartographer** | System maps, dependency graphs |
| **Historian** | Decision tracking, rationale capture |
| **Journalist** | External communications, feature articles |

Each role operates within a defined scope, produces review documents in its own folder, and communicates through the shared repository structure. The human stakeholder writes briefs that drive priorities, reviews output, and makes architectural decisions.

### How the MVP was built

The process followed a structured path from specification to deployment:

1. **Project brief** defined the product: what it does, who it serves, how the encryption works, what the API looks like. This 800-line document covered user stories, architecture, deployment, and the full issue tree.

2. **Architect** designed the system topology: two Lambda functions (user-facing and admin), a storage abstraction layer, and the client-side encryption scheme. The Architect identified that 7 deployment targets reduce to 4 unique patterns (Lambda, Container, Server, CLI), simplifying the infrastructure work by approximately 40%.

3. **Dev** built the backend (FastAPI on Python 3.12) and frontend (Vanilla JS with Web Components) in parallel. The backend implements five transfer endpoints: create, upload, complete, info, and download. The frontend implements two Web Components: `send-upload` for the upload flow and `send-download` for the download flow. Zero framework dependencies.

4. **QA** wrote 44 tests covering schemas, service logic, routes, and static page serving. All tests use real implementations with an in-memory backend -- no mocks, no patches. The entire test suite starts the full application stack in memory in approximately 100 milliseconds.

5. **DevOps** configured the CI/CD pipeline: push to the `dev` branch triggers unit tests, version tag increment, and deployment of both Lambda functions. The pipeline is defined in GitHub Actions and completes in approximately 1.5 minutes.

6. **AppSec** verified the encryption model: AES-256-GCM inherently prevents silent file corruption (a wrong key produces a clear authentication failure, not a corrupted file), and the no-plaintext guarantee is maintained through the architecture.

7. **Dinis Cruz** (the human stakeholder) wired up the Lambda deployment, configured the Function URLs, and performed the first live end-to-end test that confirmed the full transfer cycle works.

### What the codebase looks like

The application is approximately 2,000 lines of code:

- **Backend:** Python/FastAPI with routes, services, and schemas following the Type_Safe pattern from osbot-utils
- **Frontend:** Vanilla JavaScript with three Web Components (upload, download, transparency) and a crypto wrapper
- **Tests:** 44 passing tests, all using real in-memory implementations
- **Deployment:** Two AWS Lambda functions with Function URLs (no API Gateway), deployed via GitHub Actions
- **Package:** Published on PyPI as `sgraph-ai-app-send`

The entire stack -- application code, static frontend assets, Lambda handlers -- fits in a single repository. The backend uses the Memory-FS abstraction layer, meaning the storage backend can be swapped between memory, disk, and S3 through configuration without changing application code.

---

## 5. From spec to Lambda in 12 days

The project brief was written in early February 2026. Twelve days later, the MVP was live on AWS Lambda.

### The timeline

| Date | Event |
|------|-------|
| Early Feb | Project brief written: 800 lines defining the product, architecture, and issue tree |
| 8 Feb | v0.1.0 -- First human review of dev and librarian commits; Admin Lambda already scaffolded |
| 10 Feb | v0.1.4 -- Infrastructure brief: focus on getting every deployment target working |
| 10 Feb | All 10 roles respond to the infrastructure brief; master index compiled |
| 10 Feb | v0.2.1 -- Repo refactored; 8 role responses indexed; critical path identified |
| 11 Feb | Backend transfer service and routes implemented; frontend encryption and UI components built |
| 12 Feb | v0.2.10 -- CI/CD deploys automatically to Lambda; live end-to-end test succeeds |
| 12 Feb | Dinis Cruz posts the working MVP on LinkedIn |

The critical insight from the Architect and Cartographer was that the critical path runs through: **Schemas --> Storage Wrapper --> Transfer Service --> User Lambda --> Frontend --> E2E**. Everything not on this path was deferred. The team did not attempt to solve all 7 deployment targets simultaneously; they shipped Lambda first and will replicate across the matrix.

### What "working" means

Working means Dinis Cruz was able to:

1. Open the SGraph Send site served by a Lambda Function URL
2. Drop a file onto the upload page
3. Watch it encrypt in the browser and upload to the Lambda
4. Copy the download link and the decryption key
5. Open the download link in a separate browser window
6. Enter the decryption key
7. Receive the original file, intact

This was done on the live Lambda deployment, not in a local development environment. The same Lambda Function URL served both the static frontend and the API endpoints.

**Source:** `team/humans/dinis_cruz/briefs/02/12/v0.2.10__review-of-user-site-mvp.md`, lines 99-106

---

## 6. The technical details

For those who want to look under the hood.

### Encryption

- **Algorithm:** AES-256-GCM (Galois/Counter Mode)
- **Key length:** 256 bits (32 bytes)
- **IV length:** 96 bits (12 bytes), randomly generated per file
- **Key format:** Base64url-encoded, 44 characters -- short enough to paste into a message
- **Wire format:** `[12 bytes IV][ciphertext + GCM auth tag]`
- **API:** Web Crypto API (`window.crypto.subtle`), available in all modern browsers over HTTPS

### Backend

- **Runtime:** Python 3.12 on ARM64
- **Framework:** FastAPI (via osbot-fast-api), adapted for Lambda via Mangum
- **Deployment:** AWS Lambda with Function URLs (direct HTTPS endpoints, no API Gateway)
- **Storage:** Memory-FS abstraction layer (currently in-memory; S3 backend ready to plug in)
- **Type system:** Type_Safe from osbot-utils (no Pydantic)

### Transfer API

Five endpoints implement the transfer lifecycle:

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/transfers/create` | POST | Initiate a transfer, get upload URL |
| `/transfers/upload/{id}` | POST | Upload encrypted payload |
| `/transfers/complete/{id}` | POST | Mark transfer complete, get download URL and transparency data |
| `/transfers/info/{id}` | GET | Get transfer metadata |
| `/transfers/download/{id}` | GET | Download encrypted payload |

### Frontend

- **Technology:** Vanilla JavaScript, Web Components (Custom Elements), zero framework dependencies
- **Components:** `send-upload`, `send-download`, `send-transparency`
- **Methodology:** IFD (Incremental Functional Deployment) -- surgical versioning, zero build step
- **Versioned paths:** `v0/v0.1/v0.1.0/index.html`

### CI/CD

- **Trigger:** Push to `dev` branch
- **Pipeline:** Run unit tests --> Increment version tag --> Deploy Admin Lambda --> Deploy User Lambda
- **Duration:** ~1.5 minutes from commit to live
- **Tests:** 44 unit tests, all using real in-memory implementations (no mocks)
- **Package:** Published on PyPI as `sgraph-ai-app-send`

---

## 7. What comes next

The MVP proves the core flow works. The immediate roadmap focuses on three areas:

1. **Storage persistence.** The current in-memory backend means files are lost when the Lambda function cold-starts. Plugging in the S3 storage backend via Memory-FS will make transfers persistent. The application code will not change -- only the storage configuration.

2. **Code hardening.** Dinis Cruz's review identified multiple areas where raw Python primitives (dicts, strings) should be replaced with Type_Safe classes, and where the Memory-FS abstraction should replace direct storage operations. The Dev role has a detailed improvement plan.

3. **Deployment matrix.** Lambda is target one of four deployment patterns (Lambda, Container, Server, CLI). Docker, ECS Fargate, EC2, and GCP Cloud Run are next. The Architect's analysis shows these reduce to 4 unique configurations, not 7.

The infrastructure brief's definition of "done" remains the north star: push a commit, watch it flow through CI to a live deployment, perform a full transfer cycle (upload, encrypt, share, download, decrypt, verify), and see it work across all deployment targets.

---

## 8. Why this matters

File sharing should be simple. It should also be private by default, not by policy.

Most file-sharing services encrypt data in transit (HTTPS) and at rest (server-side encryption), but the server itself can read every file. The service provider has access to your data. Their privacy policy is a promise, not a guarantee.

SGraph Send takes a fundamentally different position: the server is architecturally excluded from access to file content. It stores encrypted bytes. The decryption key never leaves the sender's device. Even a complete server compromise cannot expose file content.

And the transparency panel makes this verifiable. It does not ask you to trust a privacy policy. It shows you, in real time, exactly what the server captured and what it did not.

This MVP proves the concept works end-to-end, from browser encryption to Lambda deployment to browser decryption. It is not yet production-ready -- persistence, token authentication, and the full deployment matrix are still ahead. But the core architectural bet is validated: zero-knowledge file sharing is technically feasible, user-friendly, and deployable on standard serverless infrastructure.

---

## Sources

| Claim | Source |
|-------|--------|
| End-to-end transfer verified on Lambda | `team/humans/dinis_cruz/briefs/02/12/v0.2.10__review-of-user-site-mvp.md`, lines 99-104 |
| AES-256-GCM encryption implementation | `sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.0/js/crypto.js` |
| Transfer API implementation | `sgraph_ai_app_send/lambda__user/fast_api/routes/Routes__Transfers.py` |
| Transfer service and transparency data | `sgraph_ai_app_send/lambda__user/service/Transfer__Service.py` |
| Transparency panel implementation | `sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.0/components/send-transparency/send-transparency.js` |
| Upload component implementation | `sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.0/components/send-upload/send-upload.js` |
| CI/CD pipeline configuration | `.github/workflows/ci-pipeline__dev.yml`, `.github/workflows/ci-pipeline.yml` |
| Infrastructure brief (7 targets, 4 patterns) | `team/humans/dinis_cruz/briefs/02/10/v0.1.4__briefs__focus-on-mvp-release-infrastructure.md` |
| Master index of role responses | `team/roles/librarian/reviews/26-02-10/v0.2.1__master-index__infrastructure-brief-responses.md` |
| Project brief | `library/docs/_to_process/project - Secure Send Service brief.md` |
| LinkedIn announcement | https://www.linkedin.com/feed/update/urn:li:ugcPost:7427535451630276608/ |

---

## AppSec verification notes

The following security claims in this article require AppSec verification before publication in any external-facing channel:

1. "AES-256-GCM ... provides both confidentiality and integrity" -- Verified in principle by AppSec in the v0.2.1 infrastructure brief response. Implementation-level verification pending.
2. "The server is architecturally incapable of reading them" -- True by design (key never sent to server). Needs AppSec confirmation that no code path leaks the key.
3. "A complete server breach is, by design, a non-event for file confidentiality" -- True assuming key is not stored server-side. AppSec should verify no logging or debugging code captures key material.
4. "A wrong key produces a clear authentication failure, not a corrupted file" -- Confirmed by AppSec as inherent to AES-GCM (v0.2.1 review). The `crypto.js` implementation catches the error and displays a clear message.
5. "IP addresses hashed with SHA-256" -- Verified in `Transfer__Service.py` line 104. AppSec should review whether daily salt rotation is implemented (mentioned in CLAUDE.md but not observed in current code).

---

*SGraph Send Journalist -- MVP Milestone Article*
*Version: v0.2.15*
*Date: 12 February 2026*
