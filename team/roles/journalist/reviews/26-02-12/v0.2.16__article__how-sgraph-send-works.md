# How SGraph Send Works: A Visual Walkthrough

**Version:** v0.2.16
**Date:** 12 February 2026
**Role:** Journalist
**Type:** Feature article -- product walkthrough with screenshots

---

## What is SGraph Send?

SGraph Send is zero-knowledge encrypted file sharing. You drop a file into your browser, it gets encrypted before it ever leaves your device, and the encrypted blob is uploaded to the server. The decryption key stays with you. The server stores ciphertext it cannot read. You share the download link and the key separately, through different channels, so that no single interception can compromise your file. That is the whole idea: privacy enforced by architecture, not by policy.

This article walks through the complete workflow, step by step, using screenshots from the live product at [send.sgraph.ai](https://send.sgraph.ai).

---

## Step 1: The upload page

<img width="600" alt="SGraph Send main upload page showing drag-and-drop zone and test files" src="https://github.com/user-attachments/assets/f6a37952-fddf-4842-877a-4d59b9ee81ee" />

This is what you see when you open SGraph Send. The header states the product's purpose plainly: "Zero-knowledge encrypted file sharing." Below it is a drag-and-drop zone with the message: "Drop your file here or click to browse -- Encrypted in your browser before upload."

That last phrase is doing real work. It is not marketing language. It is a description of what actually happens: the file is encrypted using AES-256-GCM in your browser, via the Web Crypto API, before any data is transmitted to the server. The encryption key is generated locally, on your device, and never sent anywhere.

At the bottom of the page, a Test Files section offers sample files (test-text.txt and test-data.json) so you can try the workflow without using your own data.

---

## Step 2: File selected, ready to encrypt

<img width="600" alt="File selected for upload showing test-data.json at 333 bytes with Encrypt and Upload button" src="https://github.com/user-attachments/assets/fb5e68b7-a741-4aff-a816-99974695a067" />

After dropping a file -- in this case, test-data.json at 333 bytes -- the interface shows you what you have selected and presents a single action: "Encrypt & Upload."

Nothing has happened yet. The file has not left your browser. No network request has been made. The file sits in browser memory, waiting for you to confirm. When you click that button, two things happen in rapid sequence: (1) the browser generates a fresh AES-256-GCM key and encrypts the file, and (2) the encrypted blob is uploaded to the server. The plaintext never touches the network.

---

## Step 3: Encrypted and uploaded

<img width="600" alt="Upload success screen showing download link, decryption key, and transparency panel" src="https://github.com/user-attachments/assets/f5bcbf42-36d1-4c4d-abc0-83bc3083c48a" />

The file has been encrypted and uploaded. The success screen gives you two pieces of information you need to share with your recipient:

- **Download link** -- a URL ending in `?id=b9fe240eba7f` that points to the encrypted file on the server.
- **Decryption key** -- a base64url-encoded string (`ypIKxlu9Q3nqkT-dtCodoUPVBzWn75ZKvsRX79XpKm8`) that exists only in your browser.

Between these two fields, an orange security tip reads: "For best security, share the link and the key via different channels." This is the core operational security practice of SGraph Send. Send the link by email. Send the key by Signal, WhatsApp, or a text message. If someone intercepts the email, they get a link to an encrypted blob they cannot read. If someone intercepts the message, they get a key with nothing to decrypt. Both pieces are needed; neither is useful alone.

Below the sharing fields is the **transparency panel**. This is not buried in a privacy policy. It is displayed right here, immediately after the upload, as part of the product experience:

- File size: 333 B
- File name: NOT stored
- Decryption key: NOT stored (only you have it)
- raw_ip: NOT stored

And then: "That's everything. Nothing else is captured."

The transparency panel is a live data receipt. It shows you exactly what the server recorded and, just as importantly, what it did not. The server never saw your file name. It never saw your decryption key. It never stored your raw IP address. It has encrypted bytes, a file size, a timestamp, and a hashed IP. That is the complete inventory.

---

## Step 4: The recipient's download page

<img width="600" alt="Download page showing encrypted file metadata and a field to paste the decryption key" src="https://github.com/user-attachments/assets/2bcf7574-8eb7-4456-9a0f-442bd5d7a644" />

This is what your recipient sees when they open the download link. The page tells them an encrypted file is waiting -- 333 bytes, uploaded Thu, 12 Feb 2026 23:53:12 GMT -- and presents a single input field: "Paste the decryption key here."

The recipient cannot do anything without the key. The server has the encrypted blob, but cannot decrypt it. The download page has the interface, but cannot decrypt without the key. The recipient needs both the link (which brought them here) and the key (which you shared separately). This is the channel separation principle in action.

Once the recipient pastes the key and clicks "Download & Decrypt," the browser fetches the encrypted blob from the server, decrypts it locally using the Web Crypto API, and saves the original file.

---

## Step 5: Decryption succeeds

<img width="600" alt="Successful decryption screen showing green success message and download-side transparency panel" src="https://github.com/user-attachments/assets/a7e52ea7-d310-4f9a-8c77-8ca752dc77e0" />

The file has been decrypted and saved. A green success message confirms: "File decrypted and saved successfully."

The transparency panel appears again, this time from the recipient's perspective:

- Download time: recorded
- File size: 333 B
- File name: NOT stored
- File content: "Encrypted (we cannot read it)"
- Decryption key: "NOT stored (only you have it)"

And again: "That's everything. Nothing else is captured."

The decryption happened entirely in the browser. The server served the encrypted blob over HTTPS, but the actual decryption -- turning ciphertext back into the original file -- happened on the recipient's device. The server was a delivery mechanism for data it could not read.

---

## Step 6: The original file, intact

<img width="600" alt="The downloaded test-data.json file opened in a text editor showing the original content perfectly intact" src="https://github.com/user-attachments/assets/2b8f882f-1526-4084-928d-90c9602227e5" />

The final proof. The downloaded file, opened in a text editor, shows the original test-data.json content perfectly intact. The JSON structure, the test description ("QA testing of SGraph Send upload flow"), the sample data -- everything is exactly as it was before encryption.

This is not a lossy process. AES-256-GCM is a symmetric cipher: encrypt with a key, decrypt with the same key, get the exact original bytes back. The file is byte-for-byte identical to what was uploaded. If it were not -- if even a single bit were different -- GCM's built-in authentication would reject the decryption entirely rather than produce a corrupted file. You either get the exact original, or you get a clear error. Never silent corruption.

---

## The security model

Three properties make SGraph Send's approach meaningfully different from conventional file sharing.

### The server cannot read your files

This is not a policy decision. It is an architectural fact. The decryption key is generated in your browser and never transmitted to the server. The server receives and stores an encrypted blob. Without the key, that blob is computationally useless -- AES-256 has 2^256 possible keys, a number larger than the estimated atoms in the observable universe.

A full server compromise -- every Lambda function, every S3 bucket, every log file -- yields encrypted data that cannot be decrypted. This is the "zero-knowledge" guarantee: the server has zero knowledge of your file content, by construction.

### Channel separation protects against interception

The security tip displayed after upload -- "share the link and the key via different channels" -- is the most important operational practice in the workflow. If you send the download link by email and the decryption key by Signal:

- An attacker who compromises your email gets a link to ciphertext they cannot read.
- An attacker who compromises your Signal gets a key with nothing to apply it to.
- Only an attacker who compromises both channels simultaneously can access the file.

This is a meaningful upgrade over the common practice of sending a file and its password in the same email thread.

### Transparency replaces trust

Most services ask you to trust their privacy policy. SGraph Send shows you a live data receipt at every stage of the workflow -- after upload and after download. The transparency panel lists exactly what was stored and what was not, with no ambiguity.

This is a design choice, not a technical requirement. The team built the transparency panel because they believe privacy claims should be verifiable in the product itself, not buried in legal documents. If the server stores something new in a future version, it will appear in the transparency panel. If it does not appear there, it is not stored.

---

## What comes next

SGraph Send is currently in private beta. The core workflow -- encrypt, upload, share, download, decrypt -- works end-to-end on live infrastructure. Files persist in Amazon S3, surviving Lambda cold-starts and scaling across instances.

The near-term roadmap includes polished UI and branding, additional sharing modes (including a single-URL option for convenience and email templates for ease of use), multi-language support, and accessibility improvements.

If you are interested in trying SGraph Send, reach out. The "friendlies" beta is open to early users who want private, zero-knowledge file sharing that works without installing anything, without creating an account, and without trusting the server with their data.

---

*SGraph Send Journalist -- Product Walkthrough Article*
*Version: v0.2.16*
*Date: 12 February 2026*
