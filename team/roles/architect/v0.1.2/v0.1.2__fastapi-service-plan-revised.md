# v0.1.2 — FastAPI Service Plan (Revised)

**Version:** v0.1.2
**Date:** 2026-02-09
**Author:** Claude (Architect role)
**Type:** Plan Mode document — revised per Conductor review
**Status:** DRAFT

---

## Changes from v0.1.1

Key changes made per Conductor review:

| # | Change | v0.1.1 | v0.1.2 |
|---|--------|--------|--------|
| 1 | Storage layer | Direct S3 (boto3) | Memory-FS abstraction (in-memory, disk, zip, sqlite, S3 backends) |
| 2 | Lambda topology | Single Lambda behind API Gateway | Two Lambda URL Functions (public + admin) |
| 3 | API Gateway | API Gateway with /api/v1/ base path | Lambda Function URLs (no API Gateway) |
| 4 | Framework layer | Raw FastAPI + Mangum | OSBot-Fast-API provides routing, Mangum, CORS, auth |
| 5 | Schema library | Pydantic models | Type_Safe schemas everywhere (never Pydantic) |
| 6 | Base path | /api/v1/ prefix on all routes | No base path — Python client API provides versioning later |
| 7 | Events storage | Single events.json file (append race condition) | Individual files (events/ folder, one file per event) |
| 8 | Request logging | CloudWatch only | All requests logged per-transfer as files for observability |
| 9 | Timestamps | ISO 8601 strings | Ints via Timestamp_Now from osbot-utils |
| 10 | ID generation | secrets.token_urlsafe (12 chars) | Obj_Id pattern (Transfer_Id with .new() helper) |
| 11 | Test strategy | Mocks/patches for S3 | No mocks — full in-memory stack via Memory-FS |
| 12 | AWS SDK | boto3 directly | All AWS via osbot-aws (never boto3) |
| 13 | Register Interest | POST /register-interest endpoint | Removed (external platform handles this) |

---

## 1. System Architecture Overview

```
                                ┌──────────────────────┐
                                │      CloudFront       │
                                │    *.sgraph.ai SSL    │
                                └───┬──────────────┬───┘
                                    │              │
                        ┌───────────┘              └────────────────┐
                        ▼                                           ▼
            ┌───────────────────┐                       ┌──────────────────────┐
            │   S3: Frontend    │                       │  Lambda Function URL │
            │   Static Assets   │                       │  (public endpoints)  │
            │   HTML / JS / CSS │                       └──────────┬───────────┘
            └───────────────────┘                                  │
                                                                   ▼
                                                      ┌────────────────────────┐
                                                      │  Public Lambda         │
                                                      │  OSBot-Fast-API +      │
                                                      │  Mangum                │
                                                      │  Python 3.12 / arm64   │
                                                      └───────────┬────────────┘
                                                                  │
                                                                  ▼
                                                      ┌────────────────────────┐
                                                      │    Memory-FS Layer     │
                                                      │                        │
            ┌──────────────────────┐                  │  Tests:  in-memory     │
            │  Admin Lambda        │                  │  Dev:    local disk     │
            │  OSBot-Fast-API +    │─────────────────►│  Prod:   S3 (osbot-aws)│
            │  Mangum              │                  │                        │
            │  Python 3.12 / arm64 │                  └────────────────────────┘
            └──────────┬───────────┘                               │
                       │                                           │
                       ▼                                           ▼
            ┌──────────────────────┐                  ┌────────────────────────┐
            │  Lambda Function URL │                  │  S3: sgraph-send-      │
            │  (admin endpoints)   │                  │  {tier}-data           │
            │  (restricted access) │                  │                        │
            └──────────────────────┘                  │  transfers/{id}/       │
                                                      │  ├── meta.json         │
                                                      │  ├── events/           │
                                                      │  │   ├── 001__created  │
                                                      │  │   ├── 002__uploaded │
                                                      │  │   └── 003__download │
                                                      │  ├── requests/         │
                                                      │  │   └── {timestamp}   │
                                                      │  └── payload.enc       │
                                                      │                        │
                                                      │  tokens/{id}.json      │
                                                      │  admin/logs/           │
                                                      └────────────────────────┘
```

### Key Design Decisions

1. **Two Lambda Function URLs** — No API Gateway. Lambda Function URLs are simpler, cheaper, and sufficient. CloudFront can front them if custom domains or caching are needed later.

2. **Memory-FS abstraction** — The storage layer is an interface, not a concrete implementation. Tests use in-memory (fast, no setup), dev uses local disk or LocalStack, prod uses S3 via osbot-aws. Code never calls boto3 directly.

3. **OSBot-Fast-API as foundation** — Provides FastAPI app creation, Mangum wrapping, CORS configuration, and header/cookie auth out of the box. We configure it rather than rebuild it.

4. **Type_Safe everywhere** — All request/response schemas use Type_Safe from osbot-utils. This keeps the entire stack on one type system with consistent serialization.

5. **Events as individual files** — Each event is a separate file in the `events/` folder. This eliminates the read-modify-write race condition from v0.1.1's single events.json file. Listing the folder gives the full timeline.

6. **No /api/v1/ prefix** — Routes are bare paths (`/transfers/create`, not `/api/v1/transfers/create`). API versioning will be handled by the Python client package in a later phase.

---

## 2. Two-Lambda Architecture

### Public Lambda (Service__App__Send__Public)

Routes accessible to senders and recipients. No OSBot-Fast-API auth on the Lambda itself — individual routes handle sender token validation where needed.

| Route Group | Auth | Purpose |
|-------------|------|---------|
| Routes__Transfers | Bearer token (sender) for create/complete/upload; none for status/download/file | Transfer lifecycle |
| Routes__Health | None | Health check |

**Why public:** This Lambda's Function URL is the one CloudFront routes API traffic to. It handles all sender and recipient interactions. Token validation is done per-route in application code (not at the Lambda/infrastructure level) because some routes (status, download) are intentionally public.

### Admin Lambda (Service__App__Send__Admin)

Routes accessible only to the SGraph Send administrator. OSBot-Fast-API header/cookie auth is applied to ALL routes on this Lambda.

| Route Group | Auth | Purpose |
|-------------|------|---------|
| Routes__Tokens | OSBot-Fast-API header auth | Token CRUD |
| Routes__Admin_Stats | OSBot-Fast-API header auth | Usage analytics |

**Why admin:** Separate security boundary. This Lambda's Function URL can have tighter network restrictions (IP allowlist, VPC placement). It never needs to be publicly reachable. Independent scaling — admin traffic is negligible compared to public traffic. If the public Lambda is compromised, admin routes are not exposed.

### Why Two Lambdas (Not One)

1. **Simpler security model** — Admin auth is enforced at the infrastructure level (all routes on the admin Lambda require auth). No risk of accidentally exposing an admin route without auth.
2. **Network isolation** — Admin Lambda can sit behind stricter network rules. Public Lambda can be more permissive.
3. **Independent scaling** — Public Lambda scales with user traffic. Admin Lambda stays minimal.
4. **Blast radius** — A vulnerability in public-facing code cannot reach admin functionality.
5. **Deployment independence** — Admin Lambda can be updated without touching the public Lambda.

---

## 3. Application Structure

```
sgraph_ai_app_send/
├── fast_api/
│   ├── Service__App__Send__Public.py         # Public Lambda service class
│   ├── Service__App__Send__Admin.py          # Admin Lambda service class
│   ├── lambda_handler_public.py              # Mangum entry point (public)
│   ├── lambda_handler_admin.py               # Mangum entry point (admin)
│   └── routes/
│       ├── Routes__Transfers.py              # Transfer CRUD + download
│       ├── Routes__Tokens.py                 # Token CRUD (admin)
│       ├── Routes__Admin_Stats.py            # Usage stats (admin)
│       └── Routes__Health.py                 # Health check
├── schemas/
│   ├── Schema__App__Send__Transfer.py        # Full transfer object
│   ├── Schema__App__Send__Transfer__Create.py    # Create request
│   ├── Schema__App__Send__Transfer__Complete.py  # Complete response
│   ├── Schema__App__Send__Transfer__Status.py    # Status response (public view)
│   ├── Schema__App__Send__Transfer__Download.py  # Download response
│   ├── Schema__App__Send__Token.py           # Full token object
│   ├── Schema__App__Send__Token__Create.py   # Token create request
│   ├── Schema__App__Send__Event.py           # Single event
│   ├── Schema__App__Send__Transparency.py    # Transparency block
│   └── Schema__App__Send__Stats.py           # Admin stats response
├── services/
│   ├── Service__App__Send__Transfers.py      # Transfer business logic
│   ├── Service__App__Send__Tokens.py         # Token CRUD + validation
│   ├── Service__App__Send__Events.py         # Event file creation + listing
│   └── Service__App__Send__Stats.py          # Aggregate stats computation
├── storage/
│   ├── Storage__App__Send.py                 # Memory-FS wrapper for this app
│   └── Storage__App__Send__Factory.py        # Factory: memory / disk / S3
└── domain/
    ├── Transfer_Id.py                        # Obj_Id pattern + .new() helper
    ├── Token_Id.py                           # tok_ prefix + Obj_Id
    └── Admin_Key.py                          # Admin key validation helper
```

### Service Class Pattern

Each Lambda has a service class that extends the OSBot-Fast-API base:

```python
from osbot_fast_api.api.Fast_API import Fast_API

class Service__App__Send__Public(Fast_API):

    def setup_routes(self):
        self.add_routes(Routes__Transfers)
        self.add_routes(Routes__Health)
```

```python
class Service__App__Send__Admin(Fast_API):

    def setup_routes(self):
        self.add_routes(Routes__Tokens)
        self.add_routes(Routes__Admin_Stats)
```

### Lambda Handler Pattern

Each Lambda has a thin Mangum entry point:

```python
# lambda_handler_public.py
from mangum import Mangum
from sgraph_ai_app_send.fast_api.Service__App__Send__Public import Service__App__Send__Public

service = Service__App__Send__Public()
app     = service.app()
handler = Mangum(app, lifespan="off")
```

---

## 4. API Endpoints — Public Lambda

### POST /transfers/create

**Purpose:** Initiate a transfer. Validates sender token, creates transfer metadata, returns upload info.

- **Auth:** Bearer token (sender) — `Authorization: Bearer tok_xxx`
- **Request:** `Schema__App__Send__Transfer__Create`
  ```json
  {
    "file_size_bytes": 4821033,
    "content_type_hint": "application/pdf"
  }
  ```
- **Response (201):** `Schema__App__Send__Transfer`
  ```json
  {
    "transfer_id": "a3f8b2c1d4e5",
    "status": "pending",
    "file_size_bytes": 4821033,
    "content_type_hint": "application/pdf",
    "created_at": 1739088720,
    "expires_at": 1739693520,
    "token_id": "tok_x1y2z3a4b5c6"
  }
  ```
- **Errors:**
  - `401 Unauthorized` — Invalid, revoked, expired, or missing token
  - `400 Bad Request` — Missing file_size_bytes or invalid content_type_hint
  - `413 Payload Too Large` — file_size_bytes exceeds 100MB limit

**Server-side behaviour:**
1. Extract and validate Bearer token via `Service__App__Send__Tokens.validate()`
2. Generate transfer_id via `Transfer_Id.new()`
3. Create transfer folder in storage: `transfers/{transfer_id}/`
4. Save `meta.json` with status=pending, Timestamp_Now for created_at
5. Create first event: `events/001__created.json`
6. Log the request: `requests/{timestamp}.json`
7. Increment token usage_count, update last_used_at
8. Return Schema__App__Send__Transfer

### POST /transfers/upload/{transfer_id}

**Purpose:** Receive encrypted file bytes (for non-S3 backends). For S3 backend in production, a pre-signed URL may be used instead (see open question Q3).

- **Auth:** Bearer token (must match creation token)
- **Content-Type:** `application/octet-stream`
- **Body:** Raw encrypted bytes
- **Response (200):**
  ```json
  {
    "transfer_id": "a3f8b2c1d4e5",
    "status": "uploading",
    "bytes_received": 4821033
  }
  ```
- **Errors:**
  - `401 Unauthorized` — Token mismatch
  - `404 Not Found` — Transfer ID not found
  - `409 Conflict` — Transfer already completed

**Server-side behaviour:**
1. Validate Bearer token matches token_id in meta.json
2. Verify transfer status is `pending`
3. Save raw bytes to `transfers/{transfer_id}/payload.enc` via Memory-FS
4. Update meta.json: record bytes_received
5. Create event: `events/002__uploaded.json`
6. Log the request

**Note:** This endpoint exists so that the full upload flow works against in-memory and local-disk backends during testing and development. In production with S3 backend, the client may upload directly to S3 via a pre-signed PUT URL to avoid the Lambda payload size limit. The decision on how to handle the S3 case is flagged as open question Q3 for the Conductor.

### POST /transfers/complete/{transfer_id}

**Purpose:** Mark upload as complete. Returns download link and transparency data.

- **Auth:** Bearer token (must match creation token)
- **Request:** Empty body (transfer_id in path)
- **Response (200):** `Schema__App__Send__Transfer__Complete`
  ```json
  {
    "transfer_id": "a3f8b2c1d4e5",
    "status": "completed",
    "download_link": "https://dev-send.sgraph.ai/d/a3f8b2c1d4e5",
    "transparency": {
      "your_ip": "203.0.113.42",
      "upload_timestamp": 1739088720,
      "file_size_bytes": 4821033,
      "stored_fields": ["ip", "timestamp", "file_size", "content_type_hint", "token_id"],
      "not_stored": ["file_name", "file_content", "decryption_key"]
    }
  }
  ```
- **Errors:**
  - `401 Unauthorized` — Token mismatch
  - `404 Not Found` — Transfer ID not found
  - `409 Conflict` — Transfer already completed or expired

**Server-side behaviour:**
1. Validate Bearer token matches token_id in meta.json
2. Verify transfer status is `pending` or `uploading`
3. Verify payload.enc exists in storage
4. Update meta.json: status=completed, completed_at=Timestamp_Now
5. Create event: `events/003__completed.json`
6. Log the request
7. Return response with transparency data (read from meta.json)

### GET /transfers/status/{transfer_id}

**Purpose:** Get transfer metadata, download count, and events timeline. Public endpoint for the sender's status page.

- **Auth:** None (public)
- **Response (200):** `Schema__App__Send__Transfer__Status`
  ```json
  {
    "transfer_id": "a3f8b2c1d4e5",
    "status": "completed",
    "file_size_bytes": 4821033,
    "created_at": 1739088720,
    "expires_at": 1739693520,
    "download_count": 2,
    "events": [
      { "type": "created",   "timestamp": 1739088720 },
      { "type": "uploaded",  "timestamp": 1739088780 },
      { "type": "completed", "timestamp": 1739088800 },
      { "type": "download",  "timestamp": 1739095200 },
      { "type": "download",  "timestamp": 1739102400 }
    ]
  }
  ```

**Note:** Events returned here are sanitised — they include type and timestamp but NOT IP addresses or user-agents. Those details exist in the per-event files server-side but are stripped from this public response.

- **Errors:**
  - `404 Not Found` — Transfer ID not found
  - `410 Gone` — Transfer expired and payload deleted

**Server-side behaviour:**
1. Read meta.json from storage
2. List event files from `transfers/{id}/events/`, read each, build timeline
3. Count events where type=download for download_count
4. Strip sensitive fields (ip, user_agent) from event data
5. Log the request
6. Return sanitised response

### GET /transfers/download/{transfer_id}

**Purpose:** Get download information. For S3 backend, returns a pre-signed GET URL. For non-S3 backends, returns a reference to the file endpoint.

- **Auth:** None (public — content is encrypted)
- **Response (200):** `Schema__App__Send__Transfer__Download`
  ```json
  {
    "transfer_id": "a3f8b2c1d4e5",
    "file_url": "/transfers/file/a3f8b2c1d4e5",
    "file_size_bytes": 4821033,
    "transparency": {
      "your_ip": "198.51.100.7",
      "download_timestamp": 1739095200,
      "user_agent": "Mozilla/5.0...",
      "stored_fields": ["ip", "timestamp", "user_agent"],
      "not_stored": ["file_content", "decryption_key", "decryption_result"]
    }
  }
  ```
- **Errors:**
  - `404 Not Found` — Transfer ID not found
  - `410 Gone` — Transfer expired or payload deleted
  - `425 Too Early` — Transfer status is still pending (upload not complete)

**Server-side behaviour:**
1. Read meta.json, verify status=completed and not expired
2. Create download event: `events/{n}__download.json` (with ip, user_agent, timestamp)
3. Generate file URL (pre-signed S3 URL for prod, or /transfers/file/{id} for non-S3)
4. Log the request
5. Return response with transparency data

### GET /transfers/file/{transfer_id}

**Purpose:** Serve encrypted file bytes directly from the endpoint. Used for non-S3 backends (in-memory, local disk) where pre-signed URLs are not available.

- **Auth:** None (public — content is encrypted)
- **Response:** Raw bytes (`application/octet-stream`)
- **Errors:**
  - `404 Not Found` — Transfer ID not found or payload missing
  - `410 Gone` — Transfer expired

**Server-side behaviour:**
1. Read meta.json, verify status=completed and not expired
2. Read payload.enc bytes from storage via Memory-FS
3. Return raw bytes with Content-Type: application/octet-stream
4. Log the request

**Note:** In production with S3 backend, clients use the pre-signed URL from `/transfers/download/{id}` and never hit this endpoint. This endpoint exists for test and dev environments.

### GET /health

**Purpose:** Health check. Always public.

- **Auth:** None
- **Response (200):**
  ```json
  {
    "status": "healthy",
    "service": "sgraph-send-public",
    "version": "0.1.0",
    "timestamp": 1739088720
  }
  ```

---

## 5. API Endpoints — Admin Lambda

All routes on the admin Lambda require OSBot-Fast-API header/cookie auth. This is configured at the service level — every request must include the correct auth header or cookie.

### POST /tokens/create

**Purpose:** Create a new sender access token.

- **Auth:** OSBot-Fast-API header auth (applied at Lambda level)
- **Request:** `Schema__App__Send__Token__Create`
  ```json
  {
    "label": "Friend - Alice",
    "expires_in_days": 30
  }
  ```
- **Response (201):** `Schema__App__Send__Token`
  ```json
  {
    "token_id": "tok_a1b2c3d4e5f6",
    "token_value": "tok_a1b2c3d4e5f6",
    "label": "Friend - Alice",
    "status": "active",
    "created_at": 1739088720,
    "expires_at": 1741680720,
    "usage_count": 0,
    "last_used_at": 0
  }
  ```

**Note:** `token_value` is the full token string the admin shares with the user. For MVP, `token_id == token_value`. In a future phase, the stored token_id could be a hash.

**Server-side behaviour:**
1. Generate token_id via `Token_Id.new()` (tok_ prefix + Obj_Id)
2. Save `tokens/{token_id}.json` in storage
3. Log admin action to `admin/logs/`
4. Return full token object

### GET /tokens/list

**Purpose:** List all tokens with usage statistics.

- **Auth:** OSBot-Fast-API header auth
- **Response (200):** List of `Schema__App__Send__Token`
  ```json
  {
    "tokens": [
      {
        "token_id": "tok_a1b2c3d4e5f6",
        "label": "Friend - Alice",
        "status": "active",
        "created_at": 1739088720,
        "expires_at": 1741680720,
        "usage_count": 7,
        "last_used_at": 1739095200
      }
    ],
    "total": 1
  }
  ```

**Server-side behaviour:**
1. List all files in `tokens/` folder via Memory-FS
2. Read each token file, build list
3. Return list sorted by created_at descending

### POST /tokens/revoke/{token_id}

**Purpose:** Revoke a token. Uses POST (not DELETE) because this is a state-change action, not a resource deletion. The token file is preserved with status=revoked.

- **Auth:** OSBot-Fast-API header auth
- **Response (200):** `Schema__App__Send__Token` (with status=revoked)
  ```json
  {
    "token_id": "tok_a1b2c3d4e5f6",
    "label": "Friend - Alice",
    "status": "revoked",
    "created_at": 1739088720,
    "expires_at": 1741680720,
    "revoked_at": 1739102400,
    "usage_count": 7,
    "last_used_at": 1739095200
  }
  ```
- **Errors:**
  - `404 Not Found` — Token not found
  - `409 Conflict` — Token already revoked

**Server-side behaviour:**
1. Read `tokens/{token_id}.json`
2. Verify status is not already revoked
3. Update: status=revoked, revoked_at=Timestamp_Now
4. Save updated token file
5. Log admin action to `admin/logs/`

### GET /stats/overview

**Purpose:** Aggregate usage analytics for the admin dashboard.

- **Auth:** OSBot-Fast-API header auth
- **Response (200):** `Schema__App__Send__Stats`
  ```json
  {
    "active_tokens": 5,
    "revoked_tokens": 1,
    "total_transfers": 42,
    "transfers_by_status": {
      "pending": 1,
      "completed": 38,
      "expired": 3
    },
    "total_bytes_uploaded": 284000000,
    "generated_at": 1739102400
  }
  ```

**Server-side behaviour:**
1. List all token files, count by status
2. List all transfer folders, read each meta.json
3. Aggregate: count by status, sum file_size_bytes
4. Return computed stats with Timestamp_Now

---

## 6. Storage Layer (Memory-FS)

### 6.1 Architecture

The storage layer is an abstraction that decouples application logic from the storage backend. All file operations go through `Storage__App__Send`, which wraps Memory-FS.

```
┌─────────────────────────────────┐
│       Application Code          │
│  (Services, Routes)             │
└──────────────┬──────────────────┘
               │
               ▼
┌─────────────────────────────────┐
│     Storage__App__Send          │
│                                 │
│  file__save(path, data)         │
│  file__str(path) -> str         │
│  file__bytes(path) -> bytes     │
│  file__exists(path) -> bool     │
│  file__delete(path) -> bool     │
│  files__paths(folder) -> list   │
│  folder__create(path)           │
│  folder__exists(path) -> bool   │
└──────────────┬──────────────────┘
               │
               ▼
┌─────────────────────────────────┐
│  Storage__App__Send__Factory    │
│                                 │
│  .create_memory()  -> in-memory │
│  .create_disk(root)-> local FS  │
│  .create_s3(bucket)-> S3        │
└──────────────┬──────────────────┘
               │
       ┌───────┼───────┐
       ▼       ▼       ▼
   Memory    Disk    S3 (osbot-aws)
```

### 6.2 Storage__App__Send

App-specific wrapper that provides higher-level operations:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Storage__App__Send(Type_Safe):
    memory_fs : object = None     # Memory-FS instance (injected by factory)

    def transfer__save_meta(self, transfer_id, meta_data):
        path = f'transfers/{transfer_id}/meta.json'
        self.file__save(path, meta_data.json())

    def transfer__load_meta(self, transfer_id):
        path = f'transfers/{transfer_id}/meta.json'
        return self.file__str(path)

    def transfer__save_payload(self, transfer_id, payload_bytes):
        path = f'transfers/{transfer_id}/payload.enc'
        self.file__save(path, payload_bytes)

    def transfer__load_payload(self, transfer_id):
        path = f'transfers/{transfer_id}/payload.enc'
        return self.file__bytes(path)

    def event__save(self, transfer_id, sequence, event_type, event_data):
        path = f'transfers/{transfer_id}/events/{sequence:03d}__{event_type}.json'
        self.file__save(path, event_data.json())

    def events__list(self, transfer_id):
        folder = f'transfers/{transfer_id}/events/'
        return self.files__paths(folder)

    def request__log(self, transfer_id, timestamp, request_data):
        path = f'transfers/{transfer_id}/requests/{timestamp}.json'
        self.file__save(path, request_data.json())

    # ... delegation to Memory-FS for generic operations
    def file__save(self, path, data):   ...
    def file__str(self, path):          ...
    def file__bytes(self, path):        ...
    def file__exists(self, path):       ...
    def file__delete(self, path):       ...
    def files__paths(self, folder):     ...
```

### 6.3 Backend Selection

| Environment | Backend | Setup Time | Notes |
|-------------|---------|------------|-------|
| Unit tests | `Storage_FS__Memory` (in-memory) | ~100ms | Zero external dependencies, instant teardown |
| Dev (local) | `Storage_FS__Local_Disk` or S3 via LocalStack | ~500ms | Persists across restarts |
| Prod | S3 via `osbot-aws` S3 class | ~200ms | Single bucket, folder-based separation |

### 6.4 Storage Layout (All Backends)

```
transfers/
└── {transfer_id}/
    ├── meta.json                      # Transfer metadata
    ├── payload.enc                    # Encrypted file blob
    ├── events/
    │   ├── 001__created.json          # Transfer created
    │   ├── 002__uploaded.json         # Payload uploaded
    │   ├── 003__completed.json        # Transfer marked complete
    │   ├── 004__download.json         # First download
    │   └── 005__download.json         # Second download
    └── requests/
        ├── 1739088720__create.json    # POST /transfers/create
        ├── 1739088780__upload.json    # POST /transfers/upload/{id}
        ├── 1739088800__complete.json  # POST /transfers/complete/{id}
        └── 1739095200__download.json  # GET /transfers/download/{id}

tokens/
├── tok_a1b2c3d4e5f6.json
└── tok_x7y8z9a0b1c2.json

admin/
└── logs/
    ├── 1739088720__token_created.json
    └── 1739102400__token_revoked.json
```

### 6.5 Why Memory-FS (Not Direct S3)

1. **Testability** — In-memory backend means tests run in ~100ms with zero infrastructure. No mocks, no patches, no LocalStack for unit tests.
2. **Portability** — Same code runs locally, in CI, and on Lambda. Swap the backend, not the logic.
3. **Consistency** — All backends expose the same interface. A bug found in-memory is a bug in production.
4. **Speed** — Development iteration is instant. No waiting for S3 round-trips during test-driven development.

---

## 7. Type_Safe Schema Examples

All schemas use `Type_Safe` from `osbot-utils`. Never Pydantic.

### 7.1 Transfer Schema

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Schema__App__Send__Transfer(Type_Safe):
    transfer_id     : str = ''       # Transfer_Id value
    status          : str = 'pending'
    file_size_bytes : int = 0
    content_type_hint: str = ''
    created_at      : int = 0        # Timestamp_Now
    completed_at    : int = 0        # Timestamp_Now (0 = not completed)
    expires_at      : int = 0        # Timestamp_Now
    token_id        : str = ''
```

### 7.2 Transfer Create Request

```python
class Schema__App__Send__Transfer__Create(Type_Safe):
    file_size_bytes  : int = 0
    content_type_hint: str = ''
```

### 7.3 Transfer Complete Response

```python
class Schema__App__Send__Transfer__Complete(Type_Safe):
    transfer_id    : str                              = ''
    status         : str                              = 'completed'
    download_link  : str                              = ''
    transparency   : Schema__App__Send__Transparency  = None
```

### 7.4 Event Schema

```python
class Schema__App__Send__Event(Type_Safe):
    event_type : str = ''        # created, uploaded, completed, download, expired
    timestamp  : int = 0         # Timestamp_Now
    ip         : str = ''        # Client IP (stripped from public responses)
    user_agent : str = ''        # Client UA (stripped from public responses)
```

### 7.5 Transparency Schema

```python
class Schema__App__Send__Transparency(Type_Safe):
    your_ip        : str  = ''
    timestamp      : int  = 0
    file_size_bytes: int  = 0
    stored_fields  : list = None     # e.g. ["ip", "timestamp", "file_size"]
    not_stored     : list = None     # e.g. ["file_name", "decryption_key"]
```

### 7.6 Token Schema

```python
class Schema__App__Send__Token(Type_Safe):
    token_id    : str = ''
    token_value : str = ''         # Full token (for creation response only)
    label       : str = ''
    status      : str = 'active'   # active, revoked, expired
    created_at  : int = 0
    expires_at  : int = 0
    revoked_at  : int = 0
    usage_count : int = 0
    last_used_at: int = 0
```

### 7.7 Stats Schema

```python
class Schema__App__Send__Stats(Type_Safe):
    active_tokens        : int  = 0
    revoked_tokens       : int  = 0
    total_transfers      : int  = 0
    transfers_by_status  : dict = None   # {"pending": 1, "completed": 38, ...}
    total_bytes_uploaded : int  = 0
    generated_at         : int  = 0
```

### 7.8 Why Type_Safe (Not Pydantic)

- Type_Safe is the standard across the osbot ecosystem. Using Pydantic would introduce a second type system.
- Type_Safe provides `.json()` serialization, attribute validation, and default values.
- Consistent with OSBot-Fast-API, osbot-utils, osbot-aws patterns.
- No dependency on Pydantic (smaller Lambda package).

---

## 8. Authentication

### 8.1 Public Lambda — Sender Token Validation

Token validation is a service-layer operation, not middleware. Routes that need sender auth call the token service explicitly.

```
Request flow:

  Client                     Route Handler              Service__App__Send__Tokens
    │                              │                              │
    │  Authorization: Bearer tok_x │                              │
    │ ────────────────────────────►│                              │
    │                              │  validate(token_value)       │
    │                              │ ────────────────────────────►│
    │                              │                              │  Read tokens/{id}.json
    │                              │                              │  Check: exists?
    │                              │                              │  Check: status == active?
    │                              │                              │  Check: not expired?
    │                              │                              │  Update: usage_count += 1
    │                              │                              │  Update: last_used_at
    │                              │  ◄──── Token data (or 401)  │
    │                              │                              │
    │  ◄──── Response              │                              │
```

**Validation steps:**
1. Extract `Authorization: Bearer tok_xxx` header
2. Read token file from storage: `tokens/{token_id}.json`
3. Check: file exists (else 401)
4. Check: `status == 'active'` (else 401 — revoked or expired)
5. Check: `expires_at > Timestamp_Now` (else 401 — expired)
6. Update: increment `usage_count`, set `last_used_at = Timestamp_Now`
7. Save updated token file
8. Return token data to the route handler

**Routes requiring sender auth:**
- `POST /transfers/create` — any valid token
- `POST /transfers/upload/{transfer_id}` — must match the token used to create
- `POST /transfers/complete/{transfer_id}` — must match the token used to create

### 8.2 Admin Lambda — OSBot-Fast-API Built-in Auth

The admin Lambda uses OSBot-Fast-API's built-in header/cookie authentication. This is configured at the service level and applies to ALL routes automatically.

```python
class Service__App__Send__Admin(Fast_API):

    def setup(self):
        self.auth_key_name  = 'x-admin-key'        # Header name
        self.auth_key_value = os.environ.get('SGRAPH_SEND_ADMIN_KEY')
```

**How it works:**
- OSBot-Fast-API checks every incoming request for a header (or cookie) matching `key-name: key-value`
- On match: request proceeds to the route handler
- On mismatch: returns 401 immediately (never reaches route code)
- Admin key is loaded from the `SGRAPH_SEND_ADMIN_KEY` environment variable

### 8.3 Public Endpoints (No Auth)

These routes require no authentication:
- `GET /transfers/status/{transfer_id}` — Public status page
- `GET /transfers/download/{transfer_id}` — Public (content is encrypted)
- `GET /transfers/file/{transfer_id}` — Public (content is encrypted)
- `GET /health` — Health check

Security rationale: The transferred file content is encrypted with AES-256-GCM on the client side. The server never has the decryption key. Making download public means the recipient does not need an account or token — they just need the URL and the decryption key (shared out-of-band by the sender).

---

## 9. Error Handling

### 9.1 Response Pattern

Each route returns a Type_Safe response schema. Errors are raised via FastAPI's `HTTPException`, which OSBot-Fast-API translates into JSON responses.

```python
from fastapi import HTTPException

# In a route handler:
if not storage.file__exists(f'transfers/{transfer_id}/meta.json'):
    raise HTTPException(status_code=404, detail='Transfer not found')
```

### 9.2 Error Codes

| HTTP Status | When | Detail Message |
|-------------|------|----------------|
| 400 | Missing or invalid request fields | `Invalid request: {field} is required` |
| 401 | Token missing, invalid, revoked, or expired | `Unauthorized` |
| 404 | Transfer or token not found | `Transfer not found` / `Token not found` |
| 409 | Transfer already completed; token already revoked | `Transfer already completed` |
| 410 | Transfer expired and payload deleted | `Transfer expired` |
| 413 | file_size_bytes exceeds 100MB limit | `File too large` |
| 425 | Transfer status is still pending | `Transfer not ready` |
| 429 | Rate limit exceeded (future) | `Too many requests` |

### 9.3 Security Rules

- **No stack traces** in responses — ever. Unhandled exceptions return a generic 500.
- **No internal details** — error messages are user-facing. No file paths, no backend names, no storage keys.
- **All errors logged** — when a transfer_id is available, errors are logged to `transfers/{id}/requests/` with full context. Otherwise, logged to `admin/logs/`.

### 9.4 Global Exception Handler

```python
@app.exception_handler(Exception)
async def global_exception_handler(request, exc):
    # Log full exception with traceback to storage/CloudWatch
    # Return sanitised response to client
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )
```

---

## 10. Testing Strategy

### 10.1 Principles

- **No mocks, no patches** — Every test uses the real service logic, real route handlers, and real storage operations. The only substitution is the storage backend (in-memory instead of S3).
- **Full stack in ~100ms** — `Storage__App__Send__Factory.create_memory()` gives an in-memory backend. FastAPI's `TestClient` runs the full ASGI app synchronously. No network calls.
- **Test the contract** — Tests verify HTTP status codes, response shapes, and business rules through the API. They do not test internal implementation details.

### 10.2 Test Setup Pattern

```python
from fastapi.testclient               import TestClient
from sgraph_ai_app_send.fast_api       import Service__App__Send__Public
from sgraph_ai_app_send.storage        import Storage__App__Send__Factory

class Test__Routes__Transfers:

    @classmethod
    def setup_class(cls):
        storage = Storage__App__Send__Factory.create_memory()
        service = Service__App__Send__Public(storage=storage)
        cls.client = TestClient(service.app())

        # Create a valid token in storage for testing
        cls.test_token = 'tok_test12345678'
        storage.file__save(
            f'tokens/{cls.test_token}.json',
            '{"token_id":"tok_test12345678","status":"active",'
            '"expires_at":9999999999,"usage_count":0}'
        )

    def test_create_transfer(self):
        response = self.client.post('/transfers/create',
            headers={'Authorization': f'Bearer {self.test_token}'},
            json={'file_size_bytes': 1024, 'content_type_hint': 'text/plain'}
        )
        assert response.status_code == 201
        data = response.json()
        assert data['status']          == 'pending'
        assert data['file_size_bytes'] == 1024
        assert data['transfer_id']     != ''

    def test_create_transfer_no_token(self):
        response = self.client.post('/transfers/create',
            json={'file_size_bytes': 1024}
        )
        assert response.status_code == 401
```

### 10.3 Test Categories

| Category | What | Backend | Speed |
|----------|------|---------|-------|
| Unit tests | Route handlers + services | In-memory | ~100ms per test |
| Integration tests | Full transfer flow (create -> upload -> complete -> download) | In-memory | ~200ms per flow |
| S3 integration tests | S3-specific behavior (pre-signed URLs, large files) | LocalStack | ~2s per test |
| End-to-end tests | Full Lambda invocation | LocalStack + SAM local | ~5s per test |

### 10.4 What We Test

- **Happy paths:** Full transfer lifecycle, token CRUD, stats computation
- **Auth failures:** Missing token, invalid token, expired token, revoked token, wrong token for transfer
- **State violations:** Complete before upload, download before complete, double complete
- **Edge cases:** Zero-byte file, maximum size file, expired transfer, deleted payload
- **Concurrency:** Multiple downloads of same transfer (event ordering)

---

## 11. Observability — File-Based

### 11.1 Philosophy

Every HTTP request and every state change is persisted as a file in the transfer's folder. This data IS the observability store. It is queryable (list files, read JSON), exportable (download the folder), and graphable (feed into any analytics tool).

### 11.2 Request Logging

Every HTTP request to a transfer endpoint is logged as a file:

```
transfers/{id}/requests/{timestamp}__{action}.json
```

Example: `transfers/a3f8b2c1d4e5/requests/1739088720__create.json`

```json
{
  "timestamp"   : 1739088720,
  "action"      : "create",
  "method"      : "POST",
  "path"        : "/transfers/create",
  "ip"          : "203.0.113.42",
  "user_agent"  : "Mozilla/5.0...",
  "status_code" : 201,
  "duration_ms" : 45,
  "token_id"    : "tok_a1b2c3d4e5f6"
}
```

### 11.3 Event Logging

Every state change is logged as an event file:

```
transfers/{id}/events/{sequence}__{type}.json
```

Example: `transfers/a3f8b2c1d4e5/events/001__created.json`

```json
{
  "event_type" : "created",
  "timestamp"  : 1739088720,
  "ip"         : "203.0.113.42",
  "details"    : {
    "file_size_bytes"  : 4821033,
    "content_type_hint": "application/pdf",
    "token_id"         : "tok_a1b2c3d4e5f6"
  }
}
```

### 11.4 Admin Action Logging

Admin actions (token creation, revocation) are logged separately:

```
admin/logs/{timestamp}__{action}.json
```

Example: `admin/logs/1739088720__token_created.json`

```json
{
  "timestamp" : 1739088720,
  "action"    : "token_created",
  "token_id"  : "tok_a1b2c3d4e5f6",
  "label"     : "Friend - Alice"
}
```

### 11.5 CloudWatch (Standard AWS Monitoring)

In addition to file-based logging, the Lambda functions emit standard output that CloudWatch captures:

- Lambda invocation logs (start, end, duration, memory used)
- Application-level structured logs (JSON to stdout)
- Error logs with context (but no stack traces in responses)

CloudWatch provides:
- Real-time log streaming
- Metric filters (error rate, latency percentiles)
- Alarms (error rate > 5%, p99 > 5s)

The file-based logs are the source of truth. CloudWatch is the real-time alerting layer.

### 11.6 Querying the Observability Data

Because everything is a file, observability queries are storage queries:

```python
# How many downloads for transfer X?
events = storage.events__list('a3f8b2c1d4e5')
downloads = [e for e in events if 'download' in e]

# All requests in the last hour?
requests = storage.files__paths(f'transfers/{id}/requests/')
recent = [r for r in requests if int(r.split('/')[3].split('__')[0]) > one_hour_ago]

# Full audit trail for a transfer?
all_files = storage.files__paths(f'transfers/{id}/')
```

---

## 12. Upload/Download Flow (Revised)

### 12.1 Upload Sequence (Non-S3 Backend)

```
Client                          Public Lambda                    Memory-FS
  │                                  │                              │
  │  POST /transfers/create          │                              │
  │  Auth: Bearer tok_x              │                              │
  │  { file_size, content_type }     │                              │
  │ ────────────────────────────────►│                              │
  │                                  │  validate token              │
  │                                  │  Transfer_Id.new()           │
  │                                  │  save meta.json ────────────►│
  │                                  │  save 001__created ─────────►│
  │                                  │  log request ───────────────►│
  │  ◄──── { transfer_id, status }   │                              │
  │                                  │                              │
  │  [Client encrypts file with AES-256-GCM in browser]            │
  │                                  │                              │
  │  POST /transfers/upload/{id}     │                              │
  │  Auth: Bearer tok_x              │                              │
  │  Body: encrypted bytes           │                              │
  │ ────────────────────────────────►│                              │
  │                                  │  validate token match        │
  │                                  │  save payload.enc ──────────►│
  │                                  │  save 002__uploaded ─────────►│
  │                                  │  log request ───────────────►│
  │  ◄──── { bytes_received }        │                              │
  │                                  │                              │
  │  POST /transfers/complete/{id}   │                              │
  │  Auth: Bearer tok_x              │                              │
  │ ────────────────────────────────►│                              │
  │                                  │  validate token match        │
  │                                  │  verify payload exists       │
  │                                  │  update meta (completed) ───►│
  │                                  │  save 003__completed ────────►│
  │                                  │  log request ───────────────►│
  │  ◄──── { download_link,         │                              │
  │          transparency }          │                              │
```

### 12.2 Download Sequence (Non-S3 Backend)

```
Client                          Public Lambda                    Memory-FS
  │                                  │                              │
  │  GET /transfers/download/{id}    │                              │
  │ ────────────────────────────────►│                              │
  │                                  │  read meta.json ◄───────────│
  │                                  │  verify completed + valid    │
  │                                  │  save 004__download ────────►│
  │                                  │  log request ───────────────►│
  │  ◄──── { file_url:              │                              │
  │     /transfers/file/{id},        │                              │
  │     transparency }               │                              │
  │                                  │                              │
  │  GET /transfers/file/{id}        │                              │
  │ ────────────────────────────────►│                              │
  │                                  │  read payload.enc ◄─────────│
  │  ◄──── raw encrypted bytes       │                              │
  │                                  │                              │
  │  [Client decrypts with key from URL fragment]                   │
  │  [Client triggers browser Save As with decrypted content]       │
```

### 12.3 Upload Sequence (S3 Backend — Production)

**Open Question Q3:** For the S3 backend, how should file upload work? Options:

**Option A — Pre-signed URL (recommended):**
- `POST /transfers/create` returns a pre-signed PUT URL
- Client uploads directly to S3, bypassing Lambda entirely
- Avoids Lambda's 6MB payload limit
- `POST /transfers/complete/{id}` verifies the S3 object exists

**Option B — Lambda proxy:**
- Client uploads through `/transfers/upload/{id}` endpoint
- Lambda writes to S3 via osbot-aws
- Limited to ~6MB (Lambda payload limit)
- Simpler flow but constrains file size

This decision is deferred to the Conductor. The architecture supports both — the upload endpoint exists for non-S3 backends regardless.

---

## 13. Configuration (Environment Variables)

| Variable | Example | Purpose |
|----------|---------|---------|
| `SGRAPH_SEND_TIER` | `dev` | Environment tier (dev / qa / prod) |
| `SGRAPH_SEND_STORAGE_BACKEND` | `s3` | Storage backend (memory / disk / s3) |
| `SGRAPH_SEND_S3_BUCKET` | `sgraph-send-dev-data` | S3 bucket (when backend=s3) |
| `SGRAPH_SEND_ADMIN_KEY` | `adm_xxx` | Admin auth key |
| `SGRAPH_SEND_REGION` | `eu-west-1` | AWS region |
| `SGRAPH_SEND_FRONTEND_URL` | `https://dev-send.sgraph.ai` | Frontend origin (CORS + download links) |
| `SGRAPH_SEND_TRANSFER_EXPIRY_DAYS` | `7` | Default transfer expiry |
| `SGRAPH_SEND_MAX_FILE_SIZE` | `104857600` | Max file size in bytes (100MB) |

**Note:** Single S3 bucket for all data (transfers, tokens, admin logs). Folder structure provides separation. Two-bucket approach from v0.1.1 is simplified to one bucket since Memory-FS abstracts the layout.

---

## 14. Domain Objects

### 14.1 Transfer_Id

Uses the Obj_Id pattern from osbot-utils:

```python
from osbot_utils.helpers.Obj_Id import Obj_Id

class Transfer_Id(Obj_Id):

    @classmethod
    def new(cls):
        return cls()    # Obj_Id generates a unique ID on construction
```

### 14.2 Token_Id

Prefixed ID for tokens:

```python
class Token_Id(Type_Safe):
    prefix : str = 'tok_'
    value  : str = ''

    @classmethod
    def new(cls):
        obj_id = Obj_Id()
        return cls(value=f'tok_{obj_id}')
```

### 14.3 Timestamp Pattern

All timestamps are integers (Unix epoch seconds):

```python
from osbot_utils.helpers.Timestamp_Now import Timestamp_Now

created_at = Timestamp_Now()    # e.g., 1739088720
```

---

## 15. Open Questions for Conductor

| # | Question | Context |
|---|----------|---------|
| Q1 | Should the admin Lambda Function URL be behind CloudFront, or accessed directly? | Direct access is simpler but loses CloudFront's DDoS protection |
| Q2 | What OSBot-Fast-API auth configuration pattern should we follow? | Need to confirm the exact header-name/header-value setup for admin auth |
| Q3 | For S3 backend: pre-signed URL upload or Lambda proxy upload? | Pre-signed avoids 6MB limit but adds client complexity. See section 12.3 |
| Q4 | Should Storage__App__Send use a single bucket or two buckets in prod? | v0.1.1 had two (data + config). This plan simplifies to one. Confirm preference |
| Q5 | Event file naming: zero-padded sequence (001__) or timestamp-based? | Sequence preserves order but requires reading existing events to get next number |
