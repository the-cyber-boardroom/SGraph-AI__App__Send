# v0.2.24 — Architect Response to Daily Brief (13 Feb 2026)

**Version:** v0.2.24
**Date:** 2026-02-13
**Role:** Architect
**Context:** Response to `team/humans/dinis_cruz/briefs/02/13/v0.2.16__daily-brief__sgraph-send-13-feb-2026.md`
**User amendments:** Rate limiting deferred (needs visualisation first); CORS already handled by osbot-fast-api.

---

## 1. Hash-Fragment for One-Click File Access — APPROVED WITH CONDITIONS

### The Proposal

Combine transfer ID and decryption key into a single URL using the hash fragment:

```
https://send.sgraph.ai/send/v0/v0.1/v0.1.0/download.html#<transferId>/<base64urlKey>
```

### Technical Confirmation: Hash Fragment Never Reaches the Server

**Confirmed.** The URL hash fragment (everything after `#`) is defined by RFC 3986 §3.5 as client-only. Specifically:

1. **HTTP requests** — browsers strip the fragment before sending the request. The server receives `/send/v0/v0.1/v0.1.0/download.html` only. This is enforced by every browser engine (Chromium, Firefox, WebKit).
2. **HTTPS/TLS** — the fragment is not included in the TLS-encrypted request path.
3. **Server logs** — fragments never appear in CloudFront, Lambda, or any HTTP access logs because they were never transmitted.
4. **Referrer header** — per the Fetch spec, the fragment is stripped from `Referer` headers. However, see AppSec review for edge cases.

### Recommended URL Format

```
https://send.sgraph.ai/send/v0/v0.1/v0.1.0/download.html#{transferId}/{base64urlKey}
```

**Rationale:**
- Single `#` delimiter — standard, parseable
- `/` separator between ID and key — clear, human-readable
- Transfer ID is 12 chars, key is ~43 chars base64url — no ambiguity
- Backwards compatible: if no hash present, download page falls back to `?id=` query param + manual key input

### Parsing Logic

```javascript
const hash = window.location.hash.substring(1); // strip '#'
const slashIndex = hash.indexOf('/');
if (slashIndex > 0) {
    const transferId = hash.substring(0, slashIndex);
    const key = hash.substring(slashIndex + 1);
    // auto-populate and optionally auto-decrypt
}
```

### Backwards Compatibility

Keep supporting the current `?id=xxx` + manual key flow as a fallback. The download page should check:
1. Hash fragment (new path) — auto-fill both fields
2. Query param `?id=xxx` (legacy path) — fill transfer ID, require manual key
3. Neither — show blank form

### Security Conditions (for AppSec to confirm)

- **Browser extensions** can read `window.location.hash` — accepted risk for beta
- **Browser history** stores the full URL including hash — user should be warned
- **Shared/public computers** — the link in history contains the key. Consider: auto-clear hash after decryption using `history.replaceState`
- **Copy/paste** — when user copies URL from browser bar, hash is included (this is the desired behaviour)

### Verdict: APPROVE

The hash-fragment approach is sound. It maintains zero-knowledge by keeping the key client-side only. The trust model change is minimal — we're not weakening server-side guarantees, we're making the client-side sharing flow easier.

**Action for Dev:** implement once AppSec confirms the edge cases above.

---

## 2. Token Storage Schema

### Design: Index by Token

```python
class Schema__Token(Type_Safe):
    token_id     : str              # The token string itself (UUID or similar)
    created_at   : str              # ISO 8601 timestamp
    created_by   : str              # Admin identifier
    status       : str              # 'active', 'used', 'revoked', 'expired'
    used_at      : str              # ISO 8601, empty until used
    used_by_ip   : str              # IP hash (SHA-256 + daily salt)
    expires_at   : str              # Optional expiry
    metadata     : dict             # Flexible: batch_id, notes, etc.
```

### Storage Layout (Memory-FS)

```
/tokens/{token_id}/token.json
```

Indexed by token — each token is its own key in the storage. This makes lookup O(1) when a user presents a token in the URL.

### Token URL Format

```
https://send.sgraph.ai/?token={token_id}
```

**Note:** The token goes in the query string (NOT the hash) because we explicitly want the backend to see it. This is the opposite of the decryption key — here, server visibility is the feature.

### Token Lifecycle Events

Each token should log events (created, link_opened, used_for_upload, revoked) similar to transfer events. This feeds the observability pipeline.

---

## 3. i18n Architecture

### Approach: JSON translation files + lightweight runtime

```
sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.0/
  i18n/
    en.json     # English (primary)
    pt.json     # Portuguese (first translation)
```

### Design Decisions

1. **JSON format** — flat or shallow-nested key-value pairs. No ICU MessageFormat yet (add when needed).
2. **Lazy loading** — load only the active language file. Default: English. Detect via `navigator.language`.
3. **Template integration** — `t('key')` function used in Web Component `render()` methods.
4. **Persist preference** — `localStorage.setItem('sgraph-lang', 'pt')`.
5. **Fallback** — if key missing in active language, fall back to English.
6. **No build step** — JSON loaded at runtime via fetch. Aligns with IFD (zero build toolchain).

### Key Structure

```json
{
  "app.title": "SGraph Send",
  "upload.heading": "Send a file securely",
  "upload.dropzone": "Drop your file here or click to browse",
  "upload.text_tab": "Paste text",
  "upload.file_tab": "Upload file",
  "upload.encrypting": "Encrypting...",
  "upload.uploading": "Uploading...",
  "upload.success": "Your file is ready to share",
  "download.heading": "Download your file",
  "download.key_input": "Decryption key",
  "download.decrypt": "Download & Decrypt",
  "transparency.heading": "What we stored",
  "gate.heading": "Enter your access token",
  "gate.early_access": "Request early access"
}
```

### Architectural Constraint

**All new user-facing content (landing page copy, admin UI, email templates) MUST go through the i18n layer from day one.** No hardcoded strings in HTML templates. The Journalist and Designer should author content as i18n keys, not raw HTML.

---

## 4. Rate Limiting — DEFERRED

Per user directive: rate limiting is deferred until we have proper visualisation of traffic patterns. This is the right call — rate limiting without observability means we'd be guessing at thresholds. Sequence: observability pipeline first → understand traffic patterns → then set meaningful rate limits.

## 5. CORS — ALREADY HANDLED

The `osbot-fast-api` base framework (`Serverless__Fast_API`) includes CORS middleware configuration. No additional work needed. DevOps should verify the current CORS headers are correct for `send.sgraph.ai` origin, but this is not a blocker.

---

## Summary: Architect Actions

| # | Action | Priority | Blocks |
|---|---|---|---|
| 1 | Hash-fragment URL format approved (pending AppSec) | P1 | Dev implementation |
| 2 | Token schema designed (Schema__Token, indexed by token) | P2 | Admin token UI |
| 3 | i18n architecture defined (JSON + runtime loader) | P2 | All new UI content |
| 4 | Rate limiting deferred per user directive | — | Nothing |
| 5 | CORS confirmed handled by osbot-fast-api | — | Nothing |
