# v0.2.24 --- Architect Status Report: Post-Launch Assessment

**Version:** v0.2.24
**Date:** 13 Feb 2026
**Role:** Architect
**Status:** SGraph Send is live at send.sgraph.ai

---

## 1. Current System State

SGraph Send went live with a working end-to-end encrypted file transfer. The architecture that shipped:

| Component | Status | Notes |
|---|---|---|
| Per-route access token auth | Live | `create`, `upload`, `complete` protected; `info`, `download` public |
| S3 persistent storage | Live | Memory-FS abstraction with `Storage_FS__S3` backend, auto-detected via AWS credentials |
| Access gate web component | Live | `<send-access-gate>` wraps upload UI, token checked client-side then server-side |
| LaunchList waitlist | Live | Early access form on both send and download pages |
| Root domain redirect | Live | `/` redirects to `/send/v0/v0.1/v0.1.0/index.html` |
| Google Analytics | Live | `G-GQTMWE0LHP` on send.sgraph.ai and docs.send.sgraph.ai |
| Jekyll docs site | Live | docs.send.sgraph.ai on GitHub Pages |
| Test suite | Passing | 56 tests, no mocks, in-memory stack |
| CI/CD | Operational | Push to `dev` runs tests, increments tag, deploys to Lambda |

This is a solid MVP launch. The zero-knowledge boundary holds: the server stores only encrypted ciphertext, IP hashes, and file size metadata. No file names, no decryption keys, no plaintext ever reach the backend.

---

## 2. Architecture Decisions Needed for Next Sprint

### 2.1 Sharing UX (WS-13) --- DECISION NEEDED NOW

The current workflow requires users to copy transfer ID and decryption key separately. For the "friendlies" release, this is the single biggest usability gap.

**Decision required:** URL hash fragment approach for single-link sharing.

The design is straightforward:
- Download link format: `https://send.sgraph.ai/send/v0/v0.1/v0.1.0/download.html#id={transfer_id}&key={base64_key}`
- The hash fragment (`#...`) is never sent to the server per HTTP specification (RFC 3986 Section 3.5)
- JavaScript on the download page reads `window.location.hash` to extract both values

**Architecture considerations:**
1. The hash fragment is safe from server-side logging, but **is visible in browser history, referrer headers (if linking away from the page), and extensions**. AppSec must confirm the threat model before shipping.
2. The download page currently lives at a versioned static path. When we add SPA routing (WS-14), the URL structure will change. **We should design the share URL to be version-independent** --- e.g., `https://send.sgraph.ai/d/{transfer_id}#key={base64_key}` --- and let the SPA router resolve it.
3. The email template mode is a pure frontend concern (pre-filled `mailto:` link). No architecture decision needed.

**Recommendation:** Ship Mode 2 (URL with hash) first. Design the URL structure now with SPA routing in mind so it does not need to change later. Use `/d/{transfer_id}#key={base64_key}` as the canonical share format, with backend route mapping to serve the download page.

### 2.2 SPA Routing and URL Navigation (WS-14) --- DESIGN NOW, SHIP AFTER WS-13

Converting to SPA routing is a foundational change. Currently the app has two static HTML pages (`index.html`, `download.html`) served by Starlette `StaticFiles`. SPA routing requires:

1. **Backend catch-all route:** All non-API, non-static-asset requests return the SPA shell (`index.html`). Static assets (JS, CSS, images) continue serving directly from the static mount.
2. **Frontend router:** A lightweight vanilla JS router (no framework) that reads `window.location.pathname` and loads the appropriate web component.
3. **Route map:** `/send` (upload), `/d/{id}` (download), `/about`, `/help` --- all resolve to the same HTML shell, with JS rendering the correct view.

**Architecture consideration:** This changes the static asset serving model in `Fast_API__SGraph__App__Send__User.setup_static_routes()`. The current `StaticFiles` mount must stay for JS/CSS/images, but a new catch-all route must be added for everything else. Order matters: API routes first, static files second, SPA catch-all last.

**Dependency:** WS-13 (Sharing UX) depends on having stable URLs. Design both together. Implement WS-13 link generation against the target SPA URL structure even if the SPA shell is not yet built.

### 2.3 i18n and Accessibility Themes (WS-14 continued) --- DESIGN NOW, SHIP LATER

Multi-language and accessibility themes are low-risk to add to the web component architecture. The IFD methodology already gives us component-level isolation. The architecture decision is about content structure:

- **i18n:** Each web component loads its strings from a locale JSON file (`/i18n/en.json`, `/i18n/pt.json`). A global `<lang-switcher>` component sets `document.documentElement.lang` and triggers re-render. No build step needed --- pure runtime loading.
- **Themes:** CSS custom properties are already used (`--color-text-secondary` visible in current code). Add theme classes on `<body>` (`theme-default`, `theme-high-contrast`, `theme-bw`). Each theme overrides the custom property set. A `<theme-switcher>` component toggles the class.

**Recommendation:** Define the i18n JSON schema and theme CSS variable contract now. Implementation can follow after Sharing UX ships.

---

## 3. Recommended Priority Order

Based on user impact for the "friendlies" audience and dependency chains:

| Priority | Workstream | Rationale |
|---|---|---|
| **1** | WS-13: Sharing UX (URL hash + email template) | Biggest usability gap. Friends cannot share files with current copy/paste workflow. Blocks real usage. |
| **2** | WS-14 partial: SPA routing + URL navigation | Required for clean share URLs (`/d/{id}`). Blocks professional feel. Design alongside WS-13. |
| **3** | WS-10: Text mode | Low-effort, high-value. Same encryption pipeline, different input. Enables "paste a secret" use case for interviews and quick sharing. |
| **4** | WS-14 remainder: i18n + accessibility themes | Foundation work. Low risk, but lower urgency than user-facing sharing. Design now, ship in parallel. |
| **5** | WS-9: Public key encryption (design only) | Important differentiator but higher complexity. Design the key generation and exchange workflow. Implementation is Phase 2. |
| **6** | WS-6: Playwright-as-a-Service | Valuable for confidence, but existing 56 unit tests provide adequate coverage for friendlies. Prioritise after sharing UX is stable. |
| **7** | WS-11: Self-hosted scenarios | Docker/local mode. Already partially supported (uvicorn entry point works, Memory-FS disk backend exists). Document and polish after core UX ships. |

---

## 4. Technical Risks in the Current Live System

### 4.1 CRITICAL: Transfer ID Predictability

Transfer IDs are 12 hex characters (`secrets.token_hex(6)` = 48 bits of entropy). This provides 281 trillion possible values, which is adequate against random brute-force at current scale. However, the Conductor brief (v0.2.10) and existing code TODOs flag this for upgrade to full UUID. **Risk is low at current scale but grows with adoption. Schedule this for the sprint after friendlies.**

### 4.2 HIGH: No Rate Limiting on Public Endpoints

The `info` and `download` endpoints are unauthenticated. There is no rate limiting at the application level. Lambda URL Functions have AWS-level throttling, but an attacker could enumerate transfer IDs or exhaust Lambda concurrency.

**Recommendation:** Add rate limiting before public announcement. Options:
- CloudFront + WAF (infrastructure layer, DevOps concern)
- Application-level middleware using IP hash + sliding window counter in Memory-FS

### 4.3 HIGH: Technical Debt in Transfer Service

The `Transfer__Service` has 25+ TODOs flagged by Dinis Cruz in the v0.2.10 review. Key issues:
- Raw `dict` returns instead of `Type_Safe` classes
- No `@type_safe` decorators on method signatures
- Hardcoded URL paths in service layer
- Status strings instead of `Enum__Transfer__Status`
- Events as raw dicts instead of `Schema__Transfer__Event`

This is not a production risk (the code works correctly), but it accumulates integration cost. Every new feature (text mode, public key, sharing UX) will either work around the debt or need to refactor first.

**Recommendation:** Schedule the Type_Safe refactor as a dedicated sprint task. Do it before WS-10 (text mode) since text mode adds a new input type to the service layer.

### 4.4 MEDIUM: Lambda 6MB Response Limit

Lambda URL Functions cap response bodies at 6MB. The current proxy-mode download passes the encrypted payload through the Lambda response. Files larger than 6MB will fail silently.

**Recommendation:** Document the limit in the UI ("files up to 5MB"). For the friendlies release this is acceptable. The pre-signed URL mode (documented in the system map as path 2b/3b) removes this limit entirely and should be the next storage architecture milestone.

### 4.5 MEDIUM: No CORS Configuration Visible

The current routes do not show explicit CORS configuration. If the frontend and API are served from the same Lambda URL Function origin, this is fine. But if the docs site or any third-party integration tries to call the API, requests will fail.

**Recommendation:** Confirm CORS posture. If same-origin only, document it. If cross-origin access is planned, add CORS middleware before external integrations.

### 4.6 LOW: IP Hash Without Daily Salt

The code uses `hashlib.sha256(ip_address.encode()).hexdigest()` without a daily salt. The same IP always produces the same hash, enabling cross-transfer correlation. The original spec calls for daily salt rotation.

**Recommendation:** Add daily salt before the privacy-focused audience (journalists, activists) is targeted. Not blocking for friendlies.

---

## 5. Top 3 Things to Design Next

### Design 1: Share URL Contract and SPA Route Map

**Deliverable:** A route specification document defining:
- All application URLs (`/send`, `/d/{id}`, `/about`, `/help`, `/admin`)
- The share URL format (`/d/{transfer_id}#key={base64_key}`)
- The SPA catch-all behaviour (which paths go to API, which to static, which to SPA shell)
- How versioned static paths (`/send/v0/v0.1/v0.1.0/`) coexist with clean SPA routes (`/send`)

This unblocks WS-13 and WS-14 simultaneously.

### Design 2: Text Mode Data Model Extension

**Deliverable:** A schema extension showing how text input flows through the existing transfer pipeline:
- New field in transfer metadata: `input_type` enum (`file` | `text`)
- Text content is encrypted identically to file content (same AES-256-GCM pipeline)
- Download page detects `input_type` and renders inline text display instead of file download
- No backend changes required beyond the metadata field (the service already handles opaque byte payloads)

This unblocks WS-10 and is intentionally minimal.

### Design 3: Public Key Encryption Workflow (Design Only)

**Deliverable:** A technical design for WS-9 covering:
- Client-side RSA or ECDH key pair generation via Web Crypto API
- Hybrid encryption model: generate per-transfer AES key, encrypt payload with AES, encrypt AES key with recipient's public key
- Key storage options (browser localStorage, export/import as PEM, future: keyserver)
- How the existing symmetric pipeline adapts (the AES layer stays the same; only the key exchange changes)
- GPG interoperability assessment (import public keys, export in GPG-compatible format)

This is a design document only --- no implementation in this sprint. But it de-risks WS-9 and gives the Conductor data for Phase 2 planning.

---

## 6. Summary for the Conductor

The live system is architecturally sound for the friendlies milestone. The zero-knowledge boundary holds, S3 persistence works, and the test suite provides adequate regression coverage.

**Immediate priorities:**
1. Ship Sharing UX (WS-13) --- design the share URL now, implement URL hash approach, add email template
2. Design SPA routing (WS-14) in parallel so share URLs are forward-compatible
3. Add rate limiting on public endpoints before broader announcement

**Schedule for next sprint:**
- Type_Safe refactor of Transfer_Service (blocks clean feature development)
- Text mode (WS-10) after refactor
- i18n and theme foundations (WS-14 remainder)

**Park for later:**
- Public key encryption (WS-9) --- design now, implement Phase 2
- Playwright-as-a-Service (WS-6) --- after UX stabilises
- Self-hosted (WS-11) --- polish and document after core features ship

---

*This review is the Architect's post-launch status assessment and recommendation for the next sprint.*
