# LLM Integration (CLI + MCP) — Implementation Plan

**Version:** v0.4.17
**Date:** 2026-02-20
**Role:** Architect
**Team:** Explorer

---

## Summary

This plan covers building a CLI tool (`sg_send`) and an MCP server for SG/Send, enabling any LLM with shell or MCP access to encrypt and upload files while preserving zero-knowledge encryption.

---

## Integration Paths Evaluated

| Path | Encryption | Upload | Zero-Knowledge | LLM Support | Verdict |
|------|-----------|--------|----------------|-------------|---------|
| **CLI Tool** | Yes (Python crypto) | Yes (HTTP) | Preserved | Universal (any shell LLM) | **Build first** |
| **MCP Server** | Yes (Python crypto) | Yes (HTTP) | Preserved | Claude, OpenAI, Gemini, Cursor | **Build second** |
| **Claude Skills** | Yes (sandbox) | Unlikely (network restricted) | Partial | Claude only | Defer |
| **GPT Actions** | No (no code execution) | Yes (direct HTTP) | **Broken** | ChatGPT only | **Do not build** |

**Key finding:** GPT Actions cannot perform client-side encryption and would require sending plaintext to the server, destroying SG/Send's zero-knowledge model. This path is rejected.

---

## Trust Model

### The Trust Shift

```
Browser:     User → Browser (encrypt) → Server (ciphertext only)
CLI/MCP:     User → LLM (sees plaintext) → CLI/MCP (encrypt) → Server (ciphertext)
```

When a user asks an LLM to "send this file securely," the LLM has already read the file contents. This is an accepted trust boundary — the user chose to share with the LLM. The critical property to preserve is: **the SG/Send server never sees plaintext**. Both CLI and MCP maintain this.

### Key Management

- **Per-transfer keys:** Generate a fresh AES-256-GCM key for each file (same as browser model)
- **Keys returned to user:** The download URL contains the key in the fragment (same as browser model)
- **No key persistence:** Keys exist only during the encryption operation and in the LLM's context
- **Environment variables for tokens:** API access tokens stored in env vars, not hardcoded

---

## Phase 1: CLI Tool (`sg_send`)

### Package Structure

```
sg_send/
  __init__.py
  __main__.py          # Entry point: python -m sg_send
  cli.py               # argparse command definitions
  crypto.py            # AES-256-GCM encrypt/decrypt (format-compatible with crypto.js)
  api_client.py        # HTTP client for SG/Send API
  config.py            # Server URL, token from env vars
  version.py           # Package version
setup.py / pyproject.toml
```

### Commands

```bash
# Encrypt and upload a file
sg_send upload --file report.pdf
# Output: JSON with download_url, transfer_id, key

# Download and decrypt a file
sg_send download --url "https://send.sgraph.ai/send/...#transfer_id/key" --output report.pdf
# Or: sg_send download --transfer-id abc123 --key <base64url-key> --output report.pdf

# Get transfer info
sg_send info --transfer-id abc123

# Health check
sg_send health --server https://send.sgraph.ai
```

### Crypto Module

Must produce ciphertext in the **exact same format** as `crypto.js`:

```python
# Format: [12-byte IV][ciphertext + 16-byte GCM auth tag]
# Key encoding: base64url without padding

from cryptography.hazmat.primitives.ciphers.aead import AESGCM
import os, base64

def encrypt_file(plaintext: bytes) -> tuple[bytes, str]:
    """Encrypt file data. Returns (payload, key_b64url)."""
    key_bytes  = AESGCM.generate_key(bit_length=256)
    aesgcm     = AESGCM(key_bytes)
    iv         = os.urandom(12)
    ciphertext = aesgcm.encrypt(iv, plaintext, None)  # No AAD
    payload    = iv + ciphertext                        # [IV][ciphertext+tag]
    key_b64    = base64.urlsafe_b64encode(key_bytes).rstrip(b'=').decode()
    return payload, key_b64

def decrypt_file(payload: bytes, key_b64url: str) -> bytes:
    """Decrypt file data. Returns plaintext."""
    # Restore base64url padding
    key_b64  = key_b64url + '=' * (4 - len(key_b64url) % 4)
    key_bytes = base64.urlsafe_b64decode(key_b64)
    aesgcm    = AESGCM(key_bytes)
    iv         = payload[:12]
    ciphertext = payload[12:]
    return aesgcm.decrypt(iv, ciphertext, None)
```

### API Client

Three-step upload matching the existing API:

```python
def upload_encrypted(payload: bytes, file_size: int,
                     server_url: str, token: str) -> dict:
    headers = {"x-sgraph-access-token": token}

    # Step 1: Create transfer
    r1 = httpx.post(f"{server_url}/transfers/create",
                    json={"file_size_bytes": file_size,
                          "content_type_hint": "application/octet-stream"},
                    headers={**headers, "Content-Type": "application/json"})
    r1.raise_for_status()
    transfer_id = r1.json()["transfer_id"]

    # Step 2: Upload encrypted payload
    r2 = httpx.post(f"{server_url}/transfers/upload/{transfer_id}",
                    content=payload,
                    headers={**headers, "Content-Type": "application/octet-stream"})
    r2.raise_for_status()

    # Step 3: Complete
    r3 = httpx.post(f"{server_url}/transfers/complete/{transfer_id}",
                    headers={**headers, "Content-Type": "application/json"})
    r3.raise_for_status()

    return r3.json()
```

### JSON Output

All commands output structured JSON for LLM consumption:

```json
{
  "download_url": "https://send.sgraph.ai/send/v0/v0.1/v0.1.6/download.html#abc123/key",
  "transfer_id": "abc123",
  "key": "base64url-encoded-key",
  "file_size": 1048576,
  "status": "complete"
}
```

### Distribution

- **PyPI:** `pip install sg_send`
- **uvx:** `uvx sg_send upload --file report.pdf` (no install needed)
- **Dependencies:** `cryptography`, `httpx` (minimal)

---

## Phase 2: MCP Server

### Architecture

The MCP server wraps the same crypto and API client modules from the CLI:

```python
from mcp.server.fastmcp import FastMCP
from sg_send.crypto import encrypt_file, decrypt_file
from sg_send.api_client import upload_encrypted, download_encrypted

mcp = FastMCP("sg-send")

@mcp.tool()
def send_file(file_path: str) -> dict:
    """Encrypt a file with AES-256-GCM and upload to SG/Send.
    Returns download URL with embedded decryption key.
    The server never sees the plaintext or the key."""
    with open(file_path, 'rb') as f:
        plaintext = f.read()
    payload, key_b64 = encrypt_file(plaintext)
    result = upload_encrypted(payload, len(plaintext), server_url, token)
    transfer_id = result["transfer_id"]
    download_url = f"{server_url}/send/v0/v0.1/v0.1.6/download.html#{transfer_id}/{key_b64}"
    return {"download_url": download_url, "transfer_id": transfer_id,
            "key": key_b64, "file_size": len(plaintext)}

@mcp.tool()
def receive_file(transfer_id: str, key: str, output_path: str) -> dict:
    """Download and decrypt a file from SG/Send."""
    payload = download_encrypted(transfer_id, server_url)
    plaintext = decrypt_file(payload, key)
    with open(output_path, 'wb') as f:
        f.write(plaintext)
    return {"status": "decrypted", "output": output_path, "size": len(plaintext)}

@mcp.tool()
def transfer_info(transfer_id: str) -> dict:
    """Get metadata about a transfer (size, status, timestamps)."""
    ...
```

### Transports

| Transport | Use Case | Configuration |
|-----------|----------|---------------|
| **stdio** | Claude Code, Claude Desktop, local tools | Server spawned as child process |
| **Streamable HTTP** | Remote/hosted deployment, multi-client | Single HTTP endpoint with SSE |

### Client Configuration

**Claude Desktop** (`claude_desktop_config.json`):
```json
{
  "mcpServers": {
    "sg-send": {
      "type": "stdio",
      "command": "uvx",
      "args": ["sg_send", "mcp"],
      "env": {
        "SGRAPH_SEND_TOKEN": "your-token",
        "SGRAPH_SEND_URL": "https://send.sgraph.ai"
      }
    }
  }
}
```

**Claude Code** (CLI):
```bash
claude mcp add-json sg-send '{
  "command": "uvx",
  "args": ["sg_send", "mcp"],
  "env": { "SGRAPH_SEND_TOKEN": "your-token" }
}'
```

**Project-level** (`.mcp.json`):
```json
{
  "mcpServers": {
    "sg-send": {
      "type": "stdio",
      "command": "python",
      "args": ["-m", "sg_send.mcp_server"],
      "env": { "SGRAPH_SEND_TOKEN": "${SGRAPH_SEND_TOKEN}" }
    }
  }
}
```

---

## Phase 3: Server-Side API Enhancements

### Single-Step Upload Endpoint

The three-step flow is designed for browser streaming. CLI/MCP tools buffer the entire payload and benefit from a single-step endpoint:

```python
@router.post("/api/upload")
async def upload_single(request: Request) -> dict:
    """Single-step encrypted upload for CLI/MCP tools."""
    # Combines create + upload + complete in one request
    # Accepts encrypted payload as request body
    # Returns transfer_id, download_url, transparency report
```

### Health Endpoint

```python
@router.get("/api/health")
async def health() -> dict:
    return {"status": "ok", "version": "0.4.17", "encryption": "AES-256-GCM"}
```

### OpenAPI Specification

Publish a formal OpenAPI 3.1.0 spec at `/.well-known/openapi.json` for tool auto-discovery.

---

## Implementation Order

| Step | Deliverable | Effort | Dependencies |
|------|-------------|--------|--------------|
| 1 | `sg_send` crypto module + tests | 1 day | None |
| 2 | `sg_send` API client + upload command | 1 day | Step 1 |
| 3 | `sg_send` download command | 0.5 day | Step 1 |
| 4 | Cross-compatibility test (Python ↔ JS crypto) | 0.5 day | Step 1 |
| 5 | PyPI packaging + `uvx` support | 0.5 day | Steps 1-3 |
| 6 | MCP server (FastMCP wrapper) | 1 day | Steps 1-3 |
| 7 | MCP configuration docs | 0.5 day | Step 6 |
| 8 | Single-step upload endpoint | 1 day | None (server-side) |
| 9 | OpenAPI spec | 0.5 day | Step 8 |

**Total estimated effort:** ~6.5 days (Explorer track)

---

## What NOT to Build

1. **GPT Actions for encrypted upload** — Cannot perform client-side encryption; breaks zero-knowledge
2. **Server-side decryption endpoint** — Destroys the security model
3. **Key persistence in LLM memory** — Keys should be ephemeral, shown once to the user
4. **Claude Skills (for now)** — Beta, network-restricted sandbox, Claude-only; revisit when stable

---

## Open Questions for Human Decision

1. ~~**Package name:**~~ Decided: `sg_send`
2. **MCP bundling:** Separate `sg_send_mcp` package or `sg_send mcp` subcommand?
3. **Single-step endpoint:** New path `/api/upload` or extend existing `/transfers/create` to accept inline payload?
4. **Rate limits:** What per-token limits for CLI/MCP usage? (Suggested: 60 req/min, 1 GB/hour)
