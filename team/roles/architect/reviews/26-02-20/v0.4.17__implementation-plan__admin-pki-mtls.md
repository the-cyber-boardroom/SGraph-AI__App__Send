# Admin PKI & mTLS — Implementation Plan

**Version:** v0.4.17
**Date:** 2026-02-20
**Role:** Architect
**Team:** Explorer

---

## Summary

This plan covers adding mutual TLS (mTLS) client certificate authentication to SG/Send's admin Lambda, providing stronger authentication than API tokens for admin operations.

---

## Current Admin Authentication

The admin Lambda uses a simple access token (`x-sgraph-access-token` header) validated against environment variables or the admin service. This is adequate for the current stage but has limitations:

- Tokens are static strings — no expiry, no rotation mechanism
- Tokens can be leaked in logs, env vars, or config files
- No cryptographic proof of client identity
- Token-based auth doesn't provide non-repudiation

---

## What mTLS Provides

Mutual TLS adds **client certificates** to the TLS handshake. Both the server and client present certificates, providing:

1. **Cryptographic client identity** — the client proves possession of a private key
2. **No shared secrets** — unlike tokens, nothing to leak in logs
3. **Certificate lifecycle** — expiry, revocation, renewal
4. **Non-repudiation** — actions are tied to a specific certificate

---

## Architecture Options

### Option A: mTLS at Lambda Function URL (Not Viable)

AWS Lambda Function URLs do **not** support mTLS natively. The TLS termination happens at AWS's load balancer, and there is no mechanism to request or validate client certificates.

### Option B: mTLS via API Gateway (Viable but Heavy)

AWS API Gateway supports mTLS with a custom trust store in S3. This requires:
- Switching from Lambda Function URL to API Gateway
- Uploading a CA certificate bundle to S3
- API Gateway validates client certs before forwarding to Lambda

**Trade-off:** Adds API Gateway infrastructure (cost, complexity, latency) to get mTLS.

### Option C: Application-Level Certificate Validation (Recommended for Explorer)

Instead of transport-level mTLS, implement **application-level certificate-based authentication**:

1. Admin generates a key pair and self-signed certificate (or CA-signed)
2. Certificate's public key is registered with the admin service
3. Admin signs each request with their private key
4. Server validates the signature against the registered public key

This provides the same cryptographic guarantees as mTLS without requiring infrastructure changes.

### Option D: mTLS at Container/EC2 Level (Future — Villager)

When SG/Send runs on EC2 or in a container (Docker/Fargate), the application controls TLS termination and can implement true mTLS using Python's `ssl` module:

```python
import ssl

ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
ssl_context.load_cert_chain('server.pem', 'server-key.pem')
ssl_context.verify_mode = ssl.CERT_REQUIRED
ssl_context.load_verify_locations('trusted-clients-ca.pem')
```

This is the cleanest mTLS path but only applies to non-Lambda deployment targets.

---

## Recommended Approach: Signed Request Authentication

### How It Works

```
Admin Setup:
  1. Generate ECDSA P-256 key pair (openssl or Web Crypto)
  2. Register public key with admin service: POST /admin/keys
  3. Receive key_id for the registered key

Request Signing:
  1. Construct signing string: METHOD + PATH + TIMESTAMP + BODY_HASH
  2. Sign with ECDSA private key
  3. Include headers: X-Key-Id, X-Timestamp, X-Signature

Server Validation:
  1. Look up public key by key_id
  2. Verify signature against signing string
  3. Check timestamp freshness (±5 minutes)
  4. Process request
```

### Request Signing Format

```
# Signing string construction
signing_string = f"{method}\n{path}\n{timestamp}\n{sha256(body)}"

# Headers
X-Key-Id: kid_abc123
X-Timestamp: 2026-02-20T10:30:00Z
X-Signature: base64url(ecdsa_sign(signing_string, private_key))
```

### Schema (Type_Safe)

```python
class Schema__Admin_Key(Type_Safe):
    key_id        : str    # Unique identifier for this key
    public_key_pem: str    # PEM-encoded ECDSA P-256 public key
    display_name  : str    # Human-readable label ("Dinis's laptop")
    created_at    : str    # ISO 8601
    expires_at    : str    # ISO 8601 (optional)
    revoked       : bool = False
    last_used_at  : str = ""
```

### API Endpoints (Admin Lambda)

| Method | Path | Purpose | Auth |
|--------|------|---------|------|
| POST | `/admin/keys` | Register a new admin public key | Existing token (bootstrap) |
| GET | `/admin/keys` | List registered admin keys | Signed request |
| DELETE | `/admin/keys/{key_id}` | Revoke an admin key | Signed request |

### Authentication Middleware

```python
class Auth__Signed_Request:
    """Validates signed requests against registered admin keys."""

    def validate(self, request) -> bool:
        key_id    = request.headers.get("X-Key-Id")
        timestamp = request.headers.get("X-Timestamp")
        signature = request.headers.get("X-Signature")

        # 1. Check timestamp freshness
        if abs(now() - parse(timestamp)) > timedelta(minutes=5):
            return False

        # 2. Look up public key
        admin_key = self.key_store.get(key_id)
        if not admin_key or admin_key.revoked:
            return False

        # 3. Reconstruct signing string
        signing_string = f"{request.method}\n{request.path}\n{timestamp}\n{sha256(request.body)}"

        # 4. Verify ECDSA signature
        return verify_signature(admin_key.public_key_pem, signing_string, signature)
```

---

## Migration Path

### Phase 1: Add Signed Request Auth (Alongside Token Auth)

- Both token and signed-request authentication accepted
- Admin can register keys using existing token auth
- Gradual migration: start using signed requests for new operations

### Phase 2: Require Signed Requests for Sensitive Operations

- Token auth remains for read-only operations
- Signed requests required for: key management, token creation, data deletion
- Existing tokens continue to work for non-sensitive operations

### Phase 3: Full mTLS (Villager — Container/EC2 Deployments)

- When deployed on EC2/container, add true TLS-level mTLS
- Application-level signed requests remain as fallback for Lambda deployments
- Both mechanisms can coexist

---

## CLI Tool Integration

The `sg_send` CLI tool (from the LLM integration plan) can also handle admin operations:

```bash
# Generate admin key pair
sg_send admin keygen --output admin-key.pem

# Register public key with admin service
sg_send admin register --key admin-key.pem --name "CI Pipeline"

# Make signed admin request
sg_send admin stats --key admin-key.pem
```

---

## Security Considerations

| Concern | Mitigation |
|---------|------------|
| Key compromise | Key revocation endpoint; key expiry (default 90 days) |
| Replay attacks | Timestamp freshness check (±5 minutes); nonce optional |
| Clock skew | 5-minute window accommodates reasonable clock drift |
| Bootstrap problem | First key registered via existing token auth |
| Key storage | Private keys stored on admin's machine, never uploaded |
| Algorithm agility | Key schema includes algorithm field; start with ECDSA P-256 |

---

## Comparison with Alternatives

| Approach | Infrastructure Change | Lambda Compatible | Crypto Proof | Complexity |
|----------|----------------------|-------------------|--------------|------------|
| API tokens (current) | None | Yes | No | Low |
| **Signed requests** | None | **Yes** | **Yes** | **Medium** |
| mTLS via API Gateway | Add API Gateway | Yes (with Gateway) | Yes | High |
| mTLS at application | Need EC2/container | No (Lambda) | Yes | Medium |
| OAuth 2.0 + JWT | Add auth provider | Yes | Partial | High |

**Recommendation:** Signed requests for Explorer (works with Lambda), true mTLS for Villager (when deploying to containers/EC2).

---

## Open Questions for Human Decision

1. **Key expiry default:** 90 days, 1 year, or no expiry?
2. **Maximum keys per admin:** Unlimited or capped?
3. **Signature algorithm:** ECDSA P-256 (recommended) or Ed25519 (faster, simpler, but less library support in Python stdlib)?
4. **Priority:** Is admin PKI needed before or after the LLM integration work?
