# Browser PKI & Key Management — Implementation Plan

**Version:** v0.4.17
**Date:** 2026-02-20
**Role:** Architect
**Team:** Explorer

---

## Summary

This plan covers adding public-key infrastructure (PKI) to SG/Send's browser-based encryption, enabling **recipient-addressed encryption** ("send to Alice") alongside the existing symmetric key model.

---

## Current State

SG/Send uses AES-256-GCM (symmetric) via the Web Crypto API. The sender generates a key, encrypts in-browser, uploads ciphertext, and shares the download URL (which contains the key in the URL fragment). The recipient clicks the link and decrypts in-browser. The server never sees plaintext or keys.

**Limitation:** The sender must share the key out-of-band. There is no way to say "encrypt this for Alice" without Alice first sharing a key.

---

## Architecture: Hybrid Encryption

The standard approach is **hybrid encryption** — use asymmetric keys (ECDH or RSA) to wrap a per-file symmetric key (AES-256-GCM):

```
Sender:
  1. Generate random AES-256-GCM key (per file)
  2. Encrypt file with AES key → ciphertext
  3. Fetch recipient's public key from server
  4. Wrap AES key with recipient's public key → wrapped_key
  5. Upload ciphertext + wrapped_key to server

Recipient:
  1. Download ciphertext + wrapped_key
  2. Unwrap AES key with their private key
  3. Decrypt file with AES key → plaintext
```

This preserves zero-knowledge: the server stores ciphertext and a wrapped key, but cannot decrypt either without the recipient's private key.

---

## Web Crypto API Capabilities

The Web Crypto API (`window.crypto.subtle`) natively supports all required operations:

### Key Generation

| Algorithm | Method | Use Case |
|-----------|--------|----------|
| ECDH (P-256) | `generateKey({name: "ECDH", namedCurve: "P-256"}, true, ["deriveKey"])` | Key agreement — sender and recipient derive shared secret |
| RSA-OAEP (2048+) | `generateKey({name: "RSA-OAEP", modulusLength: 2048, ...}, true, ["wrapKey", "unwrapKey"])` | Direct key wrapping — sender wraps AES key with recipient's public key |
| AES-256-GCM | Already implemented in `crypto.js` | File encryption (unchanged) |

**Recommendation:** Use **ECDH P-256** for key agreement. It produces smaller keys (65 bytes public key vs 294+ bytes for RSA-2048), is faster, and is the modern standard. P-256 is universally supported across all browsers.

### Key Export/Import

```javascript
// Export public key for sharing
const publicKeyJwk = await crypto.subtle.exportKey("jwk", keyPair.publicKey);

// Import recipient's public key
const recipientKey = await crypto.subtle.importKey(
  "jwk", recipientPublicKeyJwk,
  { name: "ECDH", namedCurve: "P-256" },
  false, []
);

// Derive shared AES key using ECDH
const sharedKey = await crypto.subtle.deriveKey(
  { name: "ECDH", public: recipientKey },
  senderPrivateKey,
  { name: "AES-GCM", length: 256 },
  false, ["encrypt", "decrypt"]
);
```

### Key Storage (Browser)

| Storage | Persistence | Security | Use Case |
|---------|-------------|----------|----------|
| **IndexedDB** (via CryptoKey objects) | Persistent across sessions | Keys marked `extractable: false` cannot be exported | Long-term recipient keys |
| **SessionStorage** | Tab lifetime | Cleared on tab close | Ephemeral sender keys |
| **In-memory** | Page lifetime | Cleared on navigation | Current model (unchanged) |

**Recommendation for MVP:** Store recipient key pairs in **IndexedDB** with `extractable: false` for the private key. This means the private key can be used for decryption but never exported from the browser — even JavaScript cannot read it. The public key is exported (JWK format) and registered with the server.

---

## Key Registration Flow

### Recipient Registers a Public Key

```
1. Recipient visits send.sgraph.ai/keys (new page)
2. Browser generates ECDH P-256 key pair
3. Private key → IndexedDB (extractable: false)
4. Public key → exported as JWK
5. POST /api/keys { public_key: <jwk>, display_name: "Alice" }
6. Server returns short_code: "abc123" (6-char alphanumeric)
7. Recipient shares short_code with senders
```

### Sender Uses Recipient's Public Key

```
1. Sender enters recipient's short_code on upload page
2. GET /api/keys/abc123 → returns public_key JWK
3. Browser generates ephemeral ECDH key pair
4. ECDH derive shared secret → AES-256-GCM key
5. Encrypt file with derived AES key
6. Upload: ciphertext + sender's ephemeral public key
7. Recipient downloads, uses their private key + sender's ephemeral public key → same shared secret → decrypt
```

---

## API Endpoints (New)

| Method | Path | Purpose | Auth |
|--------|------|---------|------|
| POST | `/api/keys` | Register a public key | Access token |
| GET | `/api/keys/{short_code}` | Look up a public key | None |
| DELETE | `/api/keys/{short_code}` | Revoke a public key | Access token (owner) |
| GET | `/api/keys/{short_code}/fingerprint` | Get key fingerprint for verification | None |

### Schema (Type_Safe)

```python
class Schema__Public_Key(Type_Safe):
    short_code    : str           # 6-char alphanumeric, cryptographically random
    public_key_jwk: dict          # JWK format ECDH P-256 public key
    display_name  : str           # Human-readable label
    created_at    : str           # ISO 8601
    fingerprint   : str           # SHA-256 of public key bytes (for verification)
    key_type      : str = "ECDH"  # Algorithm identifier
    curve         : str = "P-256" # Named curve
```

---

## Modified Transfer Schema

The existing `Schema__Transfer` gains optional fields for asymmetric mode:

```python
class Schema__Transfer(Type_Safe):
    # ... existing fields ...
    encryption_mode    : str = "symmetric"  # "symmetric" | "hybrid"
    recipient_code     : str = ""           # short_code of recipient's public key
    sender_ephemeral_pk: str = ""           # sender's ephemeral public key (JWK, base64)
```

When `encryption_mode` is `"hybrid"`, the download page uses the recipient's private key (from IndexedDB) and the sender's ephemeral public key to derive the decryption key, instead of reading it from the URL fragment.

---

## Implementation Phases

### Phase A: Key Registration (Explorer)

1. New UI page: `keys/index.html` — generate key pair, register with server
2. New API routes: `POST /api/keys`, `GET /api/keys/{code}`
3. New service: `Key__Service` with `Storage_FS` backend
4. New schema: `Schema__Public_Key`
5. Tests: key generation, registration, lookup, fingerprint verification

### Phase B: Hybrid Upload (Explorer)

1. Modify upload page: optional "Recipient code" field
2. New JS module: `hybrid-crypto.js` — ECDH key agreement, key wrapping
3. Modified upload flow: when recipient code is provided, use hybrid encryption
4. Store sender's ephemeral public key alongside ciphertext
5. Tests: hybrid encrypt/decrypt round-trip, format compatibility

### Phase C: Hybrid Download (Explorer)

1. Modify download page: detect `encryption_mode` from transfer info
2. If hybrid: prompt for private key access (IndexedDB), derive shared secret, decrypt
3. If symmetric: existing flow (key from URL fragment)
4. Fallback: if private key not in this browser, show "key not found" with instructions
5. Tests: cross-browser key pair, download on different device

### Phase D: Key Recovery (Explorer, Future)

1. Optional encrypted key backup (key wrapped with passphrase)
2. QR code export of key pair
3. Multi-device key sync (encrypted, server-mediated)

---

## Security Considerations

| Concern | Mitigation |
|---------|------------|
| Private key theft via XSS | `extractable: false` — Web Crypto API prevents export even from JavaScript |
| Key registration spam | Rate-limit POST /api/keys per IP and per token |
| Short code enumeration | 6-char alphanumeric = 2.18 billion combinations; rate-limit lookups |
| Man-in-the-middle on key lookup | Fingerprint verification UI; future: key transparency log |
| Browser data loss | Key recovery mechanism (Phase D); warn users about clearing browser data |
| Forward secrecy | Ephemeral sender keys per transfer — compromise of one transfer doesn't affect others |

---

## Browser Compatibility

All required Web Crypto operations (ECDH P-256, AES-256-GCM, key derivation) are supported in:

- Chrome 37+ (2014)
- Firefox 34+ (2014)
- Safari 11+ (2017)
- Edge 12+ (2015)

No polyfills needed. Coverage: >97% of global browsers.

---

## Open Questions for Human Decision

1. **Short code format:** 6-char alphanumeric (`abc123`) or human-readable words (`blue-tiger-7`)?
2. **Key expiry:** Should registered public keys expire? If so, what default TTL?
3. **Multi-key support:** Can a recipient register multiple keys (e.g., work + personal)?
4. **Anonymous key registration:** Allow key registration without an access token?
