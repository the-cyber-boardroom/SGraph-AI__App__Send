# v0.2.41 — Architect Review: osbot-* Ecosystem Architecture Assessment

**Version:** v0.2.41
**Date:** 14 February 2026
**Role:** Architect
**Context:** Assessment of how SGraph Send uses the osbot-* ecosystem and MGraph-AI cache service — architectural patterns, coupling boundaries, and strategic observations

---

## 1. Executive Summary

SGraph Send is built on three architectural pillars from the osbot ecosystem:

1. **Type_Safe as the universal data model** — replaces Pydantic, provides declarative schemas with domain-specific safe primitives
2. **Service Registry as the integration pattern** — enables code-agnostic multi-service composition (IN_MEMORY for tests, REMOTE for production)
3. **Memory-FS + Cache Service as the storage abstraction** — application code never constructs paths, never calls boto3, never knows its deployment target

This review assesses each pillar architecturally: what works, what's at risk, and where the boundaries lie.

---

## 2. Pillar 1: Type_Safe as Universal Data Model

### 2.1 Architecture Pattern

Every data container — schemas, service classes, config objects — extends `Type_Safe` from `osbot-utils`. This gives SGraph Send a single type system across:

```
Schemas (data definition)
  └─ Type_Safe with Safe_* primitives
Services (business logic)
  └─ Type_Safe with typed fields for dependencies
Config (runtime configuration)
  └─ Type_Safe with environment-sourced defaults
```

### 2.2 What This Gives Us Architecturally

| Benefit | Mechanism |
|---------|-----------|
| **Self-documenting API** | Default values appear in Swagger UI (`usage_limit=50` guides admin users) |
| **Input sanitisation** | `Safe_Str__Id` strips dangerous characters; `Safe_UInt` rejects negatives |
| **Domain vocabulary** | `Safe_UInt__FileSize` vs `Safe_UInt` — the type name communicates intent |
| **No validation framework** | No Pydantic means no `model_validate`, no `model_dump`, no schema version drift |
| **Consistent serialisation** | `.json()` on any Type_Safe object produces deterministic JSON |

### 2.3 Architectural Risk: Safe Primitive Character Stripping

The v0.2.41 Type_Safe audit revealed that `Safe_Str__Id` silently strips `/`, `:`, `+`. This is a **data integrity risk** — if a developer uses `Safe_Str__Id` for a MIME type (`application/json`) or a URL path (`/transfers/abc123`), the value is silently corrupted with no error.

**Current mitigation:** The audit migrated all fields to domain-specific types (`Safe_Str__Http__Content_Type` for MIME, `Safe_Str__File__Path` for paths). But this is a one-time fix — future developers need to know the character-set constraints of each Safe type.

**Architectural recommendation:** The primitives reference document (`library/dependencies/osbot-utils/type_safe/`) should be mandatory reading for any Dev session that adds new schema fields.

### 2.4 Gap: No Safe Type for ISO Timestamps

ISO 8601 strings (`2026-02-14T10:30:00+00:00`) contain `:` and `+`, which no existing `Safe_Str` preserves. Fields storing ISO timestamp strings remain as bare `str`. This is the only place in our schemas where we can't use a Safe primitive.

**Recommendation:** Request a `Safe_Str__Iso_Timestamp` type from the osbot-utils maintainers (regex: `\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}[+\-]\d{2}:\d{2}`).

---

## 3. Pillar 2: Service Registry as Integration Pattern

### 3.1 Architecture Pattern

The Service Registry (`osbot-fast-api`) implements the **Service Locator** pattern for inter-service communication. Each service is registered with a mode and config:

```
                  ┌─────────────────────────────┐
                  │    Service Registry          │
                  │  (singleton, per-process)    │
                  ├─────────────────────────────┤
                  │  Cache__Service__Client      │
                  │    mode: IN_MEMORY           │
                  │    app: Cache_Service__Fast_API│
                  ├─────────────────────────────┤
                  │  Admin__Service__Client      │
                  │    mode: REMOTE (prod)       │
                  │    base_url: env var          │
                  │    api_key: env var           │
                  └─────────────────────────────┘
                          │
          ┌───────────────┼───────────────┐
          ▼                               ▼
   Send__Cache__Client            Admin__Service__Client
   (analytics, tokens)           (token validation)
          │                               │
          ▼                               ▼
   TestClient (in-memory)         httpx (remote)
   or httpx (when REMOTE)        or TestClient (tests)
```

### 3.2 Why This Architecture Is Correct for SGraph Send

**Problem:** Two Lambda functions need to communicate. The user Lambda validates tokens against the admin Lambda. The cache service processes analytics for every request.

**Alternative approaches considered:**

| Approach | Latency | Testability | Code Complexity |
|----------|---------|-------------|-----------------|
| Direct HTTP calls (httpx) | 50-100ms | Requires running server | Low but brittle |
| Event-driven (SQS/SNS) | Async, eventual | Hard to test end-to-end | Medium |
| Shared database | 5-20ms | Requires running DB | Medium |
| **Service Registry** | **0ms (IN_MEMORY) / 50ms (REMOTE)** | **Zero-mock, same code** | **Low** |

The Service Registry wins because it's the only approach where:
1. Tests use the exact same code path as production
2. No mocks, patches, or fakes
3. Switching from IN_MEMORY to REMOTE is a config change, not a code change

### 3.3 How We Use It: Two Registrations

**Registration 1: Cache Service (always IN_MEMORY)**

```python
# In Send__Cache__Setup.py
cache_service = Cache_Service__Fast_API()
cache_service.setup()
config = Fast_API__Service__Registry__Client__Config(
    mode      = Enum__Fast_API__Service__Registry__Client__Mode.IN_MEMORY,
    fast_api  = cache_service,
    fast_api_app = cache_service.app()
)
fast_api__service__registry.register(client_type=Cache__Service__Client, config=config)
```

The cache service runs in-process in all environments. At scale, we flip to REMOTE — zero code changes.

**Registration 2: Admin Service (REMOTE in prod, IN_MEMORY in tests)**

```python
# Production (Admin__Service__Client__Setup.py)
config = Fast_API__Service__Registry__Client__Config(
    mode         = Enum__Fast_API__Service__Registry__Client__Mode.REMOTE,
    base_url     = get_env(ENV_VAR__SGRAPH_SEND__ADMIN__BASE_URL),
    api_key_name = get_env(ENV_VAR__SGRAPH_SEND__ADMIN__API_KEY__NAME),
    api_key_value= get_env(ENV_VAR__SGRAPH_SEND__ADMIN__API_KEY__VALUE)
)

# Tests
config = Fast_API__Service__Registry__Client__Config(
    mode         = Enum__Fast_API__Service__Registry__Client__Mode.IN_MEMORY,
    fast_api     = admin_fast_api,
    fast_api_app = admin_fast_api.app()
)
```

### 3.4 Architectural Risk: Shared Process State

When the cache service runs IN_MEMORY, it shares the Lambda's memory, event loop, and error domain. An unhandled exception in cache service code could crash the user-facing request.

**Current mitigation:** `Middleware__Analytics` wraps all cache writes in try/except. Cache failures never propagate to user responses. This is correct — analytics data loss is acceptable, transfer failures are not.

**Residual risk:** If the cache service has a memory leak, it erodes the Lambda's available memory over time. Mitigated by Lambda's ephemeral execution model (containers recycled regularly).

---

## 4. Pillar 3: Memory-FS + Cache Service as Storage Abstraction

### 4.1 Architecture Pattern

Storage in SGraph Send has two layers:

```
Application Code
     │
     ├── Transfer__Service ──────► Storage_FS (Memory-FS interface)
     │                               │
     │                          ┌────┴────┐
     │                          ▼         ▼
     │                   Storage_FS   Storage_FS__S3
     │                   __Memory     (s3_prefix="user/")
     │
     └── Send__Cache__Client ───► Cache__Service__Client
                                     │
                                     ▼
                               Cache_Service__Fast_API
                                     │
                                     ▼
                               Storage_FS (internal)
                                     │
                                ┌────┴────┐
                                ▼         ▼
                         Storage_FS   Storage_FS__S3
                         __Memory     (s3_prefix="admin/")
```

### 4.2 S3 Prefix Separation

| Prefix | Owner | Content |
|--------|-------|---------|
| `user/` | Transfer__Service | `user/transfers/{id}/meta.json`, `user/transfers/{id}/payload` |
| `admin/` | Cache Service | `admin/analytics/data/temporal/...`, `admin/tokens/data/key-based/...` |

Both use the same S3 bucket. The prefix separation mirrors the Lambda architecture — if we later deploy the cache service as a separate Lambda, the `admin/` prefix data naturally belongs to its IAM policy scope.

### 4.3 What the Cache Service Eliminates

My v0.2.33 review designed a custom cache layer from scratch. The MGraph-AI Cache Service eliminates all of that:

| Custom Code (v0.2.33) | Cache Service Feature (v0.2.40+) |
|------------------------|----------------------------------|
| Custom Storage_FS path generation per namespace | Automatic via 5 storage strategies |
| Sharded directory hash-to-ID resolution | Built-in content-addressable storage |
| Custom namespace directory creation | First-class namespace parameter |
| Custom temporal file writing with date paths | `TEMPORAL` strategy: `year/month/day/hour` |
| Custom "latest" pointer management | `TEMPORAL_LATEST` strategy with overwrite |
| ~25-35h build effort | ~8-12h integration effort |

### 4.4 Cache Service Strategies — Architectural Significance

The cache service offers five storage strategies. We currently use two:

| Strategy | Used | Purpose |
|----------|------|---------|
| `TEMPORAL` | Yes | Analytics events — auto-filed by timestamp |
| `KEY_BASED` | Yes | Tokens, costs, transfers — explicit cache keys |
| `TEMPORAL_LATEST` | Not yet | Real-time pulse — overwrite semantics |
| `CONTENT_ADDRESSABLE` | Not yet | Deduplication |
| `HIERARCHICAL` | Not yet | Nested data structures |

**Architectural observation:** The `TEMPORAL` strategy is what makes server-side analytics viable. Without it, we'd need custom code to construct `analytics/data/2026/02/14/10/event_abc123.json` paths. The strategy handles this automatically, including file listing and time-range queries.

### 4.5 Hash Generator — Token Resolution Architecture

Token names are human-friendly strings ("dinis-test-token") but stored via content-addressable hashing:

```
token_name: "dinis-test-token"
     │
     ▼
Cache__Hash__Generator.from_string("dinis-test-token")
     │
     ▼
hash: "a3f7b2c1..."
     │
     ▼
Cache Service: KEY_BASED lookup in "tokens" namespace
     │
     ▼
cache_id: "tokens/data/key-based/a3f7b2c1"
     │
     ▼
Token metadata JSON
```

This means token names can be any string — no slug requirements, no reserved characters. The hash function handles the mapping. Token lookup is O(1) regardless of token count.

---

## 5. Dependency Coupling Assessment

### 5.1 Coupling Map

```
SGraph Send
  │
  ├── TIGHT coupling to osbot-utils (Type_Safe, Safe_*)
  │     Every schema, service, and config class extends Type_Safe.
  │     Migration cost: Extremely high (rewrite all data containers).
  │     Risk: Low (stable, same-org maintenance).
  │
  ├── MODERATE coupling to osbot-fast-api (Routes, Service Registry)
  │     All routes use Fast_API__Routes base class.
  │     Service Registry is the inter-service backbone.
  │     Migration cost: High (rewrite routes and service communication).
  │     Risk: Low (stable patterns, canonical usage).
  │
  ├── MODERATE coupling to osbot-fast-api-serverless (Serverless__Fast_API)
  │     Both Lambda entry points extend this.
  │     Migration cost: Medium (could replace with plain FastAPI + Mangum).
  │     Risk: Low.
  │
  ├── THIN coupling to osbot-aws (S3 client, aws_config)
  │     Only used in Storage_FS__S3 and Send__Config.
  │     Migration cost: Low (replace with boto3 calls in 2 files).
  │     Risk: Very low.
  │
  └── THIN coupling to mgraph-ai-service-cache (Cache Service + Client)
        Only used in Send__Cache__Client and Send__Cache__Setup.
        Migration cost: Low (the wrapper insulates all application code).
        Risk: Medium (newer dependency, actively evolving).
```

### 5.2 Key Architectural Insight

The **Send__Cache__Client** wrapper is architecturally critical — it's the anti-corruption layer between the application and the cache service. If the cache service API changes, only the wrapper needs updating. Application code calls `analytics__record_event()` and `token__lookup()` and never knows the cache service exists.

This is the same pattern as **Storage_FS** — the application calls `file__save()` and `file__bytes()` and never knows if it's talking to memory, disk, or S3.

**Both wrappers share the same architectural role:** insulate business logic from infrastructure choices.

---

## 6. Observations on the osbot Ecosystem

### 6.1 Strengths

1. **Convention over configuration.** Type_Safe eliminates boilerplate. Routes register with one line. Deployment is a context manager. The frameworks enforce patterns rather than asking developers to choose.

2. **Test ergonomics.** The IN_MEMORY mode for Service Registry means we test with real implementations. No mocking framework, no patch decorators, no "it works in tests but fails in prod" surprises. The full stack starts in ~100ms.

3. **Abstraction discipline.** The code never calls boto3 directly, never constructs S3 paths, never instantiates httpx clients. Each concern has one abstraction, and that abstraction is used everywhere.

4. **Consistent packaging.** All osbot-* packages follow the same patterns — `Type_Safe` base classes, `setup()` lifecycle, `setup_routes()` for FastAPI extensions. Learning one package means knowing the idioms for all of them.

### 6.2 Concerns

1. **Silent data corruption in Safe types.** `Safe_Str__Id` stripping characters without raising an error is a design choice that prioritises sanitisation over validation. For security (XSS prevention), this is correct. For data integrity, it's dangerous. The developer must choose the right type — there's no safety net if they choose wrong.

2. **Registry is a singleton.** `fast_api__service__registry` is a process-global singleton. In tests, registrations from one test can leak into another if not cleaned up. We haven't hit this yet because our test setup is disciplined, but it's a latent issue.

3. **No ISO timestamp Safe type.** This forces us to leave timestamp fields as bare `str`, breaking the otherwise complete Safe type coverage. Minor gap but noticeable.

### 6.3 Strategic Value

The osbot ecosystem is not just a set of libraries — it's an **architectural framework** that enforces:
- Type safety without Pydantic
- Service composition without mocks
- Storage abstraction without vendor lock-in
- Deployment abstraction across 7 targets

For SGraph Send specifically, this means we can focus on business logic (encryption, transfers, tokens, analytics) while the framework handles infrastructure concerns. The 7-deployment-target requirement from the architecture docs is achievable precisely because of these abstractions.

---

## 7. Recommendations

| # | Recommendation | Priority | Rationale |
|---|---------------|----------|-----------|
| R1 | Request `Safe_Str__Iso_Timestamp` from osbot-utils | P2 | Complete Safe type coverage |
| R2 | Document Safe primitive character-set constraints in a developer guide | P1 | Prevent silent data corruption in future schema changes |
| R3 | Add cache service package size measurement to CI | P1 | Monitor Lambda package size impact (per v0.2.40 review) |
| R4 | Evaluate `TEMPORAL_LATEST` strategy for health pulse endpoint | P3 | Could simplify the pulse computation |
| R5 | Add registry cleanup to test teardown | P2 | Prevent test pollution as test suite grows |

---

## 8. Summary

The osbot-* ecosystem provides SGraph Send with a disciplined architectural foundation:

- **Type_Safe** is the universal data model — every schema, service, and config
- **Service Registry** is the universal integration pattern — every inter-service call
- **Memory-FS / Cache Service** is the universal storage abstraction — every read and write

The coupling is intentional and well-bounded. The thin wrapper pattern (`Send__Cache__Client`, `Storage_FS`) means infrastructure can change without touching business logic. The IN_MEMORY mode means tests exercise production code paths.

The cache service adoption (v0.2.40) was the right architectural decision — it replaced 25-35 hours of custom path management with a proven package and preserved a clean extraction path to REMOTE mode when scale demands it.

---

*Architect review complete. This document assesses the architectural role of osbot-* packages and the MGraph-AI cache service in SGraph Send as of v0.2.41.*
