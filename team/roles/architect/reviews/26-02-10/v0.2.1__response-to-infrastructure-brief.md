# v0.2.1 — Architect Response to MVP Infrastructure Brief

**Version:** v0.2.1
**Date:** 2026-02-10
**Role:** Architect
**Responding to:** `team/humans/dinis_cruz/briefs/2026-02-10/v0.1.4__briefs__focus-on-mvp-release-infrastructure.md`

---

## 1. Architecture Alignment Assessment

The Conductor's brief is architecturally sound and consistent with the documented system topology (`team/roles/cartographer/v0.1.2/v0.1.2__system-landscape-map-revised.md`). No conflicts detected. The brief expands the deployment surface significantly beyond what was previously scoped (Lambda-only → 7 deployment targets), but the Memory-FS abstraction was designed specifically to make this possible.

### What Validates Well

| Brief Requirement | Architecture Support |
|---|---|
| Memory-FS proxy mode for all backends | Documented in system map §2a, §3a. Storage code is backend-agnostic. |
| Two Lambda functions (public + admin) | Admin Lambda scaffolded and tested (commit 07f1b09). Public Lambda structure defined. |
| Client-side AES-256-GCM | Zero-knowledge boundary documented in system map §7, §8. |
| File-based action logging | Storage layout in system map §4 — `transfers/{id}/events/` and `transfers/{id}/requests/`. |
| No mocks testing pattern | In-memory Memory-FS backend gives ~100ms full-stack startup (system map §6). |
| Pre-signed URL mode (future) | Documented as 2b/3b in system map. Not required for MVP proxy mode. |

### What Needs Architecture Updates

1. **Deployment target matrix** — The system map (§6) only covers Lambda environments (dev/qa/prod) + local. It needs expansion to cover Docker, ECS Fargate, EC2, AMI, and GCP Cloud Run.
2. **Entry point abstraction** — Currently we have `lambda_handler__admin.py` as the Lambda-specific entry point (Mangum adapter). Docker/EC2/GCP need a `uvicorn` entry point. Fargate needs a container health check. These should be documented as a matrix of entry points sharing the same `Fast_API__SGraph__App__Send__*` core.
3. **CLI architecture** — Not yet documented. The CLI should wrap the same core library used by the FastAPI routes, not call HTTP endpoints.

---

## 2. Memory-FS × Deployment Matrix Analysis

This is the critical architectural insight from the brief: **the deployment target and the storage backend are orthogonal concerns**.

```
                        Storage Backend (Memory-FS)
                    ┌──────────┬──────────┬──────────┐
                    │ In-Memory│ Disk     │ S3       │
Deployment  ┌──────┼──────────┼──────────┼──────────┤
Target      │Lambda│ tests    │ N/A      │ prod     │
            │Docker│ tests    │ dev      │ prod     │
            │ECS   │ tests    │ N/A      │ prod     │
            │EC2   │ tests    │ dev      │ prod     │
            │AMI   │ tests    │ dev      │ prod     │
            │GCP   │ tests    │ N/A      │ prod     │
            │Local │ tests    │ dev      │ int-test │
            └──────┴──────────┴──────────┴──────────┘
```

**Architecture decision needed:** How is the storage backend selected at runtime?

**Recommendation:** Environment variable `SGRAPH_SEND_STORAGE_BACKEND` with values `memory`, `disk`, `s3`. The `Fast_API__SGraph__App__Send__*` setup reads this and configures the Memory-FS instance accordingly. Default to `memory` for tests, `disk` for local dev, `s3` for production deployments.

---

## 3. Entry Point Architecture

Each deployment target needs a different entry point, but ALL share the same FastAPI application:

```
┌─────────────────────────────────────────────────────────┐
│ Core Application (shared)                                │
│                                                         │
│  Fast_API__SGraph__App__Send__Admin                     │
│  Fast_API__SGraph__App__Send__User   (to be created)    │
│                                                         │
│  Both extend Serverless__Fast_API from osbot-fast-api   │
│  Both use .setup() and .setup_routes() pattern          │
│  Both produce a standard FastAPI app via .app()         │
└──────────┬──────────────────────────────────────────────┘
           │
           │ .app() returns FastAPI instance
           ▼
┌──────────────────────────────────────────────────────────┐
│ Entry Points (one per deployment target)                  │
│                                                          │
│  Lambda:   lambda_handler.py → Mangum(app)              │
│  Docker:   Dockerfile → uvicorn app:app                 │
│  EC2/AMI:  systemd service → uvicorn app:app            │
│  Fargate:  container task def → uvicorn + health check  │
│  GCP:     Cloud Run → same container as Docker          │
│  Local:    python -m uvicorn app:app --reload           │
│  CLI:      cli.py → imports core library directly       │
└──────────────────────────────────────────────────────────┘
```

**Key architectural constraint:** Docker, Fargate, and GCP Cloud Run can share the same container image. EC2 and AMI may share a systemd-based entry point. This reduces the actual number of unique entry points to:
- Lambda (Mangum)
- Container (uvicorn — Docker, Fargate, GCP)
- Server (uvicorn + systemd — EC2, AMI)
- CLI (direct library import)
- Local dev (uvicorn with --reload)

---

## 4. API Contract Updates

The brief mentions CLI consumption of the same API. The current API contract (from `v0.1.1__fastapi-service-plan.md`) covers REST endpoints but not the CLI interface.

**Proposed CLI contract:**

```
# Upload
sgraph-send upload <file-path> --token <access-token> [--server <url>] [--storage memory|disk|s3]

# Download
sgraph-send download <transfer-id> --key <decryption-key> [--server <url>] --output <path>

# Local mode (no server)
sgraph-send upload <file-path> --local --storage disk --output-dir <path>
sgraph-send download <transfer-id> --key <decryption-key> --local --storage disk --data-dir <path>
```

The CLI should import and call the same service classes that the FastAPI routes use (`Service__App__Send__Transfers`, etc.), not make HTTP calls. This is architecturally cleaner and enables offline/local usage.

---

## 5. Flags and Concerns

### 5.1 Lambda 6MB Response Limit

The Conductor's brief says "upload a file" — but Lambda URL Functions have a **6MB response payload limit** (not 20MB as noted in the risk register). For the proxy mode (MVP), this means downloaded files are capped at 6MB via Lambda. This is fine for MVP but must be documented.

**Correction to risk register:** Lambda URL Function payload limit is 6MB for response body (streamed), not 20MB. The 20MB limit applies to synchronous invocation payload.

### 5.2 Dockerfile Dependency on Lambda Layer Mechanism

The current `lambda_handler__admin.py` uses `load_dependencies()` which fetches packages from Lambda layers at runtime. Docker/EC2/GCP entry points must skip this and install dependencies via `pip`/`poetry` at build time. The conditional `if os.getenv('AWS_REGION')` guard in `lambda_handler__admin.py:3` partially handles this, but the container/server entry point should not import `lambda_handler` at all.

### 5.3 GCP Equivalent of Memory-FS S3 Backend

The brief says "multi-cloud from day one." For GCP Cloud Run with persistent storage, we'd need a Memory-FS → GCS backend. **Recommendation:** For MVP, GCP Cloud Run can use the Memory-FS S3 backend pointing at an AWS S3 bucket (cross-cloud). A native GCS backend is a Phase 2 item.

### 5.4 Admin Deployment Matrix

The brief says "admin interface needs the same deployment matrix." This doubles the number of deployment configurations: 7 targets × 2 Lambdas = 14 deployment configs. Architecturally sound (same container, different entry class) but the DevOps effort is significant.

---

## 6. Recommended Sequencing

1. **First:** Complete Public Lambda (mirror Admin Lambda pattern) — same day
2. **Second:** Docker container (single Dockerfile, build arg for admin vs user) — same day
3. **Third:** Local dev server (uvicorn entry point) — already works implicitly
4. **Fourth:** CLI (imports core library) — 1 day
5. **Fifth:** ECS Fargate (reuses Docker image + task definition) — infrastructure config only
6. **Sixth:** EC2 / AMI (systemd service + AMI bake) — infrastructure config only
7. **Seventh:** GCP Cloud Run (reuses Docker image + Cloud Run config) — infrastructure config only

The first three give us the full "one deployment target fully working end-to-end" that the brief requests. Items 5-7 are infrastructure configuration that reuses existing artifacts.

---

## 7. Action Items for Architect

- [ ] Update system landscape map to cover all 7 deployment targets
- [ ] Document entry point architecture (this review §3)
- [ ] Define storage backend selection mechanism (env var pattern)
- [ ] Update risk register (6MB Lambda response limit)
- [ ] Define CLI API contract
- [ ] Review Memory-FS integration once Conductor provides S3 class

---

*This review is the Architect's master file for the v0.1.4 infrastructure brief response.*
