# Architect Assessment: Interactive Encrypted Data Workflows, Briefing Packs, and Phase Sequencing

**Version:** v0.4.4
**Date:** 16 February 2026
**Role:** Architect (Explorer Team)
**Responding to:**
- `team/humans/dinis_cruz/briefs/02/16/v0.4.4__explorer-brief__interactive-encrypted-data-workflows.md`
- `team/humans/dinis_cruz/briefs/02/16/v0.4.4__briefs__briefing-packs-for-agents.md`
- `team/humans/dinis_cruz/briefs/02/16/v0.4.4__daily-brief__explorer-team-16-feb-2026.md`
- `team/humans/dinis_cruz/briefs/02/16/v0.4.3__role-definition__translator.md`

**Previous action plans:**
- `team/roles/architect/reviews/26-02-15/v0.3.12__action-plan__brief-response-15-feb.md`
- `team/roles/architect/reviews/26-02-14/v0.3.2__action-plan__explorer-next-steps.md`

---

## Executive Summary

The interactive encrypted data workflows concept is architecturally sound and fits naturally into the existing SGraph Send architecture. The server remains a dumb pipe -- it stores encrypted bytes and never needs to know whether those bytes are a file, text, or a JSON workflow payload. The entire interactive layer is a client-side concern that sits on top of the existing transfer engine without modifying it.

This assessment covers three areas: (A) the workflow architecture, schema format, rendering pipeline, and security model; (B) the briefing packs concept and its relationship to the repo; (C) phase sequencing and recommended prototyping order.

---

## Part A: Interactive Encrypted Data Workflows

### A.1 Fit Into the Existing Architecture

The current architecture has a clear separation:

```
CLIENT: encrypt(plaintext) --> ciphertext bytes
SERVER: store(ciphertext bytes) --> retrieve(ciphertext bytes)
CLIENT: decrypt(ciphertext bytes) --> plaintext
```

The interactive workflow concept adds a layer *after* decryption on the recipient side and *before* encryption on the response side:

```
SENDER CLIENT:
  data + ui_schema --> JSON --> encrypt --> ciphertext

SERVER:
  store(ciphertext) --> retrieve(ciphertext)    [NO CHANGE]

RECIPIENT CLIENT:
  ciphertext --> decrypt --> JSON --> parse ui_schema
  --> render interactive UI --> collect responses
  --> response JSON --> encrypt --> ciphertext

SERVER:
  store(response ciphertext)                    [NO CHANGE]
```

**Critical architectural observation:** The server's contract does not change at all. The server continues to receive opaque bytes via `POST /transfers/upload/{id}` and deliver them via `GET /transfers/download/{id}`. The Transfer__Service (`sgraph_ai_app_send/lambda__user/service/Transfer__Service.py`) stores bytes in `transfers/{id}/payload` via Storage_FS -- it has no knowledge of what those bytes contain.

The only server-side change that *could* be useful (but is not strictly required) is a `content_type_hint` value that distinguishes workflow payloads from raw files. The `content_type_hint` field already exists in the transfer metadata schema (`Schema__App__Send__Transfer`). Setting it to `application/vnd.sgraph.workflow+json` for workflow payloads would enable:
- Admin analytics: "how many workflow transfers vs. file transfers?"
- Client-side dispatch: the download page can detect whether to render a file download or a workflow UI

However, since the `content_type_hint` is metadata the *sender* provides (the server doesn't inspect the encrypted payload), this is purely a client-side convention. The server stores it but never acts on it.

**Verdict: The workflow concept is fully compatible with the existing architecture. Zero server-side changes required for the core flow.**

### A.2 Schema Format Recommendation

The brief proposes a JSON payload containing both `data` and a `ui_schema`. The Architect's recommendation for the schema format:

#### Recommendation: Custom Schema with JSON Schema Validation Rules

Do NOT use JSON Schema as the UI schema format. JSON Schema is designed for data validation, not UI rendering. It can describe *what* data looks like but not *how* to display it.

Instead, use a **custom declarative schema** that is purpose-built for the SGraph Send component library, with JSON Schema *embedded* for the validation rules portion.

#### Proposed Envelope Format

```json
{
  "sgraph_workflow": {
    "version": "1.0",
    "type": "translation_review",
    "title": "Translation Review: English to Brazilian Portuguese",
    "description": "20 strings to review"
  },
  "data": {
    "source_language": "en",
    "target_language": "pt-BR",
    "strings": [
      {
        "id": "hero.tagline",
        "original": "Your files, your keys, your privacy",
        "proposed": "Seus arquivos, suas chaves, sua privacidade",
        "context": "Main page hero section tagline",
        "status": "pending_review"
      }
    ]
  },
  "ui": {
    "layout": {
      "type": "vertical-stack",
      "children": [
        {
          "type": "header",
          "bind": {
            "title": "$.sgraph_workflow.title",
            "subtitle": "$.sgraph_workflow.description"
          }
        },
        {
          "type": "repeat",
          "source": "$.data.strings",
          "as": "item",
          "template": {
            "type": "card",
            "children": [
              {
                "type": "label",
                "text": "$.item.id",
                "style": "monospace"
              },
              {
                "type": "diff-viewer",
                "label_a": "$.data.source_language",
                "label_b": "$.data.target_language",
                "value_a": "$.item.original",
                "value_b": "$.item.proposed"
              },
              {
                "type": "approval-buttons",
                "bind_to": "$.item.status",
                "options": ["approved", "edited", "rejected"]
              },
              {
                "type": "text-area",
                "label": "Comment",
                "bind_to": "$.item.comment",
                "visible_when": {
                  "field": "$.item.status",
                  "not_equals": "pending_review"
                }
              },
              {
                "type": "text-input",
                "label": "Edited translation",
                "bind_to": "$.item.final",
                "default_value": "$.item.proposed",
                "visible_when": {
                  "field": "$.item.status",
                  "equals": "edited"
                }
              }
            ]
          }
        },
        {
          "type": "progress-bar",
          "source": "$.data.strings",
          "count_where": {
            "field": "status",
            "not_equals": "pending_review"
          },
          "label": "{count} of {total} reviewed"
        },
        {
          "type": "submit-button",
          "label": "Submit Review",
          "enabled_when": {
            "source": "$.data.strings",
            "all_match": {
              "field": "status",
              "not_equals": "pending_review"
            }
          }
        }
      ]
    }
  },
  "response_schema": {
    "type": "object",
    "properties": {
      "workflow": { "const": "translation_review_response" },
      "reviewed_at": { "type": "string", "format": "date-time" },
      "strings": {
        "type": "array",
        "items": {
          "type": "object",
          "properties": {
            "id": { "type": "string" },
            "status": { "enum": ["approved", "edited", "rejected"] },
            "final": { "type": "string" },
            "comment": { "type": "string" }
          },
          "required": ["id", "status"]
        }
      }
    }
  }
}
```

#### Key Design Decisions in This Schema

1. **Four top-level sections**: `sgraph_workflow` (envelope metadata), `data` (the actual content), `ui` (the rendering instructions), `response_schema` (JSON Schema for validating the response before encrypting and sending back).

2. **Data binding via JSON Path expressions**: `$.data.strings`, `$.item.original`. This is a restricted subset of JSONPath -- only direct property access and array traversal, no filters, no recursive descent. This keeps the renderer simple and auditable.

3. **`repeat` element for iteration**: Loops over an array in the data, rendering a template for each item. This is essential for the translation review use case (20+ strings) and for general list-based workflows.

4. **`visible_when` / `enabled_when` for conditional logic**: Simple equality/inequality checks against data fields. No arbitrary expressions. No function calls. Declarative only.

5. **`bind_to` for two-way binding**: Connects a UI element to a data field. When the user edits the field, the data is updated. When the response is serialised, these bound fields are included.

6. **`response_schema` for validation**: The sender defines what a valid response looks like. The recipient's browser validates the response against this schema before encrypting and sending it back. This prevents malformed responses.

#### Why Not JSON Schema Alone?

JSON Schema (`$ref`, `properties`, `items`, etc.) defines data shape, not UI layout. Libraries like `react-jsonschema-form` bridge this gap, but they:
- Require React (violates our zero-dependency rule)
- Produce generic forms (no approval buttons, no diff viewers, no progress bars)
- Cannot express conditional visibility or data binding cleanly
- Cannot express layout (horizontal vs. vertical stacking, cards, headers)

Our custom schema is *more restrictive* than JSON Schema (only the component types we define exist), *more expressive* for UI (layout, binding, conditionals), and *auditable* (a finite set of allowed elements).

#### Why Not Web Component Slot-Based Composition?

An alternative approach would be to define the UI as HTML strings with Web Component tags:

```html
<sgraph-card>
  <sgraph-label>hero.tagline</sgraph-label>
  <sgraph-diff-viewer ...></sgraph-diff-viewer>
</sgraph-card>
```

This approach is rejected because **HTML strings in the JSON payload create an injection risk**. Even with sanitisation, the attack surface of parsing arbitrary HTML is larger than parsing a known JSON schema. The declarative JSON schema is safer: it describes components by type name, and the renderer maps type names to known Web Components. No HTML parsing needed.

### A.3 The Rendering Pipeline

The complete rendering pipeline from encrypted transfer to interactive UI:

```
1. RECEIVE
   Browser receives encrypted bytes from server
   (existing: GET /transfers/download/{id})

2. DECRYPT
   Browser decrypts using key from URL fragment
   (existing: SendCrypto.decryptFile(key, ciphertext))

3. DETECT CONTENT TYPE
   If content_type_hint === 'application/vnd.sgraph.workflow+json'
     OR if decrypted bytes parse as JSON with an 'sgraph_workflow' key:
     --> workflow mode
   Else:
     --> file download mode (existing behaviour, no change)

4. PARSE
   JSON.parse(decryptedBytes) --> workflowPayload
   Validate: workflowPayload must have sgraph_workflow, data, ui sections
   Validate: workflowPayload.sgraph_workflow.version must be supported

5. CREATE DATA CONTEXT
   Build a DataContext object from workflowPayload.data
   DataContext provides:
     - get(jsonPath) -> value
     - set(jsonPath, value) -> updates data
     - observe(jsonPath, callback) -> notifies on change

6. RENDER UI
   WorkflowRenderer walks workflowPayload.ui.layout:
     For each element:
       a. Look up element.type in ComponentRegistry
       b. If not found: render a "unsupported component" placeholder (fail safe, not fail hard)
       c. Create the Web Component instance
       d. Bind data paths (resolve $.xxx against DataContext)
       e. Wire up visible_when / enabled_when conditions
       f. Append to parent container

7. USER INTERACTION
   User interacts with rendered components
   Components update DataContext via set() calls
   Conditional visibility re-evaluates automatically
   Progress bar updates via DataContext observation

8. SUBMIT
   User clicks submit button
   Collect all bound data from DataContext
   Validate against response_schema (JSON Schema validation)
   If invalid: show validation errors, do not proceed
   If valid: serialise response as JSON

9. ENCRYPT RESPONSE
   SendCrypto.encryptFile(responseKey, responseJSON)
   (responseKey may be a new key or the same key -- see A.6 below)

10. SEND RESPONSE
    Create a new transfer via existing API:
    POST /transfers/create --> POST /transfers/upload/{id} --> POST /transfers/complete/{id}
    The response is a new transfer linked to the original by convention
    (the response JSON includes the original transfer ID)
```

#### Key Components in the Pipeline

| Component | New or Existing | Description |
|-----------|----------------|-------------|
| `SendCrypto` | Existing | AES-256-GCM encrypt/decrypt -- no changes |
| `Transfer__Service` | Existing | Server-side transfer storage -- no changes |
| `ContentTypeDetector` | **New** | Determines if decrypted content is a workflow or a file |
| `DataContext` | **New** | Observable data store for workflow data binding |
| `WorkflowRenderer` | **New** | Walks UI schema, creates Web Components, wires bindings |
| `ComponentRegistry` | **New** | Maps schema type names to Web Component constructors |
| `ResponseSerializer` | **New** | Collects bound data, validates against response_schema |
| Workflow Web Components | **New** | The component library (see A.4) |

### A.4 UI Component Library

The brief defines 13 component types. The Architect recommends organising them into three tiers:

#### Tier 1: Core Components (needed for translation review prototype)

| Schema Type | Web Component Tag | Purpose | Complexity |
|------------|-------------------|---------|------------|
| `text-input` | `<sgraph-wf-text-input>` | Single-line text entry with label and binding | Low |
| `text-area` | `<sgraph-wf-text-area>` | Multi-line text entry | Low |
| `approval-buttons` | `<sgraph-wf-approval>` | Approve / Edit / Reject button group | Medium |
| `diff-viewer` | `<sgraph-wf-diff>` | Side-by-side text comparison | Medium |
| `comment-field` | `<sgraph-wf-comment>` | Contextual comment attached to an element | Low |
| `progress-bar` | `<sgraph-wf-progress>` | X of Y reviewed indicator | Low |
| `submit-button` | `<sgraph-wf-submit>` | Submit with validation gate | Low |

**Tier 1 delivers** the complete translation review workflow (Use Case 1).

#### Tier 2: Form Components (general-purpose forms)

| Schema Type | Web Component Tag | Purpose | Complexity |
|------------|-------------------|---------|------------|
| `dropdown` | `<sgraph-wf-dropdown>` | Select from a list | Low |
| `checkbox` | `<sgraph-wf-checkbox>` | Boolean toggle | Low |
| `radio-group` | `<sgraph-wf-radio>` | Select one from options | Low |
| `date-picker` | `<sgraph-wf-date>` | Date selection | Medium |
| `rating` | `<sgraph-wf-rating>` | Star/numeric rating | Low |

**Tier 2 delivers** general-purpose encrypted forms (surveys, data collection, feedback).

#### Tier 3: Advanced Components (specialised workflows)

| Schema Type | Web Component Tag | Purpose | Complexity |
|------------|-------------------|---------|------------|
| `file-upload` | `<sgraph-wf-file>` | Attach a file to the response | High |
| `signature` | `<sgraph-wf-signature>` | Digital signature / confirmation | High |

**Tier 3 delivers** document approval, contract workflows.

#### Naming Convention

All workflow components use the `sgraph-wf-` prefix to distinguish them from the existing `send-` prefixed components (e.g., `send-upload`, `send-download`). This keeps the two component namespaces cleanly separated.

#### Layout Components (implicit, not in the brief's table)

The schema also needs layout primitives:

| Schema Type | Web Component Tag | Purpose |
|------------|-------------------|---------|
| `vertical-stack` | `<sgraph-wf-vstack>` | Vertical container |
| `horizontal-stack` | `<sgraph-wf-hstack>` | Horizontal container |
| `card` | `<sgraph-wf-card>` | Grouped card with border/padding |
| `header` | `<sgraph-wf-header>` | Title + subtitle display |
| `repeat` | `<sgraph-wf-repeat>` | Iterates over array, renders template per item |
| `label` | `<sgraph-wf-label>` | Read-only text display |

#### Connection to IFD and Existing Web Components Approach

The existing user UI components (`send-upload`, `send-download`, `send-access-gate`, `send-transparency`) follow the IFD pattern:
- Each component is a single `.js` file containing `class extends HTMLElement`
- `connectedCallback()` calls `render()` which sets `this.innerHTML`
- No Shadow DOM (per CLAUDE.md constraints)
- CSS class prefixes per component
- Surgical override versioning across minor versions

The workflow components follow the same pattern, with one addition: **data binding**. Existing components manage their own state internally. Workflow components receive their state from a shared `DataContext` and report changes back to it. This is a lightweight observer pattern, not a framework:

```javascript
// Conceptual example -- not actual implementation
class SgraphWfTextInput extends HTMLElement {
    static get observedAttributes() { return ['bind-to', 'label']; }

    connectedCallback() {
        this.render();
        // Subscribe to DataContext changes for our bound path
        this._unsubscribe = this.dataContext.observe(
            this.getAttribute('bind-to'),
            (newValue) => this.updateDisplay(newValue)
        );
    }

    disconnectedCallback() {
        if (this._unsubscribe) this._unsubscribe();
    }

    onInput(event) {
        // Push change back to DataContext
        this.dataContext.set(this.getAttribute('bind-to'), event.target.value);
    }

    render() {
        const label = this.getAttribute('label') || '';
        this.innerHTML = `
            <div class="sgraph-wf-text-input">
                <label class="sgraph-wf-text-input__label">${label}</label>
                <input type="text" class="sgraph-wf-text-input__field" />
            </div>
        `;
        this.querySelector('input').addEventListener('input', (e) => this.onInput(e));
    }
}
customElements.define('sgraph-wf-text-input', SgraphWfTextInput);
```

**DataContext** is a plain JavaScript object with `get`, `set`, and `observe` methods. It is NOT a framework. It is ~50 lines of code. It uses a simple pub/sub pattern where observers register for specific JSON paths and are notified when those paths change.

#### IFD Versioning for Workflow Components

Workflow components live in a new asset folder:

```
sgraph_ai_app_send__ui__user/
  v0/v0.1/v0.1.x/                    # Existing upload/download UI
    components/
      send-upload/send-upload.js
      send-download/send-download.js
    js/
      crypto.js

  v0/v0.2/v0.2.0/                    # New: Workflow UI (major version)
    components/
      workflow-renderer/workflow-renderer.js
      data-context/data-context.js
      component-registry/component-registry.js
      sgraph-wf-text-input/sgraph-wf-text-input.js
      sgraph-wf-text-area/sgraph-wf-text-area.js
      sgraph-wf-approval/sgraph-wf-approval.js
      sgraph-wf-diff/sgraph-wf-diff.js
      sgraph-wf-comment/sgraph-wf-comment.js
      sgraph-wf-progress/sgraph-wf-progress.js
      sgraph-wf-submit/sgraph-wf-submit.js
      sgraph-wf-vstack/sgraph-wf-vstack.js
      sgraph-wf-hstack/sgraph-wf-hstack.js
      sgraph-wf-card/sgraph-wf-card.js
      sgraph-wf-header/sgraph-wf-header.js
      sgraph-wf-repeat/sgraph-wf-repeat.js
      sgraph-wf-label/sgraph-wf-label.js
    js/
      response-serializer.js
      content-type-detector.js
```

This is a new **major version** (v0.2.0) because it is self-contained and does not surgically override v0.1.x. The download page in v0.1.x would need a minor version (v0.1.7 or later) that adds the content type detection and delegates to the v0.2.0 workflow renderer when a workflow payload is detected.

**Alternative**: Put the workflow renderer in the same major version (v0.1.x) as a minor version addition. This avoids a major version bump but means the workflow components share the v0.1.x namespace. The Architect recommends the separate major version approach for cleaner separation, but this is a decision point for the Conductor.

### A.5 Security Considerations

The brief correctly identifies the critical security properties. The Architect's detailed analysis:

#### S1: Declarative-Only Schemas -- No Executable Code

**Requirement:** The UI schema must be declarative. It describes what to render, never what to execute.

**How this is enforced:**

1. **ComponentRegistry whitelist:** The `WorkflowRenderer` only instantiates components whose `type` is in the `ComponentRegistry`. Any unknown type is ignored (rendered as a placeholder, not executed). The registry is defined in code, not in the schema.

2. **No `eval`, no `Function()`, no `innerHTML` of untrusted content:** The renderer maps schema types to Web Component constructors. Data values are set as text content or attribute values, never as HTML. Specifically:
   - `element.textContent = value` (safe -- no HTML parsing)
   - `element.setAttribute('data-value', value)` (safe -- attributes are strings)
   - NEVER: `element.innerHTML = userProvidedValue` (unsafe)

3. **No `<script>` injection:** Since the schema is JSON (not HTML), and the renderer creates Web Components programmatically (not via `innerHTML` of HTML strings), there is no vector for `<script>` tag injection.

4. **Data binding paths are strings:** The `$.data.strings[0].original` path is resolved by splitting on `.` and traversing the data object. No `eval` of the path string. No dynamic property access beyond what the path describes.

#### S2: Renderer Sandboxing

**Requirement:** The renderer must be sandboxed to prevent exfiltration of decrypted data.

**Threat model:** A malicious sender crafts a schema that, when rendered, causes the recipient's browser to send decrypted data to a third-party server.

**Mitigations:**

1. **Content Security Policy (CSP):** The workflow page should have a strict CSP that prevents:
   - `connect-src`: Only allow connections to `*.sgraph.ai` (no external fetch/XHR)
   - `form-action`: Only allow form submission to `*.sgraph.ai`
   - `script-src`: Only allow same-origin scripts (no external script loading)
   - `img-src`: Restrict to `self` and `data:` URIs (prevent image-based exfiltration)

   This is the **primary defence**. Even if the renderer has a bug, CSP prevents data from leaving the page.

2. **No network-capable components:** None of the workflow components make network requests. The only network activity is the final submission (creating a new transfer via the existing API). Components that display data (`diff-viewer`, `label`) only read from DataContext; they do not fetch external resources.

3. **No `<img>`, `<iframe>`, `<link>` rendering from schema data:** The renderer does not create elements that can trigger external requests based on schema data. An `img` component (if ever added) must use data URIs or blob URLs from the decrypted payload, never external URLs.

4. **Iframe isolation (future hardening):** For maximum sandboxing, the workflow renderer could run inside a sandboxed `<iframe>` with `sandbox="allow-scripts"` (no `allow-same-origin`). This isolates the rendered workflow from the parent page's cookies, localStorage, and origin. Communication between the iframe and the parent page uses `postMessage()` with origin validation. This is NOT needed for the prototype but should be considered for production (Villager concern).

#### S3: Schema Validation Before Rendering

Before the renderer processes a schema, validate it:

1. **Structural validation:** Does the payload have the required top-level keys (`sgraph_workflow`, `data`, `ui`)?
2. **Version check:** Is `sgraph_workflow.version` a supported version?
3. **Component type whitelist:** Walk the `ui.layout` tree and verify every `type` value is in the ComponentRegistry.
4. **Path validation:** Verify all `bind_to`, `source`, and `$.xxx` paths resolve to actual locations in the data. Reject schemas with paths that reference non-existent data.
5. **Depth limit:** The UI tree should have a maximum nesting depth (e.g., 10 levels) to prevent stack overflow during rendering.
6. **Size limit:** The schema should have a maximum size (e.g., 1 MB of JSON) to prevent resource exhaustion.

If validation fails, show the user a clear message: "This workflow cannot be displayed. The schema is invalid." Do NOT attempt partial rendering.

#### S4: Exfiltration via CSS

**Threat:** CSS can exfiltrate data via `url()` in background-image, font-face src, etc.

**Mitigation:** Workflow components use only CSS classes defined in the component library. The schema cannot inject arbitrary CSS. All styling comes from the component definitions and the global theme system (Aurora, Glacier, Ember, etc.). No schema-provided CSS is rendered.

### A.6 Interaction with the Transfer Engine

The workflow sits on top of the existing transfer engine as a content-type specialisation:

```
EXISTING:
  Sender --> [encrypt file] --> Transfer --> [decrypt file] --> Recipient

WORKFLOW:
  Sender --> [encrypt JSON workflow] --> Transfer --> [decrypt, render UI] --> Recipient
  Recipient --> [serialise response, encrypt] --> Transfer --> [decrypt response] --> Sender
```

**Key architectural decision: the response is a NEW transfer, not a modification of the original.**

This preserves the existing transfer model (transfers are immutable once completed). The response transfer includes a reference to the original transfer ID in its data:

```json
{
  "sgraph_workflow_response": {
    "version": "1.0",
    "original_transfer_id": "abc123def456",
    "response_type": "translation_review_response"
  },
  "data": { ... response data ... }
}
```

The sender decrypts the response and correlates it with the original workflow via the `original_transfer_id`.

**Transfer manifest interaction:** If/when the transfer manifest evolves (per the brief's research task), the workflow type should be a field in the manifest:

```json
{
  "transfer_id": "abc123def456",
  "content_type": "application/vnd.sgraph.workflow+json",
  "workflow_type": "translation_review",
  "workflow_version": "1.0"
}
```

This is informational metadata that the server stores but never inspects (it is part of the encrypted manifest or the unencrypted transfer metadata, depending on the manifest design).

### A.7 Response Key Management

**Question from the Architect to the human:** How does the recipient encrypt their response?

Three options:

| Option | Mechanism | Security | UX |
|--------|-----------|----------|----|
| **R1: Same key** | Recipient uses the same AES-256-GCM key they used to decrypt the workflow | Both parties know the key. Server still sees nothing. | Simplest. No additional key management. |
| **R2: New key, sender's public key** | Recipient generates a new key, encrypts the response, and also encrypts the new key with the sender's public key (requires public key infrastructure) | Stronger: forward secrecy per response. | Complex: requires PKI or key exchange. |
| **R3: New key, shared via separate channel** | Recipient generates a new key, encrypts the response, and must share the key with the sender out-of-band | Same model as original transfer, but now the recipient is the sender. | Awkward: the recipient has to manage key sharing. |

**Architect recommendation: Option R1 for the prototype.** The sender already shared the key (it was in the URL fragment). Using the same key for the response means the sender can decrypt the response without any additional key exchange. The threat model is unchanged: both parties have the key, the server has neither the key nor the plaintext.

For production, Option R2 would provide forward secrecy (compromising the original key doesn't compromise the response), but this requires designing a key exchange mechanism. This is a Villager-track enhancement, not an Explorer concern.

**Decision needed from:** Human (confirm R1 for prototype).

---

## Part B: Briefing Packs Architecture

### B.1 Relationship to Issues FS

The briefing pack concept extends the existing Issues FS pattern. Currently, `.issues/` lives at the repo root and tracks project-wide issues. Briefing packs introduce *per-pack* `.issues/` folders that track issues specific to that unit of work.

**Architectural relationship:**

```
.issues/                          # Project-wide issues (existing)
  bugs.issues
  features.issues

briefing-packs/                   # New: pack library root
  cloudfront-log-pipeline/        # Workstream-level pack
    BRIEF.md
    .issues/
      tasks.issues                # Pack-specific issues
    architecture.md
    code-context.md
    addenda/
      devops.md
      appsec.md

  token-fetch-bug/                # Bug-level pack
    BRIEF.md
    .issues/
      bug.issues                  # Pack-specific issue
```

The pack-level `.issues/` folders are self-contained. They can be merged into the project-level `.issues/` by the Librarian when the pack's work is complete, or they can remain as historical records of the work done.

### B.2 Method Streams -- Implementation Approach

The brief describes "method streams" as extracting call chains from entry points into readable documents. This is an AST-level operation.

**For Python code**, the implementation approach:

1. **Use Python's `ast` module** to parse source files
2. **Walk the call graph** from a specified entry point function/method
3. **Extract each called function/method** with its file path, line numbers, and source
4. **Output as Markdown** with code blocks and file references

This could be a simple CLI tool:

```bash
python -m sgraph_send.tools.method_stream \
  --entry "Transfer__Service.create_transfer" \
  --output "briefing-packs/some-pack/code-context.md"
```

**For JavaScript code**, the approach is similar but uses a JS parser (or a simpler regex-based extraction for our codebase, since our Web Components are self-contained single-file components).

**Implementation priority:** Low. For the Explorer prototype, method streams can be extracted manually (read the code, copy the relevant functions into a Markdown document). Automated extraction is a Villager-track tooling improvement.

### B.3 Pack Folder Structure Recommendation

The Architect recommends the following pack library layout:

```
briefing-packs/
  _templates/                     # Reusable templates
    bug-pack-template/
      BRIEF.md
      .issues/
        bug.issues
    task-pack-template/
      BRIEF.md
      .issues/
        tasks.issues
    workstream-pack-template/
      BRIEF.md
      architecture.md
      code-context.md
      .issues/
        tasks.issues
      addenda/
      reference/

  _reference-summaries/           # Reusable context blocks (maintained by Librarian)
    caching-service-summary.md
    lets-pipeline-summary.md
    issues-fs-summary.md
    ifd-versioning-summary.md
    type-safe-structures-summary.md
    admin-ui-patterns-summary.md

  active/                         # Currently in-progress packs
    cloudfront-log-pipeline/
    interactive-workflow-prototype/

  completed/                      # Finished packs (historical record)
    token-fetch-bug/
```

**Why `active/` and `completed/`:** This makes it trivial to see what packs are in flight and what has been delivered. The Librarian moves packs from `active/` to `completed/` when the work is done and merged.

### B.4 Where Packs Live in the Repo

The `briefing-packs/` directory lives at the repo root, alongside `team/`, `library/`, and `.issues/`. It is a first-class organisational unit.

**Reasoning:**
- Packs are not role-specific (they span roles) -- so they don't belong under `team/roles/`
- Packs are not documentation (they are work units) -- so they don't belong under `library/`
- Packs contain their own issues -- so they are not part of the project-level `.issues/`
- Packs are git-tracked artifacts -- they belong in the repo, not external

---

## Part C: Phase Assessment and Sequencing

### C.1 What the Explorer Team Should Prototype First

**Recommendation: The translation review workflow (Use Case 1).** This aligns with both the brief's recommendation and the Architect's assessment.

Reasons:

1. **Most concrete use case.** The data format is defined (translation strings with original/proposed/status). The UI is sketched (approve/edit/reject per string with comments). The response format is defined. There are no ambiguous requirements.

2. **Smallest component surface.** Only Tier 1 components are needed (7 components + 6 layout primitives = 13 components total). No file upload, no signatures, no complex form logic.

3. **Exercises the full pipeline.** Even though it is small, it exercises every part of the architecture: schema parsing, DataContext, WorkflowRenderer, ComponentRegistry, data binding, conditional visibility, progress tracking, response serialisation, encryption round-trip.

4. **Immediate customer.** The Translator role (Villager team) needs the human reviewer workflow. Building the translation review prototype directly serves a known use case.

5. **Validates the security model.** The prototype is the first real test of the declarative schema security model. AppSec can review a working system rather than a theoretical design.

### C.2 Architectural Decisions Before Prototyping

These must be resolved before the Dev role starts implementation:

| # | Decision | Options | Architect Recommendation | Blocker? |
|---|----------|---------|--------------------------|----------|
| AD-11 | Schema format | JSON Schema, Custom (this doc), HTML-based | Custom declarative schema (Section A.2) | **Yes** -- Dev cannot build renderer without a schema spec |
| AD-12 | Component namespace | `sgraph-wf-*`, `send-wf-*`, `sg-*` | `sgraph-wf-*` (Section A.4) | **Yes** -- affects all component file names |
| AD-13 | IFD versioning | New major version (v0.2.0) or minor version (v0.1.7+) for workflow components | New major version v0.2.0 (Section A.4) | Soft -- can be decided after prototype works |
| AD-14 | Response key | Same key (R1), New key + PKI (R2), New key + out-of-band (R3) | R1 (same key) for prototype (Section A.7) | **Yes** -- affects response encryption flow |
| AD-15 | DataContext implementation | Observable object, event-based, framework | Lightweight observable object (~50 LOC) | **Yes** -- all components depend on it |
| AD-16 | Content type detection | `content_type_hint` metadata, or sniff after decryption | Both: hint first, sniff as fallback | Low -- affects download page branching logic |

**Decisions AD-11, AD-14, and AD-15 are blocking.** The Architect recommends the choices in this document. If the human approves, Dev can start immediately.

### C.3 Dependencies and Sequencing

```
Phase 1: Foundation (Architect delivers, ~1 session)
  [DONE] Schema format specification (this document, Section A.2)
  [DONE] Component library specification (this document, Section A.4)
  [DONE] Security model specification (this document, Section A.5)
  [DONE] Rendering pipeline specification (this document, Section A.3)

Phase 2: Core Infrastructure (Dev builds, ~2-3 sessions)
  DataContext implementation
  ComponentRegistry implementation
  WorkflowRenderer implementation
  ContentTypeDetector implementation
  ResponseSerializer implementation

Phase 3: Tier 1 Components (Dev builds, ~2-3 sessions)
  sgraph-wf-text-input
  sgraph-wf-text-area
  sgraph-wf-approval
  sgraph-wf-diff
  sgraph-wf-comment
  sgraph-wf-progress
  sgraph-wf-submit
  Layout components (vstack, hstack, card, header, repeat, label)

Phase 4: Integration (Dev + Architect, ~1-2 sessions)
  Modify download page to detect workflow content
  Wire WorkflowRenderer into download flow
  Wire ResponseSerializer into upload flow (response as new transfer)
  End-to-end encrypted round-trip test:
    Create workflow JSON --> encrypt --> upload --> download --> decrypt
    --> render UI --> interact --> serialise response
    --> encrypt --> upload --> download --> decrypt response --> verify

Phase 5: Translation Review Prototype (Dev + Translator, ~1 session)
  Build a specific translation review workflow JSON
  Test with real translation data
  Validate with the Translator role

Phase 6: Security Review (AppSec, ~1 session)
  Review the working prototype against Section A.5
  Test: Can a malicious schema exfiltrate data? (CSP, no network components)
  Test: Can a schema inject scripts? (declarative-only, no HTML parsing)
  Test: Can a schema cause resource exhaustion? (depth limits, size limits)
  Produce AppSec review document
```

**Total estimated effort: 7-10 Explorer sessions** from Architect approval to working prototype with security review.

### C.4 Relationship to Existing Priorities

The 16 Feb daily brief says existing priorities remain active:
- UX bugs (items 1-12 from 15 Feb brief)
- SA dashboard foundation
- Upload/download resilience research

The interactive workflow exploration is additive. It does NOT block or replace those workstreams. The Architect recommends:

1. **Dev** continues on UX bugs and SA dashboard (P1 items from 15 Feb)
2. **Architect** delivers this assessment (done) and moves to the 15 Feb blockers (A1: path-based routing, A2: cache service mapping) which are still outstanding
3. **Interactive workflow prototyping** begins after the P1 blockers from 15 Feb are cleared
4. The only immediate action from this assessment is **human review and approval of AD-11 through AD-16**

### C.5 Briefing Pack for the Interactive Workflow Prototype

Once human approves, the Architect and Librarian should create a briefing pack:

```
briefing-packs/active/interactive-workflow-prototype/
  BRIEF.md                         # This assessment, compressed
  schema-spec.md                   # The schema format from Section A.2
  component-spec.md                # The component library from Section A.4
  security-requirements.md         # The security model from Section A.5
  .issues/
    tasks.issues                   # Phase 2-6 tasks as issues
  code-context.md                  # Method streams for crypto.js, send-download.js,
                                   # Transfer__Service.py (the code paths the prototype touches)
```

This pack would enable a Dev agent to build the prototype with full context, even without reading the entire repo.

---

## Questions for Human

1. **AD-11 (Schema format):** Does the custom declarative schema in Section A.2 match your vision? Specifically, is the `bind_to` / `visible_when` / `repeat` approach the right level of expressiveness, or do you want more / less flexibility?

2. **AD-14 (Response key):** Confirm that using the same AES-256-GCM key for both the original workflow and the response is acceptable for the prototype. Forward secrecy (Option R2) would be a Villager-track enhancement.

3. **Content type convention:** Is `application/vnd.sgraph.workflow+json` the right content type identifier, or do you prefer something shorter (e.g., `sgraph/workflow`)?

4. **IFD versioning:** Should the workflow components live in a new major version (v0.2.0) or in the existing v0.1.x as a minor version? The Architect recommends v0.2.0 for clean separation but acknowledges this adds a new version folder.

5. **Briefing packs location:** Does `briefing-packs/` at the repo root work, or do you prefer a different location (e.g., under `team/`, under `library/`, or as `.packs/`)?

6. **LLM-generated schemas (from the brief):** The brief mentions that LLMs can dynamically generate UI schemas. Should the Architect research this now (P3 in the brief), or after the prototype proves the rendering pipeline works? The Architect recommends deferring -- validate the schema format first, then explore automated generation.

7. **Parallel priorities:** The 15 Feb brief has two Architect blockers outstanding (A1: path-based routing, A2: cache service mapping). Should the Architect complete those first, or does the interactive workflow assessment change the priority order?

---

## Recommended Next Steps

| # | Action | Owner | Priority | Dependency |
|---|--------|-------|----------|------------|
| 1 | Human reviews this assessment and approves/modifies AD-11 through AD-16 | Human | **P1** | None |
| 2 | Architect completes A2 (cache service mapping) from 15 Feb brief | Architect | **P1** | None (carry-forward blocker) |
| 3 | Architect completes A1 (path-based routing) from 15 Feb brief | Architect | **P1** | None (carry-forward blocker) |
| 4 | AppSec reviews the security model in Section A.5 | AppSec | **P2** | After human approves AD-11 |
| 5 | Dev begins DataContext + WorkflowRenderer implementation (Phase 2) | Dev | **P2** | After AD-11, AD-14, AD-15 approved |
| 6 | Librarian + Architect create the interactive workflow briefing pack | Librarian, Architect | **P2** | After human approves |
| 7 | Librarian + Architect create the CloudFront log pipeline briefing pack | Librarian, Architect | **P2** | None |
| 8 | Dev builds Tier 1 components (Phase 3) | Dev | **P2** | After Phase 2 complete |
| 9 | Dev + Architect integration test: encrypted workflow round-trip (Phase 4) | Dev, Architect | **P2** | After Phase 3 complete |
| 10 | AppSec security review of working prototype (Phase 6) | AppSec | **P2** | After Phase 4 complete |

**The Architect's immediate next actions are items 2 and 3 (carry-forward blockers from 15 Feb), with this assessment serving as the design foundation for when the interactive workflow prototyping begins.**

---

*Architect assessment complete. This document provides the architectural foundation for interactive encrypted data workflows, the briefing packs repo structure, and the phase sequencing for prototyping. Awaiting human review and approval of decisions AD-11 through AD-16 before prototyping begins.*
