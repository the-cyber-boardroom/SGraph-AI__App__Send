# Architect Review: Part-3 Briefs — Architecture Assessment

**version** v0.5.13
**date** 21 Feb 2026
**role** Architect
**type** Review — architecture assessment of v0.5.10 briefs

---

## Briefs Assigned to Architect

| Brief | Role | Key Architecture Decisions |
|-------|------|---------------------------|
| `architecture__browser-pod` | Lead | Service Worker-only model. Network interception + message API. IndexedDB persistence. |
| `architecture__github-store-and-ephemeral-compute` | Lead | Two storage classes. GitHub = source of truth. Ephemeral EC2. Fleet management API. |
| `architecture__identity-spectrum-and-friendly-search` | Lead | 5-level verification model. Client-side search within decrypted directories. |
| `brief__secrets-manager-dogfooding` | Consulted | SG/Send as its own secrets manager. 2 env vars per deployment. |
| `dev-brief__fastapi-ec2-management-routes` | Consulted | API-first EC2 management. osbot_aws wrappers. Budget controls. |
| `product-brief__data-rooms` | Consulted | Data room = GitHub repo + ephemeral compute. The product definition. |

---

## Architecture Observations

### 1. Browser Pod — Service Worker Only

The decision to use **only a Service Worker** (no Web Worker) is sound. The SW provides transparent fetch interception, persistence across page loads, and the message API — all in one component. The zero-code-change property for page developers is the killer feature.

**Open questions for further research:**
- Can a compromised main page read SW in-memory variables via debugging APIs?
- Can browser extensions intercept SW outbound fetch?
- Does crypto.subtle work in SW across all target browsers?
- What happens when SW update lifecycle triggers during an active session?

### 2. Two Storage Classes

The persistent/ephemeral split is clean and maps well to the existing Memory-FS abstraction:
- **Persistent** (GitHub): config, directory, branding, documents
- **Ephemeral** (S3): transfers, messages, temporary content with TTL

**Key architectural property**: when data moves from GitHub to S3, it's always encrypted. The repo may be cleartext; SG/Send storage never is.

### 3. Ephemeral Compute Model

EC2 instances as sealed boxes (port 443 inbound only, zero egress) is a strong security model. The Lambda orchestrator state machine for boot sequence is well-defined.

**Concern**: the boot sequence (30-50 seconds for EC2) is slow for first-access UX. The holding page mitigates this, but containers (ECS Fargate, Cloud Run) should be evaluated for faster startup. The architecture explicitly flags this as a future option.

### 4. Identity Spectrum

The 5-level verification model (self-asserted to KYC/government) is sound. The recommendation for client-side search only in Phase 1 preserves zero-knowledge. No architectural objections.

### 5. Secrets Manager

Elegant dogfooding. SG/Send's existing encryption and API are sufficient — no new routes needed for storing secrets. The cost comparison ($0.01/month vs $200/month at scale) is compelling.

---

## Cross-Brief Dependencies (Architect View)

```
Browser Pod ──────────► Admin Agent Chat ──────────► Team Site
     │                       │
     │                       ▼
     │                Agent Context Pages (GH Pages)
     │
     ▼
Secrets Manager ◄──── FastAPI EC2 Routes ◄──── GitHub-as-Store
                                                      │
                                                      ▼
                                              Data Room UX + Fleet
                                                      │
                                                      ▼
                                              Identity Spectrum
```

---

## Recommended Build Order (Architecture Perspective)

1. **Agent Context Pages** (GitHub Pages) — no code dependencies, enables everything else
2. **Secrets Manager** — dogfooding, small effort, high value for deployment
3. **FastAPI EC2 Routes** — wraps existing osbot_aws, enables data room compute
4. **Browser Pod (Phase 1)** — in-memory secrets, no IndexedDB yet
5. **Admin Agent Chat** — uses Browser Pod + Agent Context Pages
6. **Data Room UX** — uses EC2 Routes + Identity Spectrum
7. **Team Site** — uses Agent Context Pages + Browser Pod
