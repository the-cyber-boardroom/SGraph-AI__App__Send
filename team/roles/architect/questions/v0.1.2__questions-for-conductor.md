# v0.1.2 — Questions for Conductor

**Version:** v0.1.2
**Date:** 2026-02-09
**From:** Claude (Architect)
**To:** Human (Conductor)

---

## Q1: Memory-FS S3 Backend — Will You Provide the Class?

You mentioned "on Memory-FS S3 support, I will provide the class that we can use." Until that class is available, should I design the storage layer assuming only the Storage_FS interface methods (`file__save`, `file__str`, `file__bytes`, `file__exists`, `file__delete`, `files__paths`)? Or are there additional S3-specific methods (like pre-signed URL generation) that will be exposed through the Memory-FS abstraction?

**Why this matters:** Pre-signed URLs are currently central to the upload/download flow. If the storage abstraction doesn't expose pre-signed URL generation, the route handlers will need to know they're talking to S3 (which breaks the abstraction). The alternative is always proxying file bytes through Lambda, which works for small files but has the Lambda payload limit for larger ones.

## Q2: File Transfer — Pre-Signed URLs vs Server Proxy

The review says "we will need to both support the file save direct to S3 (or whatever storage was used)... this means that we will have to have endpoints to save and retrieve files."

**Clarification needed:** For the S3 deployment mode specifically, do we:
- **A)** Always proxy file bytes through Lambda endpoints (file upload → Lambda → Memory-FS → S3), or
- **B)** Use pre-signed URLs when the backend is S3 (bypassing Lambda for file bytes), and proxy through Lambda when the backend is in-memory/disk/other, or
- **C)** Always proxy through Lambda for now (MVP), and add pre-signed URL optimisation later as a deployment-specific enhancement?

**My recommendation:** Option C for MVP. This keeps the code simple (one path), works with all Memory-FS backends, and the 100MB limit is within Lambda's capabilities if we use streaming (though the 6MB API Gateway limit won't apply since we're using Lambda URL Functions which have a 20MB limit — still under 100MB). We'd need chunked upload for files over 20MB.

## Q3: Lambda URL Functions — Payload Size Limit

Lambda URL Functions have a **20MB payload limit** (for synchronous invocations). With max file size at 100MB, encrypted files will be ~100MB + 28 bytes. This exceeds the Lambda URL Function limit.

**Options:**
- **A)** Lower MVP max file size to 20MB (fits in Lambda URL Functions)
- **B)** Use chunked upload/download (client splits file, multiple requests)
- **C)** Keep pre-signed URLs for file bytes even in the Memory-FS model (hybrid approach)
- **D)** Use response streaming (Lambda URL Functions support streaming responses up to 20MB for response, but request payload is still limited)

**What's your preference?** This is the most critical open design question for the storage layer.

## Q4: Two Lambdas — Shared Code or Separate Packages?

The two Lambda functions (public + admin) — should they be:
- **A)** Same codebase, different entry points (two Mangum handlers, different route sets registered)
- **B)** Same codebase, single entry point, routes filtered by deployment config
- **C)** Separate packages entirely

**My recommendation:** Option A — same codebase, two entry points. The OSBot-Fast-API `Service__Fast_API` class can be instantiated twice with different route sets. This keeps services/schemas shared while enforcing the security boundary at the Lambda level.

## Q5: OSBot-Fast-API Auth — Key Name and Value

You mentioned OSBot-Fast-API "already supports a header/cookie based auth (each server can define a key-name and key-value)." For the admin Lambda:
- What header name should we use? (e.g., `X-Admin-Key`, `Authorization`)
- Is the key-value a single static string from an environment variable?
- Does this replace the `Bearer adm_xxx` pattern from v0.1.1, or supplement it?

## Q6: Service and Schema Naming

Confirmed naming patterns:
- Services: `Service__App__Send__Transfers`, `Service__App__Send__Tokens`, etc.
- Schemas: `Schema__App__Send__Transfer`, `Schema__App__Send__Token`, etc.
- Routes: `Routes__Transfers`, `Routes__Tokens`, etc.

**Question:** For the route tag (which becomes the URL prefix), should it be:
- `transfers` → `/transfers/create`, `/transfers/complete/{id}`, etc.
- `transfer` → `/transfer/create`, `/transfer/complete/{id}`, etc.
- Something else?

## Q7: Transfer Folder — Full Action Logging

You want "EVERYTHING that happened" stored in the transfer folder. My proposed structure (in the data model doc) captures:
- `meta.json` — transfer metadata
- `events/{event_id}.json` — one file per event (upload, download, complete, expire, etc.)
- `requests/{request_id}.json` — one file per HTTP request related to this transfer
- `payload.enc` — the encrypted file

**Question:** Should `requests/` log raw HTTP request data (method, path, headers, timestamp, response status)? Or a processed/anonymised version? This connects to the IP privacy research — we shouldn't store raw IPs in request logs if the zero-knowledge promise is to hold.

## Q8: The "Admin Panel" Mode for User Tools

You mentioned using the IFD "admin panel" mode for the user tools site (UI #2). Looking at the Issues-FS admin panel docs (`library/guides/development/ifd/ifd__issues-fs/`), this provides:
- EventBus-driven architecture
- Shell with navigation
- Debug panel (messages, events, API log, automation)
- Service singletons

**Question:** Should the user tools site share the same Shell/EventBus infrastructure as the admin site, or should they be independently built? (Same codebase with different configs, or separate codebases?)

## Q9: External Platform for Register Interest

You decided to move Register Interest to an external platform. Any preference among:
- **Buttondown** (privacy-focused, simple, API available)
- **Mailchimp** (well-known, free tier, heavy)
- **ConvertKit** (creator-focused)
- **Google Form** (zero cost, simple, but not privacy-aligned with our brand)
- **Simple mailto: link** (zero implementation, but no list management)

I'd lean towards Buttondown given our privacy-first brand, but this is your call.
