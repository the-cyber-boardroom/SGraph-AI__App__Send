# Incident Response: Access Token Leak via Shareable URLs

**Version:** v0.4.12
**Date:** 19 February 2026
**Roles:** AppSec + DevOps
**Severity:** P3-as-P1 (low blast radius due to beta, high severity by classification)
**Status:** HOTFIX APPLIED — Awaiting deployment

---

## Executive Summary

Access tokens were embedded as `?token=` query parameters in shareable URLs generated by the Send upload flow. Every shareable link created since v0.1.3 exposed the sender's authentication token to recipients, intermediary infrastructure, browser history, and HTTP Referer headers. The zero-knowledge encryption model prevented any exposure of file content, but the leaked tokens granted platform access (upload, token validation) and consumed sender quota on every recipient download.

A hotfix has been developed and committed covering 7 files across frontend, backend, and tests. Deployment and token rotation remain outstanding.

---

## Blast Radius Assessment

### Affected Versions

The bug was introduced in **v0.1.3** — the commit that added the `token` parameter to `buildCombinedUrl` and `buildLinkOnlyUrl` in `send-upload.js`. It was carried forward through all subsequent IFD versions:

| Version | Status |
|---------|--------|
| v0.1.3 | Affected (bug introduced) |
| v0.1.4 | Affected (carried forward) |
| v0.1.5 | Affected (IFD override, carried forward) |
| v0.1.6 | Affected (IFD override, carried forward) |

### What Was Exposed

Every shareable link generated since v0.1.3 was deployed contains the sender's access token as a `?token=` query parameter in the URL.

The token is in the **query string** (not the hash fragment). This distinction is critical:

| Exposure Vector | Token (`?token=`) | Decryption Key (`#fragment`) |
|-----------------|:------------------:|:----------------------------:|
| Sent to server in HTTP requests | YES | No |
| Visible in CloudFront access logs | YES | No |
| Visible in Lambda/API Gateway logs | YES | No |
| Visible in browser history | YES | Yes |
| Leaked via HTTP Referer headers to external resources | YES | No |
| Visible to intermediary proxies | YES | No |
| Accessible by link recipients | YES | Yes (by design) |

### What the Leaked Token Enables

- **Can** authenticate to the platform as the sender (upload files, validate tokens)
- **Can** consume uses from the sender's token quota (each recipient opening a link calls `validateToken`, deducting from the **sender's** allowance)
- **Cannot** decrypt other users' content — the zero-knowledge model protects file confidentiality regardless of token compromise
- **Cannot** access admin endpoints (admin tokens are separate)

### What Remains Safe

- **Decryption keys** — stored exclusively in the hash fragment, never sent to the server, never logged
- **File content** — encrypted with AES-256-GCM client-side; server only stores ciphertext
- **Other users' tokens** — each token is independent; compromising one does not compromise others

---

## Token Revocation Assessment

### Compromised Token Scope

All tokens that have been included in shareable URLs since v0.1.3 should be considered compromised. Specifically:

- **Affected tokens:** Any token whose holder uploaded a file and generated a shareable link during v0.1.3 through v0.1.6
- **Unaffected tokens:** Tokens that were never used for upload, or tokens issued after the hotfix deployment

### Recommendations

1. **Rotate all active tokens** after the hotfix is deployed to production
2. **Audit token usage logs** for anomalous activity (unexpected `validateToken` calls, uploads from unfamiliar IPs)
3. **Notify affected users** that their tokens were exposed and have been rotated

### Mitigating Factor

Since this is a **beta deployment with limited users**, the blast radius is contained. The number of compromised tokens and exposed links is small.

---

## Root Cause Analysis

### When Introduced

**v0.1.3** — the same commit that added download-side token validation.

### Design Intent

The developer wanted the download page to validate that the recipient has a valid token before allowing file retrieval. The implementation chose to carry the **sender's** token forward in the shareable URL so the download page could call `validateToken`.

### The Mistake

Using the sender's **authentication credential** as a **download authorization mechanism**. These are fundamentally different security concerns:

| Concern | Purpose | Who holds it |
|---------|---------|--------------|
| Authentication (sender token) | Proves sender identity, grants upload access | Sender only |
| Download authorization | Proves recipient is allowed to download | Recipient (or anonymous, by design) |

By conflating these two, the sender's credential was distributed to every recipient.

### Why It Was Not Caught

1. **No URL content tests** — No tests verify the format or content of shareable URLs. No test checks that sensitive data is absent from generated URLs.

2. **Code review focused on functionality** — Review validated that download-side token validation worked correctly, but did not assess whether the token was being leaked in the process.

3. **Existing test validated the leak** — The test `test__complete_returns_token_name` actively asserted that `token_name` was present in the complete endpoint response. This was a prerequisite for the leak — the test ensured the backend returned the token name so the frontend could embed it in the URL.

4. **Backend was intentionally complicit** — `Routes__Transfers.py` line 97 explicitly returned `result['token_name'] = token_name or ''` with the comment _"Include token name so UI can build share URL"_. This was a deliberate design choice, not an accidental inclusion.

### Contributing Factors

- No formal specification for what a shareable URL should contain
- No distinction in the codebase between sender credentials and download authorization
- No automated scanning for sensitive data in URL construction paths
- The IFD versioning model carried the bug forward into v0.1.4, v0.1.5, and v0.1.6 without re-evaluation

---

## Hotfix Applied

Seven files changed across frontend, backend, and tests.

### Frontend (4 files — all affected versions)

**1. `v0.1.3/components/send-upload/send-upload.js`**
- Removed `token` parameter from `buildCombinedUrl()`
- Removed `token` parameter from `buildLinkOnlyUrl()`
- Removed `tokenName` variable from the `startUpload()` flow

**2. `v0.1.4/components/send-upload/send-upload.js`**
- Same changes as v0.1.3

**3. `v0.1.5/components/send-upload/send-upload.js`**
- Same changes (IFD override applied to this version)

**4. `v0.1.6/components/send-upload/send-upload.js`**
- Same changes (IFD override applied to this version)

### Backend (1 file)

**5. `Routes__Transfers.py`**
- Removed `result['token_name'] = token_name or ''` from the `complete__transfer_id()` endpoint
- The server no longer returns the sender's token name in the transfer completion response

### Tests (1 file)

**6. `test_Routes__Transfers__with_tokens.py`**
- Renamed `test__complete_returns_token_name` to `test__complete_does_not_return_token_name`
- Assertions now verify that `token_name` is **NOT** present in the response body
- This test serves as a regression guard against reintroduction of the leak

### Download Side: No Change Needed

The download components (`send-download.js`) already handle the case where `this.tokenName` is null. The existing `if (this.tokenName)` guard skips token validation when no token is present in the URL. Downloads will continue to work without a token in the URL.

---

## Preventive Measures

| # | Measure | Priority | Status | Owner |
|---|---------|----------|--------|-------|
| 1 | **URL sanitisation test** — automated test that verifies shareable URLs contain ONLY `transfer_id` and key in hash fragment, with no query parameters containing sensitive data | P1 | Implemented in this hotfix | QA / Dev |
| 2 | **CI/CD URL scanner** — regex check in CI pipeline for `token`/`key`/`secret`/`password` patterns in any URL string literal or URL construction code | P2 | Backlog | DevOps |
| 3 | **Shareable URL contract** — formal specification defining exactly what a share URL must and must not contain, maintained alongside the API contracts | P2 | Backlog | Architect |
| 4 | **Referer header audit** — verify that no sensitive URL parameters leak via the `Referer` header on the download page; consider adding `Referrer-Policy: no-referrer` | P2 | Backlog | AppSec |
| 5 | **Server log audit** — check CloudFront access logs and Lambda execution logs for exposed tokens from the affected period; determine if log rotation has already purged them | P1 | Requires DevOps | DevOps |
| 6 | **Credential/authorization separation** — establish a clear architectural boundary between sender authentication tokens and download authorization mechanisms | P2 | Backlog | Architect |

---

## Connection to Architecture

The Architect's response (same date) identified a `compare_and_swap` primitive for `Storage_FS` to fix token race conditions (AD-23). This incident reinforces the need for a **proper download authorization model** that is architecturally separate from sender authentication.

Key architectural implications:

- **Sender tokens must never leave the sender's session.** The token is a credential, not a capability to be forwarded.
- **Download authorization requires its own mechanism** — either anonymous access (current post-hotfix behaviour), a separate download token, or a channel-based model.
- **The channel abstraction** proposed for encrypted chat (AD-20) may provide the right pattern: download authorization via channel membership rather than forwarded sender credentials.
- **The zero-knowledge model held.** Despite the token leak, file content was never compromised. This validates the core architectural decision to keep decryption keys in the hash fragment.

---

## Timeline

| Time | Event |
|------|-------|
| v0.1.3 deployment | Bug introduced — sender's access token added to shareable URLs as `?token=` query parameter |
| v0.1.4 deployment | Bug carried forward in IFD version |
| v0.1.5 deployment | Bug carried forward in IFD override |
| v0.1.6 deployment | Bug carried forward in IFD override |
| 19 Feb 2026, ~13:50 | Human discovers token in shareable link during routine use |
| 19 Feb 2026, ~14:00 | Incident classified as **P3-as-P1** (low user impact due to beta, high severity by security classification) |
| 19 Feb 2026 | Root cause identified — token embedding traced to v0.1.3 `send-upload.js` and `Routes__Transfers.py` |
| 19 Feb 2026 | Hotfix developed — 7 files changed across 4 frontend versions, 1 backend route, 1 test file |
| 19 Feb 2026 | Hotfix committed and pushed |
| TBD | Hotfix deployed to production |
| TBD | Token rotation for affected users |
| TBD | Server log audit completed |

---

## Lessons Learned

1. **Security properties need negative tests.** Testing that something works is insufficient. We must also test that sensitive data does NOT appear where it should not. The URL sanitisation test added in this hotfix is a template for this pattern.

2. **Authentication credentials must never be forwarded.** When a feature requires authorization at a different boundary (download vs. upload), a new authorization mechanism must be designed — never reuse the existing credential.

3. **IFD versioning amplifies bugs.** Because each IFD version is a standalone copy, a bug introduced in one version is carried forward into every subsequent version. This is a known trade-off of IFD; the mitigation is to apply fixes as overrides to all affected versions.

4. **Comments that explain "why" can reveal design flaws.** The comment _"Include token name so UI can build share URL"_ was honest documentation of the wrong design. Comments like this should trigger security review.

5. **The zero-knowledge architecture limited the blast radius.** Even with tokens fully exposed, no file content was compromised. This validates the fundamental architectural choice.

---

## Status: HOTFIX APPLIED — Awaiting Deployment

**Next actions:**
1. Deploy hotfix to production (Villager team / DevOps)
2. Rotate all active tokens for affected users
3. Audit server logs for exposed tokens (DevOps — preventive measure #5)
4. Close this incident after deployment and rotation are confirmed
