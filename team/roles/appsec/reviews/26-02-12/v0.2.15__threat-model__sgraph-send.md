# Threat Model — SGraph Send MVP

**Role:** AppSec
**Version:** v0.2.15
**Date:** 12/02/2026
**Classification:** Internal — Security Sensitive

---

## 1. System Overview

SGraph Send is a zero-knowledge encrypted file sharing service. Files are encrypted client-side using AES-256-GCM via the Web Crypto API before upload. The server stores only encrypted ciphertext. Decryption keys never leave the sender's browser and are shared out-of-band.

### 1.1 Architecture Summary

- **Two Lambda Functions**: User (public, no auth) and Admin (auth required)
- **Lambda Function URLs**: Direct HTTPS endpoints, no API Gateway
- **Storage**: In-memory (Memory-FS) — pluggable backends (memory, disk, S3)
- **Frontend**: Vanilla JS + Web Components (IFD methodology)
- **Encryption**: AES-256-GCM, Web Crypto API, client-side only

---

## 2. Data Flow Diagrams

### 2.1 Upload Flow

```
Sender Browser                    User Lambda (Public)              Memory-FS
     |                                    |                            |
     |  1. Select file                    |                            |
     |  2. Generate AES-256-GCM key       |                            |
     |  3. Encrypt file (IV + ciphertext) |                            |
     |                                    |                            |
     |--POST /transfers/create----------->|                            |
     |    {file_size_bytes,               |  4. Generate transfer_id   |
     |     content_type_hint}             |     (secrets.token_hex(6)) |
     |<---{transfer_id, upload_url}-------|  5. Store metadata-------->|
     |                                    |                            |
     |--POST /transfers/upload/{id}------>|                            |
     |    [encrypted binary payload]      |  6. Store payload--------->|
     |<---{status: uploaded}--------------|                            |
     |                                    |                            |
     |--POST /transfers/complete/{id}---->|                            |
     |                                    |  7. Set status=completed-->|
     |<---{download_url, transparency}----|                            |
     |                                    |                            |
     |  8. Display download link          |                            |
     |  9. Display decryption key         |                            |
     |     (key NEVER sent to server)     |                            |
```

### 2.2 Download Flow

```
Recipient Browser                 User Lambda (Public)              Memory-FS
     |                                    |                            |
     |  1. Open download URL              |                            |
     |     (?id=transfer_id)              |                            |
     |                                    |                            |
     |--GET /transfers/info/{id}--------->|                            |
     |                                    |  2. Lookup metadata------->|
     |<---{status, file_size, created_at}-|                            |
     |                                    |                            |
     |  3. Paste decryption key           |                            |
     |                                    |                            |
     |--GET /transfers/download/{id}----->|                            |
     |                                    |  4. Retrieve payload------>|
     |<---[encrypted binary payload]------|  5. Log download event---->|
     |                                    |                            |
     |  6. Import key from base64url      |                            |
     |  7. Extract IV (first 12 bytes)    |                            |
     |  8. Decrypt with AES-256-GCM       |                            |
     |  9. Save decrypted file            |                            |
```

### 2.3 Admin Flow

```
Admin Browser                     Admin Lambda (Auth Required)
     |                                    |
     |--GET /admin/--------------------->|
     |    (with auth credentials)         |
     |<---Admin UI static assets----------|
     |                                    |
     |  (Admin API endpoints TBD)         |
```

---

## 3. Trust Boundaries

### Boundary 1: Browser <-> Internet
- **Nature:** Untrusted network transport
- **Protection:** TLS (via Lambda URL HTTPS)
- **Threats:** MitM (mitigated by TLS), DNS hijacking, CDN compromise

### Boundary 2: Internet <-> Lambda Function URL
- **Nature:** Public endpoint, no intermediary (no API Gateway, no WAF, no CloudFront)
- **Protection:** Lambda URL built-in TLS, HTTPS-only
- **Threats:** DDoS, brute-force, payload abuse, no rate limiting
- **CRITICAL GAP:** No WAF, no rate limiting, no request filtering

### Boundary 3: Lambda <-> Memory-FS Storage
- **Nature:** In-process storage (currently) or AWS SDK calls (future S3)
- **Protection:** Lambda execution role IAM (for S3), in-memory isolation (for Memory-FS)
- **Threats:** Memory exhaustion (current), S3 bucket misconfiguration (future)

### Boundary 4: Admin Lambda Authentication Boundary
- **Nature:** API key or IAM-based auth
- **Protection:** `enable_api_key` is set (not False like User Lambda)
- **Threats:** Key leakage, brute-force on auth endpoint

### Boundary 5: Client-Side Crypto Boundary
- **Nature:** All encryption/decryption happens within the browser's Web Crypto API
- **Protection:** Web Crypto API is a hardware-backed browser primitive
- **Threats:** Compromised browser, malicious browser extensions, compromised JS assets

---

## 4. Attack Surfaces

### 4.1 Public Lambda URL Endpoints (User Lambda)

| Endpoint | Method | Auth | Input | Attack Surface |
|---|---|---|---|---|
| `/transfers/create` | POST | None | JSON body | Injection via content_type_hint, negative file_size_bytes |
| `/transfers/upload/{id}` | POST | None | Binary body + path param | Memory exhaustion (no size limit), injection via transfer_id |
| `/transfers/complete/{id}` | POST | None | Path param | State manipulation, injection via transfer_id |
| `/transfers/info/{id}` | GET | None | Path param | Transfer enumeration, injection via transfer_id |
| `/transfers/download/{id}` | GET | None | Path param + headers | Bandwidth DoS, enumeration, UA injection |
| `/send/*` | GET | None | Static files | Path traversal (mitigated by Starlette), cache poisoning |
| `/info` | GET | None | None | Version/config disclosure |

### 4.2 Admin Lambda URL Endpoints

| Endpoint | Method | Auth | Attack Surface |
|---|---|---|---|
| `/admin/*` | GET | API key | Auth bypass, key brute-force |
| `/info` | GET | API key | Version/config disclosure |

### 4.3 Client-Side Attack Surface

| Component | Attack Surface |
|---|---|
| `crypto.js` | Key generation quality, IV reuse, algorithm choice |
| `api-client.js` | SSRF (if baseUrl is manipulated), response injection |
| `send-upload.js` | XSS via file name (mitigated by escapeHtml), DOM manipulation |
| `send-download.js` | XSS via URL parameters (transfer_id from query string), DOM manipulation |

---

## 5. STRIDE Analysis

### 5.1 Spoofing

| Threat | Likelihood | Impact | Mitigation Status |
|---|---|---|---|
| Attacker impersonates a legitimate sender | Medium | Low | NOT MITIGATED — no sender authentication. By design (public service), but means abuse tracking depends on IP hashing (which is broken — Vuln-5, Vuln-10) |
| Attacker creates transfers from spoofed IP | Medium | Medium | NOT MITIGATED — sender_ip is hardcoded to '' (Vuln-10) |
| Attacker spoofs admin credentials | Low | Critical | PARTIALLY MITIGATED — API key auth exists on Admin Lambda |

### 5.2 Tampering

| Threat | Likelihood | Impact | Mitigation Status |
|---|---|---|---|
| Attacker modifies encrypted payload in transit | Low | High | MITIGATED — TLS on Lambda URLs, AES-GCM includes authentication tag |
| Attacker replaces stored ciphertext | Low | High | MITIGATED — in-memory storage is not externally accessible. RISK with S3 backend if bucket ACLs are wrong |
| Attacker modifies transfer metadata | Low | Medium | MITIGATED — in-memory storage. RISK with S3 backend |
| Attacker tampers with JS assets on CDN/static serving | Low | Critical | NOT MITIGATED — no Subresource Integrity (SRI), no Content-Security-Policy headers |

### 5.3 Repudiation

| Threat | Likelihood | Impact | Mitigation Status |
|---|---|---|---|
| Sender denies uploading malicious content | Medium | Medium | NOT MITIGATED — sender IP is hardcoded to '' (Vuln-10), IP hash is unsalted (Vuln-5) |
| Downloader denies downloading content | Low | Low | PARTIALLY MITIGATED — download events are logged with ip_hash and user_agent, but ip_hash is unsalted |

### 5.4 Information Disclosure

| Threat | Likelihood | Impact | Mitigation Status |
|---|---|---|---|
| Server accesses plaintext file content | N/A | N/A | MITIGATED BY DESIGN — server only stores ciphertext. Zero-knowledge verified (see Section 6) |
| Transfer ID enumeration reveals metadata | Medium | Medium | NOT MITIGATED — no rate limiting (Vuln-4), 48-bit ID entropy (Vuln-7) |
| Error messages leak internal details | Medium | Low | NOT MITIGATED — exception details returned to callers (Vuln-8), transfer_id reflected in errors (Vuln-1) |
| IP addresses recovered from hashes | High | Medium | NOT MITIGATED — unsalted SHA-256 is trivially reversible (Vuln-5) |

### 5.5 Denial of Service

| Threat | Likelihood | Impact | Mitigation Status |
|---|---|---|---|
| Memory exhaustion via large upload | High | High | NOT MITIGATED — no upload size limit (Vuln-3) |
| Lambda concurrency exhaustion via mass requests | High | High | NOT MITIGATED — no rate limiting (Vuln-4) |
| In-memory storage exhaustion | High | High | NOT MITIGATED — no limit on number of transfers, no expiry/cleanup |
| Cost amplification via repeated downloads | Medium | Medium | NOT MITIGATED — no download rate limiting |

### 5.6 Elevation of Privilege

| Threat | Likelihood | Impact | Mitigation Status |
|---|---|---|---|
| User accesses admin endpoints | Low | High | MITIGATED — separate Lambda functions with different auth configs |
| Path traversal to access other files | Low | Medium | MITIGATED — Starlette StaticFiles handles path normalization |
| Lambda execution role over-permissioned | Unknown | High | UNKNOWN — needs verification by DevOps (see Task-4/issue.json) |

---

## 6. Zero-Knowledge Verification

### 6.1 Claims Verified

| Claim | Verified | Evidence |
|---|---|---|
| Encryption happens in browser | YES | `crypto.js` uses `window.crypto.subtle.encrypt()` — Web Crypto API, client-side only |
| AES-256-GCM algorithm | YES | `{ name: 'AES-GCM', length: 256 }` in `generateKey()` |
| Fresh random IV per encryption | YES | `window.crypto.getRandomValues(new Uint8Array(12))` in `encryptFile()` |
| Key never sent to server | YES | Key is generated, used for encryption, exported as base64url, and displayed to user. Never included in any API call. `ApiClient` methods do not transmit the key. |
| Server never receives file name | YES | `createTransfer()` sends only `file_size_bytes` and `content_type_hint`. File name is never in any API payload. |
| Server stores only ciphertext | YES | `upload_payload()` stores raw `payload_bytes` — which is the output of `encryptFile()` (IV + ciphertext + auth tag) |
| Decryption key displayed to user for out-of-band sharing | YES | Upload component displays `keyString` with copy button. Guidance tells user to share via separate channel. |

### 6.2 Claims With Caveats

| Claim | Status | Caveat |
|---|---|---|
| IP addresses are hashed | PARTIALLY TRUE | IP hashing exists in `Transfer__Service.hash_ip()` but is unsalted (trivially reversible — Vuln-5) and sender IP is never actually captured (hardcoded to '' — Vuln-10) |
| Backend data is non-sensitive | MOSTLY TRUE | Encrypted payloads are non-sensitive by design. However, metadata (file_size_bytes, timestamps, ip_hashes, user_agent) is stored and could be used for traffic analysis |
| No server-side logging of keys | TRUE | Verified — no logging statements in Transfer__Service or Routes__Transfers reference keys. FastAPI default logging does not log request bodies for binary uploads. |

### 6.3 Zero-Knowledge Gaps

1. **content_type_hint is metadata leakage**: The original file's MIME type is sent to the server and stored. While not the file name, it reveals the type of file being shared (e.g., application/pdf, image/png). This is a minor privacy leak.
2. **file_size_bytes is metadata leakage**: The original file size is sent and stored. Combined with content_type_hint, this narrows the set of possible files significantly.
3. **Download URL contains transfer_id in plaintext**: The download URL `?id={transfer_id}` is visible in browser history, server logs, and referrer headers.

---

## 7. Key Threat Scenarios

### 7.1 Scenario: Malicious File Distribution

**Threat:** An attacker uses SGraph Send to distribute malware or illegal content at scale.

**Attack path:**
1. Attacker creates thousands of transfers (no rate limiting)
2. Uploads encrypted malware to each
3. Distributes download links + keys on external channels
4. No sender attribution (IP not captured)
5. No content inspection possible (by design — zero-knowledge)

**Risk level:** HIGH
**Current mitigations:** None
**Recommended:** Rate limiting, sender IP capture, transfer expiry, abuse reporting mechanism

### 7.2 Scenario: Service Denial via Resource Exhaustion

**Threat:** An attacker exhausts Lambda memory, storage, or concurrent execution capacity.

**Attack path:**
1. Send many POST /transfers/create requests (no rate limit)
2. For each, upload maximum payload size (no size limit)
3. Never complete transfers — they remain in memory as "pending" forever
4. Lambda memory is exhausted; service becomes unresponsive

**Risk level:** HIGH
**Current mitigations:** None
**Recommended:** Upload size limits, rate limiting, transfer expiry/cleanup, Lambda concurrency limits

### 7.3 Scenario: Transfer Enumeration and Metadata Harvesting

**Threat:** An attacker discovers active transfers and harvests metadata.

**Attack path:**
1. Enumerate GET /transfers/info/{hex_id} for sequential hex values (no rate limit)
2. 200 responses reveal: transfer_id, status, file_size_bytes, created_at, download_count
3. Attacker builds a database of all active transfers with their metadata
4. This metadata reveals usage patterns, popular transfer sizes, timing

**Risk level:** MEDIUM
**Current mitigations:** 48-bit transfer ID randomness
**Recommended:** Increase ID entropy (UUID4), rate limiting, consider requiring a download token

### 7.4 Scenario: Stored XSS via Admin Dashboard

**Threat:** Attacker injects malicious scripts that execute when admin views transfer data.

**Attack path:**
1. Create transfer with content_type_hint containing `<script>` tags
2. Download a transfer with a malicious User-Agent header
3. When admin views transfer metadata/events in admin UI, scripts execute
4. Attacker exfiltrates admin session cookies or performs actions as admin

**Risk level:** MEDIUM (conditional on admin UI rendering)
**Current mitigations:** None in backend; admin UI not yet implemented
**Recommended:** Input validation/sanitization on all stored strings, CSP headers on admin UI

---

## 8. Recommendations by Priority

### P0 — Critical (fix before public launch)

1. **Vuln-1/Vuln-2:** Validate transfer_id (regex: `^[a-f0-9]{12}$`), remove user input from error messages
2. **Vuln-3:** Enforce maximum upload payload size
3. **Vuln-4:** Add rate limiting (even basic IP-based throttling)

### P1 — High (fix in next sprint)

4. **Vuln-5:** Add salt to IP hashing (HMAC-SHA256 with server secret)
5. **Vuln-7:** Increase transfer ID to UUID4 (128 bits)
6. **Vuln-9:** Validate content_type_hint and file_size_bytes
7. **Vuln-10:** Capture sender IP from Request object
8. **Vuln-6:** Sanitize User-Agent before storage
9. Add transfer expiry and cleanup mechanism
10. Add Content-Security-Policy headers

### P2 — Medium (address in roadmap)

11. **Vuln-8:** Generic error messages in Lambda handlers
12. Add WAF or CloudFront in front of Lambda URLs
13. Add Subresource Integrity (SRI) for static JS assets
14. Add abuse reporting mechanism
15. Implement download tokens separate from transfer IDs

---

## 9. Assumptions and Open Questions

### Assumptions
- Lambda execution role has been scoped to minimum required permissions (unverified — see Task-3/issue.json)
- Admin Lambda API key is managed via environment variable or AWS Secrets Manager (unverified)
- GitHub Actions CI/CD pipeline uses least-privilege permissions (unverified — see Task-4/issue.json)

### Open Questions (tracked in Issues FS)
- What CORS origins are configured on the User Lambda? (Task-3/issue.json)
- How is the Admin API key provisioned and rotated? (Task-3/issue.json)
- Are GitHub Actions pinned to SHA commits? (Task-4/issue.json)
- Is there dependency scanning in CI? (Task-4/issue.json)

---

## Appendix A: Encryption Flow Verification

The client-side encryption flow in `crypto.js` is sound:

1. **Key Generation:** `crypto.subtle.generateKey({name: 'AES-GCM', length: 256}, true, ['encrypt', 'decrypt'])` — uses the browser's CSPRNG
2. **IV Generation:** `crypto.getRandomValues(new Uint8Array(12))` — 96-bit random IV from CSPRNG, fresh per encryption
3. **Encryption:** `crypto.subtle.encrypt({name: 'AES-GCM', iv}, key, fileData)` — standard AES-256-GCM with authentication tag
4. **Wire Format:** `[12-byte IV][ciphertext + 16-byte auth tag]` — standard, well-defined
5. **Key Export:** `exportKey('raw', key)` then base64url encoding — clean, standard
6. **Key Import:** `importKey('raw', base64urlToBytes(str), 'AES-GCM', ...)` — symmetric to export

**No issues found in the cryptographic implementation.** The Web Crypto API handles all primitives correctly. IV is never reused (fresh random per encrypt call). The authentication tag protects integrity.

## Appendix B: Frontend Security Review

### send-upload.js
- **XSS Protection:** Uses `escapeHtml()` method that creates a text node via `div.textContent = str; return div.innerHTML` — this is a correct and safe HTML escaping pattern
- **File Name Handling:** File name is displayed using `this.escapeHtml(this.selectedFile.name)` — properly escaped
- **DOM Manipulation:** Uses `innerHTML` assignment, but all dynamic values are passed through `escapeHtml()` first
- **Event Cleanup:** Proper `disconnectedCallback()` removes all event listeners — no memory leaks

### send-download.js
- **Transfer ID from URL:** `new URLSearchParams(window.location.search).get('id')` — standard, no injection risk (value is used in API calls, not DOM)
- **XSS Protection:** Same `escapeHtml()` pattern as upload component
- **Key Input:** Key is read from input field, used only for `SendCrypto.importKey()` — no injection path
- **File Save:** Uses `URL.createObjectURL(blob)` and programmatic click — standard, safe pattern
- **Download File Name:** Hardcoded to `'download'` — correct, server does not know original name

### Common Frontend Observations
- No Content-Security-Policy headers enforced (would need to be set by Lambda/server)
- No Subresource Integrity (SRI) hashes on script tags
- `document.execCommand('copy')` fallback is deprecated but harmless
