# v0.3.2 -- AppSec Action Plan: Explorer Next Steps

**Version:** v0.3.2
**Date:** 14 February 2026
**Role:** AppSec (Application Security)
**Team:** Explorer
**Context:** Action plan responding to [v0.3.2 daily brief](../../../../humans/dinis_cruz/briefs/02/14/v0.3.2__daily-brief__sgraph-send-14-feb-2026.md) -- security assessment of unencrypted mode, large file transfer, external partner access, and handover preparation
**Continues from:** [v0.3.0 AppSec review](v0.3.0__response-to-daily-brief__14-feb.md) -- Admin UI security review (AU-1 through AU-4, 28 cumulative action items)
**Explorer role definition:** [v0.3.2 Explorer role](../../../../humans/dinis_cruz/briefs/02/14/v0.3.2__role-definition__explorer.md)
**Wardley Maps context:** [v0.3.2 Wardley Maps](../../../../humans/dinis_cruz/briefs/02/14/v0.3.2__briefs__wardley-maps-in-sgraph-project.md)
**Threat model baseline:** [v0.2.15 threat model](../26-02-12/v0.2.15__threat-model__sgraph-send.md)

---

## Executive Summary

The v0.3.2 brief introduces three new security-relevant workstreams: an unencrypted file transfer mode (P3), large file transfer capability (P2), and external partner access to project-aware bots (P2). It also marks the transition to the Explorer/Villager team structure, which creates a formal handover boundary that requires a security checklist.

This action plan provides:
1. A security assessment and conditional recommendation on unencrypted mode
2. Security requirements for large file transfer architecture
3. A threat analysis of external partner bot access
4. Status update on Admin UI security items from v0.3.0
5. A handover security checklist for the Villager team
6. An updated risk register incorporating all v0.3.2 risks
7. Carry-forward of all open security items

**Bottom line:** Unencrypted mode is conditionally acceptable with strict guardrails. Large file transfer introduces new integrity and DoS risks that need early architectural decisions. External partner bot access is the highest-risk new item and needs scope limitation before deployment.

---

## 1. Unencrypted Mode Security Assessment (P3)

### 1.1 The Proposal

The brief asks whether SGraph Send should offer a mode where files are sent without client-side encryption. The use case is large, non-sensitive files where encryption adds friction (key management, browser-side processing overhead) for zero perceived benefit.

### 1.2 Threat Model Impact

Introducing unencrypted mode changes the threat model fundamentally. The current [v0.2.15 threat model](../26-02-12/v0.2.15__threat-model__sgraph-send.md) is built on the assumption that the server stores only ciphertext. Specifically:

| Current Assumption | Impact of Unencrypted Mode |
|---|---|
| **Server never sees plaintext** | VIOLATED -- server stores and serves plaintext files |
| **Content inspection impossible (by design)** | VIOLATED -- server can now inspect stored content |
| **No file names on server** | AT RISK -- the SGMETA envelope currently wraps file names into the encrypted payload. Without encryption, the metadata packaging approach must be redesigned. |
| **Backend data is non-sensitive/non-confidential** | VIOLATED -- plaintext files may contain anything, including PII, credentials, or illegal content |
| **No decryption keys to protect** | N/A -- no keys generated for unencrypted transfers |
| **Zero-knowledge architecture** | PARTIALLY VIOLATED -- server has knowledge of unencrypted file content |

### 1.3 New Threats Introduced

| Threat | Likelihood | Impact | Notes |
|---|---|---|---|
| **UT-1: Server-side data breach exposes plaintext** | MEDIUM | HIGH | Currently a breach exposes only ciphertext (useless without keys). With unencrypted mode, a breach exposes actual file content. |
| **UT-2: Insider access to plaintext files** | MEDIUM | HIGH | Lambda operators, S3 bucket admins, and anyone with storage access can read unencrypted files. |
| **UT-3: Legal liability for stored content** | MEDIUM | HIGH | If the server stores plaintext, the operator may have legal obligations to scan for illegal content (CSAM, copyright), which is not required for encrypted-only storage. |
| **UT-4: Malware distribution via plaintext** | MEDIUM | MEDIUM | Unencrypted files can be scanned by middleboxes, CDNs, or antivirus -- but this also means the server is knowingly hosting potentially malicious content in plaintext. |
| **UT-5: Metadata leakage amplified** | HIGH | MEDIUM | Without encryption, content_type_hint + file_size_bytes + unencrypted content = full file disclosure. Currently these metadata fields are acceptable because the payload is encrypted. |
| **UT-6: User confusion about security state** | MEDIUM | MEDIUM | Users may not understand when encryption is on vs off. A user who thinks they are sending securely but accidentally opted out would have a false sense of security. |

### 1.4 Risk Analysis

**Residual risk of unencrypted mode: MEDIUM-HIGH** without guardrails, **MEDIUM-LOW** with the conditions below.

The primary concern is not technical -- it is positional and legal. SGraph Send's entire value proposition is "zero-knowledge encrypted file sharing." Introducing unencrypted mode:

1. **Removes the blanket claim** that the server never sees plaintext. Every security page, trust badge, marketing claim, and compliance assertion must now be qualified with "unless the user opted out."
2. **Creates a stored-content liability** that does not exist today. The server currently has no obligation to inspect content because it literally cannot. With unencrypted mode, this defence evaporates.
3. **Complicates the threat model** -- every security review must now consider two parallel trust models: zero-knowledge (encrypted) and standard (unencrypted).

### 1.5 Recommendation: CONDITIONAL APPROVAL

AppSec **conditionally approves** unencrypted mode, subject to the following mandatory conditions:

| # | Condition | Rationale | Priority |
|---|---|---|---|
| **UC-1** | **Encrypted is always the default.** The UI must never default to unencrypted. The user must take an explicit, deliberate action to disable encryption. | Secure-by-default posture | P0 |
| **UC-2** | **Unencrypted mode requires an explicit warning.** Before sending without encryption, the user must acknowledge a clear warning: "This file will be stored on the server without encryption. Anyone with access to the server can read it." | Informed consent | P0 |
| **UC-3** | **Unencrypted transfers are visually distinct.** The download page, the share link, the admin UI -- all must clearly indicate whether a transfer is encrypted or not. No ambiguity. | Prevent confusion (UT-6) | P0 |
| **UC-4** | **Unencrypted mode is a server-side flag, not just a client-side skip.** The transfer metadata must include an `encrypted: true/false` field. The server must know whether a transfer is encrypted. | Audit, compliance, transparency | P1 |
| **UC-5** | **Unencrypted transfers can be admin-disabled.** The admin must be able to disable unencrypted mode globally (e.g., an environment variable or admin setting). | Enterprise compliance | P1 |
| **UC-6** | **Unencrypted mode is documented as a separate trust model.** The threat model, security page, and all compliance documentation must clearly describe the two modes and their respective guarantees. | Transparency | P1 |
| **UC-7** | **Unencrypted transfers have shorter default TTL.** Because plaintext on the server is a higher-risk state, unencrypted transfers should expire faster than encrypted ones. | Reduce exposure window | P2 |
| **UC-8** | **No SGMETA envelope for unencrypted files.** If the file is not encrypted, the SGMETA envelope (which embeds the filename into the encrypted payload) must not be used. File names should either be sent as separate metadata or omitted. | SGMETA is designed for encrypted payloads | P1 |

### 1.6 Architecture Guidance for Unencrypted Mode

The brief says this should be "pluggable, configurable, not a fundamental architecture change." From an AppSec perspective, the cleanest approach is:

1. **Client decides.** The encryption/no-encryption decision is made in the browser (just as encryption is today).
2. **Client signals the server.** The `POST /transfers/create` request includes an `encrypted: boolean` field.
3. **Server stores the flag.** The transfer metadata includes `encrypted: true/false`.
4. **Server enforces admin policy.** If admin has disabled unencrypted mode, the server rejects `encrypted: false` requests with a 403.
5. **Download page adapts.** If `encrypted: true`, the download page requests the decryption key. If `encrypted: false`, it downloads directly.
6. **Transparency panel shows the mode.** The transparency data already lists what is stored -- it must now also show whether the payload is encrypted or plaintext.

This keeps the architecture change minimal: one new boolean in the create request, one new field in metadata, one conditional branch in the UI.

---

## 2. Large File Transfer Security

### 2.1 Context

The brief identifies large file transfer (1 GB+) as a key differentiator. This requires chunked/multipart uploads, retry capability, and checksum verification. Each of these introduces security considerations.

### 2.2 Chunked Upload Security

| Concern | Risk | Requirement |
|---|---|---|
| **Chunk ordering** | Attacker replaces or reorders chunks | **LF-1:** Each chunk must include a sequence number and the server must validate ordering |
| **Chunk integrity** | Corruption during upload | **LF-2:** Each chunk must include a checksum (SHA-256 or CRC-32) that the server verifies before accepting |
| **Chunk reassembly** | Server reassembles incorrectly | **LF-3:** After all chunks are uploaded, the server must verify a whole-file checksum provided by the client |
| **Orphaned chunks** | Incomplete uploads consume storage | **LF-4:** Chunked uploads must have a timeout. If not completed within N minutes, orphaned chunks are cleaned up |
| **Memory/storage DoS** | Attacker starts many chunked uploads, never completes | **LF-5:** Rate limit chunked upload initiation. Limit concurrent chunked uploads per IP/token |
| **Resume token security** | Resume tokens allow an attacker to hijack an upload | **LF-6:** Resume tokens must be cryptographically random and tied to the original upload session (IP hash + transfer_id) |

### 2.3 Checksum Verification Architecture

For encrypted transfers, checksum verification has a subtlety: the client encrypts chunks locally, so the server only sees ciphertext chunks. The verification flow should be:

```
CLIENT                              SERVER
  |                                    |
  | 1. Encrypt chunk_N                 |
  | 2. SHA-256(encrypted_chunk_N)      |
  |                                    |
  |-- Upload chunk_N + checksum ------>|
  |                                    | 3. SHA-256(received_bytes)
  |                                    | 4. Compare checksums
  |                                    | 5. Accept or reject
  |                                    |
  | ... all chunks uploaded ...        |
  |                                    |
  | 6. SHA-256(all_encrypted_chunks)   |
  |-- Complete + whole_file_checksum ->|
  |                                    | 7. SHA-256(reassembled_payload)
  |                                    | 8. Compare whole-file checksums
  |                                    | 9. Mark complete or reject
```

**Key point:** For encrypted transfers, all checksums are computed over the ciphertext, not the plaintext. The server never needs to see plaintext to verify integrity.

For unencrypted transfers (if approved per Section 1), checksums are computed over the plaintext content. The same mechanism works, but the implications are different -- the server has the content and the checksum.

### 2.4 Encryption Overhead for Large Files

The brief mentions encryption overhead as a motivator for unencrypted mode. AppSec notes:

- AES-256-GCM via Web Crypto API is hardware-accelerated on modern browsers (AES-NI). Encryption throughput is typically 1-3 GB/s on modern hardware. The overhead for a 5 GB file is seconds, not minutes.
- The actual bottleneck for large files is **reading the file into memory** (FileReader API) and **network upload speed**, not encryption.
- Chunked encryption (encrypt each chunk independently, each with its own IV) would allow streaming and avoid loading the entire file into memory.
- **Recommendation:** Before introducing unencrypted mode for performance reasons, measure actual encryption overhead on target devices. It may be negligible compared to network transfer time.

### 2.5 Summary of Large File Security Requirements

| # | Requirement | Priority |
|---|---|---|
| **LF-1** | Chunk sequence validation | P1 |
| **LF-2** | Per-chunk checksum verification | P1 |
| **LF-3** | Whole-file checksum verification after reassembly | P1 |
| **LF-4** | Orphaned chunk cleanup (timeout-based) | P1 |
| **LF-5** | Rate limit on chunked upload initiation | P1 |
| **LF-6** | Cryptographically random resume tokens, session-bound | P1 |
| **LF-7** | Measure encryption overhead before using it to justify unencrypted mode | P2 |

---

## 3. External Partner Access Security

### 3.1 Context

The brief proposes giving a design agency access to a "project-aware Claude bot" that has project context loaded (briefs, role definitions, design requirements). The brief also explores Slack and WhatsApp bot integrations.

### 3.2 Threat Analysis

| Threat | Likelihood | Impact | Notes |
|---|---|---|---|
| **EP-1: Sensitive project data exposure** | HIGH | MEDIUM | The bot has access to project briefs, role definitions, architecture docs, and security reviews. If an external partner asks the right questions, they could learn about internal security posture, vulnerabilities, and architectural weaknesses. |
| **EP-2: Prompt injection via external input** | MEDIUM | MEDIUM | If the bot processes unfiltered input from external partners, it could be manipulated into revealing information outside its intended scope. |
| **EP-3: Scope creep** | HIGH | LOW | External partners may ask questions beyond design (e.g., "how does the encryption work?" or "what's the deployment architecture?") and the bot may answer from its full context. |
| **EP-4: Data exfiltration via bot** | LOW | HIGH | If the bot can read files from the repo, an external partner could ask for specific file contents -- including security-sensitive files like threat models or incident analyses. |
| **EP-5: Slack/WhatsApp channel compromise** | MEDIUM | HIGH | If bot communications happen via Slack or WhatsApp, a compromise of those channels exposes all bot interactions, which may include project details. |
| **EP-6: No audit trail** | MEDIUM | MEDIUM | Conversations with the bot may not be logged, making it impossible to detect inappropriate information disclosure after the fact. |

### 3.3 Requirements for External Partner Bot Access

| # | Requirement | Priority |
|---|---|---|
| **EP-R1** | **Scope limitation.** The external partner bot must have access ONLY to documents relevant to the design brief: design requirements, brand guidelines, UI specs, public-facing product descriptions. It must NOT have access to: security reviews, threat models, incident analyses, architecture internals, deployment configurations, admin API documentation, or any file under `team/roles/appsec/`, `team/roles/devops/`, or `.github/`. | P0 |
| **EP-R2** | **Document classification.** Before enabling external bot access, all project documents must be classified as `external-safe` or `internal-only`. Only `external-safe` documents are loaded into the external bot context. | P0 |
| **EP-R3** | **Audit logging.** All interactions with the external bot must be logged with timestamps, the question asked, and the response given. Logs must be stored internally and reviewed periodically. | P1 |
| **EP-R4** | **Prompt engineering guardrails.** The external bot's system prompt must explicitly instruct it to refuse questions about security, infrastructure, deployment, API keys, authentication mechanisms, or internal team processes. | P1 |
| **EP-R5** | **Separate bot instance.** The external partner bot must be a completely separate instance from any internal project bots. No shared context, no shared session. | P0 |
| **EP-R6** | **Review before launch.** AppSec must review the external bot's context documents and system prompt before it is made available to external partners. | P1 |
| **EP-R7** | **Slack/WhatsApp channel isolation.** If bot integrations use Slack or WhatsApp, the external channel must be separate from internal team channels. Bot messages must not leak internal channel content. | P1 |

### 3.4 Recommendation

External partner bot access is viable but requires careful scoping. The highest risk is inadvertent disclosure of security-sensitive project information. The mitigation is straightforward: give the external bot a curated, reviewed subset of project documents, not the full repo context.

**Recommended approach:** Create a dedicated `library/external/` directory containing only documents intended for external consumption. The external bot loads from this directory only. This is a simple, auditable boundary.

---

## 4. Admin UI Security Status

### 4.1 Status of v0.3.0 Mandatory Requirements

The v0.3.0 review ([v0.3.0 AppSec review](v0.3.0__response-to-daily-brief__14-feb.md)) established four mandatory requirements for the admin UI:

| # | Requirement | v0.3.0 Priority | Status | Notes |
|---|---|---|---|---|
| **AU-1** | API key in `sessionStorage` only | P0 | **NEEDS VERIFICATION** | Architecture approved, implementation needs code review |
| **AU-2** | Login page exempt from API key auth | P0 | **NEEDS VERIFICATION** | Approach A approved, implementation needs code review |
| **AU-3** | All server data rendered via `textContent` | P0 | **NEEDS VERIFICATION** | Pattern defined, implementation needs audit of all admin UI components |
| **AU-4** | Security headers on admin Lambda responses | P1 | **OPEN** | CSP, X-Frame-Options, Referrer-Policy, HSTS, Cache-Control, Permissions-Policy |

### 4.2 Note on Explorer/Villager Boundary

The admin UI is classified as "Genesis" stage in the [Wardley Map](../../../../humans/dinis_cruz/briefs/02/14/v0.3.2__briefs__wardley-maps-in-sgraph-project.md). This means it remains in Explorer territory. The AU-1 through AU-4 requirements are security fundamentals that must be verified before any handover to Villager -- they are part of the handover checklist (Section 5).

### 4.3 Recommendation: RF-29 Follow-Up

RF-29 from v0.3.0 (API key auth in browser) was the primary concern. The session-based architecture (`sessionStorage` + login page) was approved. Before the admin UI moves beyond Genesis:

1. **Code audit** of all admin UI JavaScript files to verify AU-1 (no hardcoded keys), AU-3 (textContent rendering)
2. **Manual test** of the login flow to verify AU-2 (key never appears in URL, history, or logs)
3. **Header verification** on admin Lambda responses to verify AU-4

These are Explorer-phase verification tasks. They do not require Villager-level hardening.

---

## 5. Handover Security Checklist

### 5.1 Purpose

When the Explorer team hands components to the Villager team, security items must be explicitly verified. The Villager team's mandate is to stabilise and deploy -- they should not inherit undiscovered security issues.

### 5.2 Checklist: Required Before Handover

The following items must be verified for each component before it transitions from Explorer to Villager:

#### A. Encryption Integrity

| # | Item | Applies To | Verification Method |
|---|---|---|---|
| **HC-A1** | Server never stores plaintext | User Lambda, Storage | Code review of `Transfer__Service.upload_payload()` -- verify payload is raw bytes from client (already encrypted client-side) |
| **HC-A2** | No decryption keys in server logs | User Lambda | Search all logging statements for key-related strings |
| **HC-A3** | No file names in server storage | User Lambda, Storage | Code review of `Transfer__Service.create_transfer()` -- verify no filename field |
| **HC-A4** | Download URL does not contain decryption key | User UI | Verify hash fragment architecture (key in `#`, not `?`) |
| **HC-A5** | AES-256-GCM implementation verified | User UI (crypto.js) | Already verified in [v0.2.15 threat model](../26-02-12/v0.2.15__threat-model__sgraph-send.md), Appendix A |

#### B. Authentication and Authorization

| # | Item | Applies To | Verification Method |
|---|---|---|---|
| **HC-B1** | Admin Lambda requires API key on all routes | Admin Lambda | Test: unauthenticated requests return 401 |
| **HC-B2** | User Lambda token validation works | User Lambda | Test: requests without valid token return 401 when token enforcement is enabled |
| **HC-B3** | Admin endpoints not accessible via User Lambda URL | Both Lambdas | Test: `/tokens/*` on User Lambda URL returns 404 |
| **HC-B4** | API key not exposed in admin UI source | Admin UI | Automated scan of admin UI source files for key patterns |

#### C. Input Validation

| # | Item | Applies To | Verification Method |
|---|---|---|---|
| **HC-C1** | Transfer ID validated (format check) | User Lambda | Code review: `Safe_Str__Id` type enforcement on transfer_id parameters |
| **HC-C2** | Content type hint validated | User Lambda | Code review: verify `content_type_hint` is validated or sanitised |
| **HC-C3** | File size limit enforced | User Lambda | Test: upload exceeding limit is rejected |
| **HC-C4** | No user input reflected in error messages without sanitisation | Both Lambdas | Code review of HTTPException detail strings |

#### D. Security Headers

| # | Item | Applies To | Verification Method |
|---|---|---|---|
| **HC-D1** | `Referrer-Policy: no-referrer` | Both Lambdas | Response header check |
| **HC-D2** | `Content-Security-Policy` | Both Lambdas | Response header check |
| **HC-D3** | `X-Content-Type-Options: nosniff` | Both Lambdas | Response header check |
| **HC-D4** | `X-Frame-Options: DENY` | Both Lambdas | Response header check |
| **HC-D5** | `Strict-Transport-Security` | Both Lambdas | Response header check |

#### E. Data Protection

| # | Item | Applies To | Verification Method |
|---|---|---|---|
| **HC-E1** | IP addresses hashed with daily-rotating salt | User Lambda | Code review of `hash_ip()` -- currently uses unsalted SHA-256 (Vuln-5 from threat model, STILL OPEN) |
| **HC-E2** | Sender IP actually captured from request | User Lambda | Code review of Routes__Transfers.create() -- currently hardcoded to `''` (Vuln-10, STILL OPEN) |
| **HC-E3** | User-Agent sanitised before storage | User Lambda | Code review of download event logging |
| **HC-E4** | Transfer expiry mechanism exists | User Lambda, Storage | Verify cleanup/TTL on transfers |

#### F. Operational Security

| # | Item | Applies To | Verification Method |
|---|---|---|---|
| **HC-F1** | Upload size limit configured | User Lambda | Configuration check |
| **HC-F2** | Rate limiting active | User Lambda | Configuration check or test |
| **HC-F3** | Lambda execution role minimum-privilege | Both Lambdas | IAM policy review |
| **HC-F4** | No hardcoded secrets in code | Entire codebase | Automated scan |
| **HC-F5** | Dependencies pinned to exact versions | pyproject.toml | Configuration check |

### 5.3 Current Status Against Checklist

Based on code review of `Transfer__Service.py`, `Routes__Transfers.py`, `crypto.js`, and `send-upload.js`:

| Category | Pass | Fail / Open | Notes |
|---|---|---|---|
| A. Encryption Integrity | HC-A1 through HC-A5 | None | Zero-knowledge architecture is sound |
| B. Auth & AuthZ | HC-B1, HC-B2 | HC-B3 (untested), HC-B4 (unverified) | Need regression test for admin endpoint isolation |
| C. Input Validation | HC-C1 (partial -- uses Safe_Str__Id) | HC-C2, HC-C3, HC-C4 | Content type not validated, no upload size limit, transfer_id reflected in errors |
| D. Security Headers | None verified | HC-D1 through HC-D5 | All security headers need implementation |
| E. Data Protection | None | HC-E1, HC-E2, HC-E3, HC-E4 | IP hashing unsalted, sender IP not captured, no transfer expiry |
| F. Operational | None verified | HC-F1 through HC-F5 | Rate limiting, size limits, and dependency pinning all open |

**Handover readiness: NOT READY.** The encryption integrity (Category A) is solid. Authentication (Category B) is mostly in place. Categories C through F have significant gaps. These must be addressed by the Explorer team before handover to the Villager team.

---

## 6. Risk Register Update

### 6.1 New Risks from v0.3.2

| Risk ID | Risk | Source | Likelihood | Impact | Current Status | Owner |
|---|---|---|---|---|---|---|
| **RF-31** | Unencrypted mode dilutes zero-knowledge positioning | v0.3.2 brief (P3) | HIGH | MEDIUM | PROPOSED -- conditional approval with UC-1 through UC-8 | AppSec, Architect, Advocate |
| **RF-32** | Unencrypted files create stored-content liability | v0.3.2 brief (P3) | MEDIUM | HIGH | PROPOSED -- mitigated by UC-4, UC-5, UC-7 | AppSec, GRC, DPO |
| **RF-33** | External partner bot leaks internal security information | v0.3.2 brief (P2) | HIGH | MEDIUM | PROPOSED -- mitigated by EP-R1 through EP-R7 | AppSec, Architect |
| **RF-34** | Large file chunked uploads enable storage DoS | v0.3.2 brief (P2) | HIGH | HIGH | PROPOSED -- mitigated by LF-4, LF-5 | AppSec, Architect |
| **RF-35** | Chunk manipulation during large file upload | v0.3.2 brief (P2) | LOW | HIGH | PROPOSED -- mitigated by LF-1, LF-2, LF-3 | AppSec, Architect |
| **RF-36** | Explorer/Villager handover misses security items | v0.3.2 team structure | MEDIUM | HIGH | PROPOSED -- mitigated by handover checklist (Section 5) | AppSec, Conductor |
| **RF-37** | Slack/WhatsApp bot channel compromise exposes project data | v0.3.2 brief (P2) | LOW | HIGH | PROPOSED -- mitigated by EP-R5, EP-R7 | AppSec, Architect |

### 6.2 Updated Risk Summary

| Category | Previous (v0.3.0) | New (v0.3.2) | Total |
|---|---|---|---|
| Carried risks (RF-1 through RF-30) | 30 | 0 | 30 |
| New risks (RF-31 through RF-37) | 0 | 7 | 7 |
| **Total active risks** | | | **37** |

### 6.3 Risk Priority Distribution

| Priority | Count | Key Items |
|---|---|---|
| P0 (Critical) | 6 | Referrer-Policy, admin endpoint isolation, dependency pinning, AU-1, AU-2, AU-3 |
| P1 (High) | 17 | Security headers, rate limiting, IP hashing salt, upload size limits, large file security, external partner scope |
| P2 (Medium) | 14 | Unencrypted mode conditions, key expiry, session timeout, constant-time lookups |

---

## 7. Carries Forward

### 7.1 Open Security Items from v0.3.0 and Earlier

All 28 action items from the [v0.3.0 cumulative list](v0.3.0__response-to-daily-brief__14-feb.md) remain active. None have been confirmed as resolved since the v0.3.0 review.

#### P0 Items (6 -- BLOCKING for production)

| # | Action | Source | Status |
|---|---|---|---|
| 1 | `Referrer-Policy: no-referrer` on all responses (both Lambdas) | v0.2.24 | **CARRIED** |
| 2 | Regression test: admin endpoints 404 on public Lambda URL | v0.2.40 M1 | **CARRIED** |
| 3 | Pin exact dependency versions in Lambda config | v0.2.40 M2 | **CARRIED** |
| 4 | API key in `sessionStorage` only (AU-1) | v0.3.0 | **CARRIED -- needs verification** |
| 5 | Login page exempt from API key auth (AU-2) | v0.3.0 | **CARRIED -- needs verification** |
| 6 | All server data rendered via `textContent` (AU-3) | v0.3.0 | **CARRIED -- needs verification** |

#### P1 Items (13)

| # | Action | Source |
|---|---|---|
| 7 | Security headers on admin Lambda (AU-4) | v0.3.0 |
| 8 | `history.replaceState` after decryption | v0.2.24 |
| 9 | Strict CSP headers (both Lambdas) | v0.2.33 |
| 10 | SRI on script/stylesheet references | v0.2.33 |
| 11 | Cross-prefix isolation test | v0.2.40 M3 |
| 12 | Audit `Send__Cache__Client` -- no admin_storage() | v0.2.40 M4 |
| 13 | Document architecture boundary in code | v0.2.40 M5 |
| 14 | Rate limiting on token resolution | v0.2.40 M6 |
| 15 | Salt the cache hash for token namespace | v0.2.33 |
| 16 | `textContent` not `innerHTML` for user UI data | v0.2.24 |
| 17 | CI check for hardcoded API keys in UI source (AU-R1) | v0.3.0 |
| 18 | `Cache-Control: no-store` on admin API responses (AU-R2) | v0.3.0 |
| 19 | XSS test with script payload in token name (AU-R6) | v0.3.0 |

#### P2 Items (9)

| # | Action | Source |
|---|---|---|
| 20 | Key expiry in localStorage (user UI) | v0.2.33 |
| 21 | Constant-time token lookup | v0.2.33 |
| 22 | Token probing audit trail | v0.2.33 |
| 23 | Per-user token migration | v0.2.24 |
| 24 | Separate S3 bucket for cache service extraction | v0.2.40 |
| 25 | Monitor Lambda cold start impact | v0.2.40 |
| 26 | Pin all `pyproject.toml` deps to exact versions | v0.2.40 |
| 27 | Log failed auth attempts on admin Lambda (AU-R4) | v0.3.0 |
| 28 | Session timeout (clear sessionStorage after inactivity) (AU-R5) | v0.3.0 |

### 7.2 New Action Items from v0.3.2

| # | Action | Priority | Source |
|---|---|---|---|
| 29 | Implement UC-1 through UC-8 conditions if unencrypted mode proceeds | P1 (UC-1 through UC-3 are P0 for unencrypted mode) | Section 1 |
| 30 | Implement LF-1 through LF-7 for large file transfer architecture | P1 | Section 2 |
| 31 | Implement EP-R1 through EP-R7 before external partner bot goes live | P0 for EP-R1, EP-R2, EP-R5 | Section 3 |
| 32 | Complete handover checklist verification (Section 5) before any Villager handover | P0 for handover | Section 5 |
| 33 | Classify all project documents as external-safe or internal-only | P1 | Section 3 |
| 34 | Measure encryption overhead on target devices before using performance as justification for unencrypted mode | P2 | Section 2 |
| 35 | Review external bot context documents and system prompt before launch | P1 | Section 3 |

### 7.3 Updated Totals

| Priority | Previous (v0.3.0) | New (v0.3.2) | Total |
|---|---|---|---|
| P0 | 6 | 1 (handover checklist as blocking gate) | 7 |
| P1 | 13 | 5 | 18 |
| P2 | 9 | 1 | 10 |
| **Total** | **28** | **7** | **35** |

---

## 8. Explorer AppSec Priorities

As an Explorer-team AppSec role, the immediate priorities for the next iteration are:

1. **Verify AU-1 through AU-3** on the admin UI code (P0 carry-forward)
2. **Provide security input to the Architect** on large file transfer design (LF-1 through LF-7)
3. **Define the external-safe document boundary** (EP-R1, EP-R2) before the design agency bot is created
4. **Review the unencrypted mode architecture** when/if the Architect designs it (UC-1 through UC-8)
5. **Prepare the handover checklist** for the first Villager handover -- encryption, upload/download, S3 storage, and token system are the candidates

The Explorer team should not attempt to close all P1/P2 items before handover. The handover checklist (Section 5) defines the minimum security bar. P1 and P2 items that are Villager-territory (performance, monitoring, deployment hardening) will transition with the component.

---

*AppSec action plan complete. This document covers all security-relevant items from the v0.3.2 daily brief and provides a carry-forward register from all previous reviews (v0.2.24, v0.2.33, v0.2.40, v0.3.0). The next scheduled review will be triggered by the Architect's response to the large file transfer and unencrypted mode design tasks.*
