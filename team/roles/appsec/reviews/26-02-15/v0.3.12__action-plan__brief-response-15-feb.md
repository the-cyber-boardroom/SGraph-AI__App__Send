# v0.3.12 -- AppSec Action Plan: Brief Response (15 Feb 2026)

**Version:** v0.3.12
**Date:** 15 February 2026
**Role:** AppSec (Application Security)
**Team:** Explorer
**Brief:** [v0.3.10 daily brief](../../../../humans/dinis_cruz/briefs/02/15/v0.3.10__daily-brief__explorer-team-15-feb-2026.md)
**Previous action plan:** [v0.3.2 action plan](../26-02-14/v0.3.2__action-plan__explorer-next-steps.md) -- unencrypted mode, large file transfer, external partner access, handover checklist
**Master index:** [v0.3.10 master index](../../librarian/reviews/26-02-15/v0.3.10__master-index__daily-brief-15-feb.md)
**Threat model baseline:** [v0.2.15 threat model](../26-02-12/v0.2.15__threat-model__sgraph-send.md)

---

## Executive Summary

The v0.3.10 brief assigns AppSec one explicit task: the **three-word key concept security review** (P3, but blocks Dev implementation per D040). This review is the core deliverable of this action plan. In addition, several new features in the brief have security implications that require AppSec commentary even though they are not explicitly assigned to this role.

This action plan provides:

1. Acknowledged tasks from the brief
2. Carryover status from the v0.3.2 action plan
3. A full security review of the three-word key concept (entropy, brute-force, trademark, risk classification, recommendation)
4. Security implications of new features introduced in the brief
5. Prioritised recommendations for AppSec reviews

**Bottom line:** Three-word keys are **conditionally viable** for a specific, clearly bounded use case (convenience sharing of non-sensitive files) but must never be the default and must never replace the full AES-256-GCM key for users who need real security. The entropy is insufficient to resist targeted brute-force, and the scheme must be designed to make offline attacks infeasible. Several new features in the brief (path-based routing, navigation guards, cache browser, upload progress events) introduce secondary security considerations that AppSec should review as they are implemented.

---

## 1. Acknowledged Tasks

### 1.1 From the Brief

| # | Task | Priority | Status | Notes |
|---|------|----------|--------|-------|
| 20 | Three-word key concept security review | **P3** | **ADDRESSED IN THIS DOCUMENT** (Section 3) | Blocks Dev implementation per D040 and Architect technical design |

The brief explicitly states: *"Dev: don't implement yet -- this needs the security review first."* This action plan provides that review.

### 1.2 From the Master Index Dependency Graph

```
AppSec: three-word key security review (#20)
    |
    +---> Architect: technical feasibility (#20)
    +---> Dev: implementation (BLOCKED until review complete)
```

This document unblocks the Architect to proceed with technical design. The Architect should read Section 3 before producing their feasibility analysis.

---

## 2. Carryover from v0.3.2

### 2.1 Status of v0.3.2 Action Items

The [v0.3.2 action plan](../26-02-14/v0.3.2__action-plan__explorer-next-steps.md) established 35 action items across 7 sections. None have been confirmed as resolved since that review. The full carry-forward register remains active.

| Category | v0.3.2 Items | Status | Notes |
|----------|-------------|--------|-------|
| **Unencrypted mode** (UC-1 to UC-8) | 8 conditions | **DORMANT** | Unencrypted mode is P3 in v0.3.2, not mentioned in v0.3.10 brief. Conditions remain valid if/when feature proceeds. |
| **Large file transfer** (LF-1 to LF-7) | 7 requirements | **ACTIVE -- RELEVANT** | Upload/download resilience research is P2 in v0.3.10 brief. LF-1 through LF-7 apply directly to the Architect's research output. |
| **External partner access** (EP-R1 to EP-R7) | 7 requirements | **DORMANT** | Design agency brief exists but bot access not yet implemented. Requirements remain valid. |
| **Admin UI security** (AU-1 to AU-4) | 4 requirements | **NEEDS VERIFICATION** | Admin UI continues to evolve (new SA dashboard, cache browser, navigation links). AU-1 through AU-4 verification is increasingly urgent. |
| **Handover checklist** (HC-A through HC-F) | 30 items | **ACTIVE** | Handover readiness was "NOT READY" at v0.3.2. No change. |
| **P0 carry-forward** (6 items) | 6 blocking items | **STILL OPEN** | Referrer-Policy, admin endpoint isolation test, dependency pinning, AU-1, AU-2, AU-3 |
| **P1 carry-forward** (13 items) | 13 items | **STILL OPEN** | Security headers, rate limiting, IP hashing salt, upload size limits |
| **P2 carry-forward** (9 items) | 9 items | **STILL OPEN** | Key expiry, constant-time lookup, token probing audit trail |

### 2.2 What Changed Between v0.3.2 and v0.3.10

The v0.3.10 brief introduces the **Server Analytics dashboard** and **path-based routing**, which expands the admin UI attack surface. The three items most affected:

1. **AU-3 (textContent rendering)** -- now applies to SA dashboard views (cache browser, Lambda dashboard, CloudFront viewer), not just the original admin console. Every new view that renders server data must use `textContent`, not `innerHTML`.
2. **AU-4 (security headers)** -- now applies to SA dashboard path-based routes. All `/admin/dashboard/*` responses must include security headers.
3. **AU-1 (sessionStorage for API key)** -- the SA dashboard will make API calls to fetch cache data, Lambda metrics, and CloudFront logs. The API key must flow correctly through all these calls without being leaked into URLs, logs, or browser history.

### 2.3 New Carry-Forward Items from This Review

See Section 5 for the updated action items added by this review.

---

## 3. Security Review: Three-Word Keys

### 3.1 Concept Summary

The brief proposes offering a mode where users can share files using **three memorable words** as a passphrase (e.g., `sunset-bicycle-ocean`) instead of a complex encryption key. The three words could be used to:

- **Derive the cache/transfer ID** (find the file on the server)
- **Derive the decryption key** (decrypt the file)
- Or a split approach: three words for lookup, separate mechanism for decryption

### 3.2 Entropy Analysis

#### 3.2.1 Dictionary Size and Entropy Calculation

The entropy of a three-word passphrase depends entirely on the dictionary size and the selection method.

| Dictionary Size | Entropy per Word | Three-Word Entropy | Equivalent Key Length |
|-----------------|-----------------|-------------------|----------------------|
| 1,000 words | ~10 bits | ~30 bits | Less than DES (56-bit) |
| 2,048 words (BIP-39 standard) | 11 bits | 33 bits | Less than DES |
| 4,096 words | 12 bits | 36 bits | Less than DES |
| 7,776 words (Diceware) | ~12.9 bits | ~38.8 bits | Less than DES |
| 10,000 words | ~13.3 bits | ~39.9 bits | Less than DES |
| 50,000 words | ~15.6 bits | ~46.8 bits | Less than DES |
| 100,000 words | ~16.6 bits | ~49.8 bits | Approaching DES |

**Key finding:** Even with a 100,000-word dictionary, three words provide approximately 50 bits of entropy. This is **206 orders of magnitude weaker** than a 256-bit AES key (which has 256 bits of entropy). For context:

- **30 bits (1,000-word dictionary):** ~1 billion combinations. A modern GPU can enumerate this in **seconds**.
- **33 bits (2,048-word dictionary):** ~8.6 billion combinations. Enumerable in **seconds to minutes**.
- **39 bits (Diceware 7,776-word dictionary):** ~470 billion combinations. Enumerable in **minutes to hours**.
- **50 bits (100,000-word dictionary):** ~1 quadrillion combinations. Enumerable in **hours to days** with dedicated hardware.

#### 3.2.2 Comparison to Current Architecture

The current SGraph Send architecture uses:

- **Transfer ID:** `secrets.token_hex(6)` = 12 hex characters = 48 bits of entropy (for lookup)
- **Decryption key:** AES-256-GCM = 256 bits of entropy (for decryption)

The three-word scheme at its best (large dictionary) provides roughly equivalent entropy to the current transfer ID for the **lookup** function, but is catastrophically weaker for the **decryption** function.

### 3.3 Brute-Force Attack Surface Analysis

#### 3.3.1 Attack Scenarios

| Attack | Scenario | Online/Offline | Feasibility |
|--------|----------|----------------|-------------|
| **BF-1: Online enumeration of transfer IDs** | Attacker tries three-word combinations against the server's download endpoint to find valid transfers | Online | **FEASIBLE** -- rate-limited only by server. With 2,048-word dictionary: 8.6B combinations. At 1,000 requests/second: ~100 days. At 100,000 req/s (distributed): ~1 day. |
| **BF-2: Offline key derivation** | If three words derive the decryption key, and the attacker has the ciphertext (from the server or interception), they can enumerate all possible keys offline | Offline | **HIGHLY FEASIBLE** -- no rate limiting possible. GPU can try billions of derivations per second. All dictionaries up to 100K words crackable in hours. |
| **BF-3: Combined lookup + decrypt** | If three words derive BOTH lookup and key, a single successful online guess gives the attacker everything | Online | **FEASIBLE** -- same as BF-1 but with full compromise on success |
| **BF-4: Dictionary reduction** | Attacker guesses the dictionary used, reduces search space. Common English words cluster around ~3,000 frequently used words. | Either | **HIGH IMPACT** -- users choosing words (rather than having words assigned) will cluster around common words, reducing effective entropy significantly |

#### 3.3.2 Key Insight: Online vs. Offline Matters Enormously

The security of the three-word scheme depends critically on whether the attacker must go through the server (online) or can attack independently (offline):

- **If three words only derive the lookup ID** (and the decryption key is separate): the attacker must enumerate online against the server. The server can rate-limit, block after N failures, and require CAPTCHAs. This is **defensible** with server-side controls.

- **If three words derive the decryption key** (and the attacker has the ciphertext): the attacker works offline. No rate limiting is possible. The key derivation function (KDF) can add computational cost (e.g., Argon2, scrypt, PBKDF2 with high iteration count), but the fundamental entropy is too low. Even with Argon2 at 1 second per derivation, a 2,048-word dictionary is cracked in ~100 days on a single machine -- and this parallelises trivially.

- **If three words derive BOTH**: this is the worst case. Online enumeration finds the file AND decrypts it in one shot.

### 3.4 Architecture Recommendation: Separated Concerns

**AppSec strongly recommends separating lookup and decryption:**

| Function | Mechanism | Rationale |
|----------|-----------|-----------|
| **File lookup** | Three-word passphrase -> server-side hash -> transfer lookup | Defensible with server-side rate limiting, account lockout, CAPTCHA |
| **File decryption** | Full AES-256-GCM key, shared out-of-band (current approach) | Maintains zero-knowledge guarantee. Server never sees the key. |

This means the three-word scheme is a **convenience feature for file lookup only**, not a replacement for the encryption key. The user experience would be:

1. Sender uploads a file (encrypted as usual with a full AES-256-GCM key)
2. Sender gets a three-word lookup code AND a decryption key
3. Sender tells recipient: "Go to send.sgraph.ai, enter `sunset-bicycle-ocean`, and use this key: `[full key]`"
4. Recipient enters three words -> server finds the file -> recipient enters key -> browser decrypts

This preserves the zero-knowledge guarantee while making the "find the file" step more human-friendly.

#### 3.4.1 Alternative: Three Words for Everything (Reduced Security Mode)

If the product team decides that some users want three words for BOTH lookup AND decryption (the "convenience over security" use case), the following conditions are mandatory:

| # | Condition | Rationale |
|---|-----------|-----------|
| **TWK-1** | This mode is explicitly labelled as "Convenience Mode" or "Easy Share" -- never as "Secure" or "Encrypted" | Users must understand the trade-off |
| **TWK-2** | A clear warning is displayed: "This sharing method uses a simple passphrase. It is not suitable for sensitive, confidential, or personal files." | Informed consent |
| **TWK-3** | The key derivation function must use Argon2id with high memory and iteration parameters (minimum: 256 MB memory, 3 iterations, parallelism 4) | Maximise cost of offline brute-force |
| **TWK-4** | The dictionary must be at least 7,776 words (Diceware standard) and words must be server-assigned (not user-chosen) | Prevent dictionary reduction attacks (BF-4) |
| **TWK-5** | Server-side rate limiting: maximum 5 failed lookup attempts per IP per hour, with exponential backoff | Mitigate online enumeration (BF-1) |
| **TWK-6** | Transfers using three-word keys must have a shorter TTL (maximum 24 hours, default 4 hours) | Reduce the window for brute-force |
| **TWK-7** | Three-word transfers must be limited to files under 50 MB | Prevent use for high-value large file transfers where the security gap matters most |
| **TWK-8** | The server must log all failed three-word lookups and alert on enumeration patterns | Detection of active attacks |
| **TWK-9** | A per-transfer salt must be used in the key derivation (the three words alone do not determine the key -- the server adds a salt stored with the transfer metadata) | The attacker must know both the three words AND the salt, which requires a successful online lookup first, converting offline attacks to online attacks |
| **TWK-10** | The transparency panel must clearly show that this transfer uses "passphrase-derived encryption" and not "full-strength encryption" | Transparency |

#### 3.4.2 The Salt Trick (TWK-9): Converting Offline to Online

TWK-9 deserves special attention because it is the single most important architectural decision for the "three words for everything" variant:

```
Without salt:
    key = KDF(three_words)
    Attacker with ciphertext can brute-force offline.

With server-side salt:
    key = KDF(three_words || server_salt)
    Attacker must first retrieve salt from server (online request).
    Server can rate-limit salt retrieval = all attacks become online.
    Server can require the three-word lookup to succeed before returning salt.
    Failed lookups are logged and rate-limited.
```

This transforms an offline brute-force problem (unsolvable at low entropy) into an online enumeration problem (solvable with rate limiting). The trade-off is that the server now holds a value (the salt) that is necessary for decryption -- this is a **partial departure from zero-knowledge**, but the server still never holds the key itself.

### 3.5 Trademark and Patent Analysis

#### 3.5.1 What3Words

**What3Words** is a UK company (what3words Ltd) that has:

- **Trademarked** the name "what3words" and the "///" prefix notation in multiple jurisdictions
- **Patented** their specific system for dividing the world into 3m x 3m squares and assigning three-word addresses (patents in US, UK, EU, and others)
- **Aggressively enforced** their IP -- they have sent cease-and-desist letters to open-source projects that replicate their geographic grid system

**Risk assessment for SGraph Send:**

| Aspect | Risk | Notes |
|--------|------|-------|
| Using the name "What3Words" or "W3W" | **HIGH** -- trademark infringement | Do not use. Use our own branding. |
| Using "///" prefix notation | **MEDIUM** -- potentially trademark | Avoid. Use our own delimiter (hyphen, space, dot). |
| Using three words to identify a geographic location | **HIGH** -- potential patent infringement | Not applicable -- SGraph Send uses words for file lookup, not geographic coordinates. |
| Using three words as a general passphrase/identifier | **LOW** -- not covered by W3W patents | W3W patents are specific to geographic coordinate encoding. Using three words as a passphrase or lookup key is a well-established practice (Diceware, BIP-39, PGP word list) predating W3W. |
| Using a grid/division system with three-word labels | **MEDIUM** -- may overlap with W3W patents | Not applicable to SGraph Send. |

#### 3.5.2 Prior Art for Three-Word Passphrases

Three-word (and multi-word) passphrases have extensive prior art that predates What3Words:

- **Diceware** (1995) -- Arnold Reinhold's method for generating passphrases from a word list using dice
- **PGP Word List** (1990s) -- Two-word fingerprint verification in PGP
- **BIP-39** (2013) -- Mnemonic seed phrases for cryptocurrency wallets (12/24 words from a 2,048-word list)
- **S/KEY** (1996) -- One-time password system using six short words
- **XKCD 936** (2011) -- "correct horse battery staple" popularised multi-word passphrases

**Conclusion:** Using three words as a passphrase or lookup identifier is **not novel** and is **not covered by What3Words patents**. However, SGraph Send should:

1. **Never use the name "What3Words"** or "W3W" or the "///" notation
2. **Create our own branding** (e.g., "Easy Share Code", "Share Words", "Quick Code")
3. **Use our own word list** (not the What3Words word list, which is proprietary)
4. **Avoid any geographic/mapping association** in marketing or documentation

### 3.6 Risk Classification

| Use Case | Three-Word Scheme Acceptable? | Risk Level | Notes |
|----------|-------------------------------|------------|-------|
| Sharing public/non-sensitive files (presentations, marketing assets, open-source code) | **YES** -- with conditions (TWK-1 through TWK-10) | **LOW** | The file has no confidentiality requirement. The three-word scheme adds convenience. |
| Sharing internal/business files (reports, spreadsheets, meeting notes) | **CONDITIONAL** -- only with separated concerns (3.4) or salt trick (TWK-9) | **MEDIUM** | Content has some sensitivity. Full key + three-word lookup is the right approach. |
| Sharing sensitive/confidential files (contracts, financial data, PII, health records) | **NO** -- use full AES-256-GCM key only | **HIGH** | Entropy is insufficient. Even with all mitigations, the risk of brute-force is too high for truly sensitive content. |
| Sharing files in regulated environments (HIPAA, GDPR personal data, financial compliance) | **ABSOLUTELY NOT** | **CRITICAL** | Regulatory frameworks require "appropriate technical measures." A 33-50 bit passphrase is not appropriate. |

### 3.7 Go/No-Go Recommendation

**GO -- with conditions.**

| Decision | Details |
|----------|---------|
| **Verdict** | CONDITIONAL APPROVAL |
| **Recommended architecture** | Separated concerns (Section 3.4): three words for **lookup only**, full AES-256-GCM key for **decryption** |
| **Alternative architecture** | If "three words for everything" is pursued: mandatory TWK-1 through TWK-10 (Section 3.4.1) |
| **Blocking conditions** | TWK-1 (explicit labelling), TWK-2 (warning), TWK-4 (server-assigned words from 7,776+ dictionary), TWK-5 (rate limiting) are P0 for any implementation |
| **Branding** | Must not reference What3Words. Create own branding. Use own word list. |
| **Default** | Three-word mode must NEVER be the default. Full encryption is always the default. |
| **Threat model update** | If implemented, the threat model (v0.2.15) must be updated with a new section for passphrase-derived key threats |
| **Review gate** | AppSec must review the Architect's technical design before Dev implementation begins |

### 3.8 New Risk Register Entries

| Risk ID | Risk | Likelihood | Impact | Mitigation |
|---------|------|------------|--------|------------|
| **RF-38** | Three-word passphrase brute-forced offline (if used for decryption) | HIGH | HIGH | TWK-9 (server-side salt), TWK-3 (Argon2id), TWK-6 (short TTL) |
| **RF-39** | User sends sensitive file with three-word "easy" mode, false sense of security | MEDIUM | HIGH | TWK-1 (labelling), TWK-2 (warning), TWK-7 (file size limit) |
| **RF-40** | Online enumeration of three-word lookup codes finds valid transfers | MEDIUM | MEDIUM | TWK-5 (rate limiting), TWK-8 (logging and alerting) |
| **RF-41** | Dictionary reduction attack -- users choose predictable words | HIGH | MEDIUM | TWK-4 (server-assigned words, not user-chosen) |
| **RF-42** | Trademark/branding confusion with What3Words | LOW | MEDIUM | Own branding, own word list, no geographic association |

---

## 4. Security Implications of New Features

The v0.3.10 brief introduces several features that, while not explicitly assigned to AppSec, have security implications worth flagging.

### 4.1 Navigation Guards and `beforeunload` (Brief Section 12)

**Feature:** Use the `beforeunload` event to warn users before navigating away during active transfers. Disable or de-emphasise on-page links during transfers.

**Security assessment:**

| Concern | Risk | Notes |
|---------|------|-------|
| **Can `beforeunload` be bypassed?** | **YES** -- `beforeunload` is a browser hint, not a guarantee. Browsers may suppress the dialog (Chrome suppresses it after page load if the user hasn't interacted). Closing the browser/tab may not trigger it on mobile. Browser crashes bypass it entirely. | This is a UX feature, not a security control. Do not rely on it for data integrity. |
| **Can malicious JS prevent the user from leaving?** | **LOW RISK** -- modern browsers limit `beforeunload` abuse. The dialog text cannot be customised (browser shows a generic message). The user can always close the tab. | No security concern for SGraph Send. |
| **Link interception during transfers** | **LOW RISK** -- intercepting clicks to show a confirmation is standard UX. No security implication as long as the click target is not modified (i.e., do not change where the link points, just confirm before following). | Standard pattern. |

**Recommendation:** Implement as described in the brief. No AppSec objection. The Dev should be aware that `beforeunload` is **best-effort** -- the real protection for transfers is server-side resumability (LF-6 from v0.3.2), not client-side navigation prevention.

### 4.2 Path-Based Routing for SA Dashboard (Brief: SA Dashboard Section)

**Feature:** The SA dashboard uses path-based URLs (`/admin/dashboard/cache/`, `/admin/dashboard/lambda/{lambda-id}`) instead of hash-fragment navigation.

**Security assessment:**

| Concern | Risk | Notes |
|---------|------|-------|
| **URL manipulation / path traversal** | **MEDIUM** | Path-based routing means the URL path is now parsed and used to determine what data to display. If the router passes URL segments directly to API calls or file lookups without validation, path traversal is possible. Example: `/admin/dashboard/lambda/../../secrets` if the router naively concatenates paths. |
| **URL logging and exposure** | **LOW** | Hash fragments (`#`) are never sent to the server and do not appear in server logs. Path segments are sent to the server and appear in access logs, CloudFront logs, and potentially in referrer headers. For the admin dashboard, the paths contain infrastructure identifiers (Lambda function names, cache IDs), not secrets. This is acceptable for admin-only URLs. |
| **Direct URL access / bookmarking** | **LOW** | Path-based URLs are directly accessible. The existing admin API key authentication must apply to ALL path-based routes, not just the root. If a new route handler forgets to check auth, it creates an unauth access path. |
| **Client-side routing security** | **LOW** | If routing is handled client-side (SPA-style), the server must return the same authenticated HTML shell for all `/admin/dashboard/*` paths. The client-side router then determines what to display. This is standard and safe. If routing is server-side, each route handler must independently verify authentication. |

**Recommendations:**

| # | Recommendation | Priority |
|---|----------------|----------|
| **PR-1** | All `/admin/dashboard/*` routes must require the same authentication as the admin root | P1 |
| **PR-2** | URL path segments used in API calls must be validated and sanitised (no path traversal characters: `..`, `//`, `%2e%2e`) | P1 |
| **PR-3** | Lambda function names, cache IDs, and other identifiers extracted from URLs must be validated against an allowlist or format pattern before use | P1 |
| **PR-4** | Server-side logging of admin dashboard URLs is acceptable but must not include the API key (verify API key is in header, not URL parameter) | P1 |

### 4.3 Cache Service Browser (Brief: SA Dashboard -- Priority View 1)

**Feature:** A UI that browses cache IDs, views temporal data, inspects individual cache entries (JSON, text, binary), and navigates the folder structure.

**Security assessment:**

| Concern | Risk | Notes |
|---------|------|-------|
| **Data exposure in browser** | **MEDIUM** | The cache browser will display raw data from the cache service -- which may include log entries, Lambda configurations, token metadata, and other operational data. If the admin UI is compromised (XSS), all this data is exposed. |
| **Rendering untrusted data** | **HIGH** | Cache entries may contain arbitrary content -- log lines with user-agent strings, request paths, error messages. If any of this is rendered via `innerHTML`, it creates an XSS vector. This is a direct application of AU-3 (textContent rendering). |
| **Binary content handling** | **MEDIUM** | The brief mentions inspecting "binary" cache entries. Rendering binary data in the browser requires care -- do not create blob URLs from untrusted binary content without content-type validation. |
| **Cache ID enumeration** | **LOW** | The cache browser lists all cache IDs. This is intended behaviour for an admin tool. The risk is if the admin UI is accessible to non-admins (covered by HC-B1). |

**Recommendations:**

| # | Recommendation | Priority |
|---|----------------|----------|
| **CB-1** | ALL cache entry content must be rendered via `textContent`, never `innerHTML`. This includes JSON views, log lines, and text content. | P0 |
| **CB-2** | Binary cache entries must not be rendered inline. Offer download-only for binary content. | P1 |
| **CB-3** | Cache entry rendering must escape or sanitise all content before display, even in `textContent` mode (defense in depth for future refactoring) | P1 |
| **CB-4** | The cache browser API endpoints must require admin authentication (same as all admin routes) | P0 |

### 4.4 Upload Progress Events (Brief Section 10)

**Feature:** Granular progress events for every stage of the upload workflow (file selected, encryption starting/progress/complete, upload starting/progress/complete, processing, link generation, done).

**Security assessment:**

| Concern | Risk | Notes |
|---------|------|-------|
| **Timing side-channel** | **VERY LOW** | Progress events reveal timing information about encryption and upload stages. In theory, an attacker observing these timings could infer file size (from encryption duration) or network conditions (from upload duration). In practice, file size is already known (it is in the transfer metadata as `file_size_bytes`), so this leaks nothing new. |
| **Event injection** | **LOW** | If progress events are communicated via DOM events or `postMessage`, a malicious script on the same page could inject fake progress events to mislead the user. This is a minor UX concern, not a security concern -- the real transfer state is server-side. |
| **Information in error events** | **MEDIUM** | If a progress event includes error details (e.g., "encryption failed: [specific error]"), it could reveal information about the crypto implementation to an attacker observing the DOM. Error events should contain user-friendly messages, not technical details. |

**Recommendations:**

| # | Recommendation | Priority |
|---|----------------|----------|
| **UP-1** | Progress event error messages must not expose crypto implementation details (key sizes, algorithm parameters, internal error codes) | P2 |
| **UP-2** | Progress events should use internal state management (not global DOM events or `postMessage` to `window`) to prevent injection by third-party scripts | P2 |

### 4.5 End-to-End Timing Capture (Brief Section 11)

**Feature:** Capture timing data for every stage of the send workflow (encryption, upload, server processing, link generation) and store in the cache service.

**Security assessment:**

| Concern | Risk | Notes |
|---------|------|-------|
| **Timing data as a fingerprint** | **LOW** | Timing data (encryption duration, upload speed) could theoretically be correlated with client hardware and network characteristics. Combined with file size, this could narrow down the identity of a sender. However, the data is stored in the admin cache service (not public) and the threat model already accepts that the server knows file sizes. |
| **Timing data includes client IP?** | **CHECK** | If timing data is stored per-transfer, ensure it does not inadvertently include the client IP address. Use the existing `ip_hash` mechanism (even though it currently lacks salt per HC-E1). |

**Recommendation:** No objection to timing capture. Ensure timing records do not include raw client IP addresses -- use `ip_hash` (and fix the salt issue per HC-E1).

### 4.6 `beforeunload` Bypass Scenarios

The brief asks about `beforeunload`. For completeness, here are the known bypass scenarios:

| Scenario | Browser Behaviour | Impact on SGraph Send |
|----------|-------------------|----------------------|
| **User has not interacted with page** | Chrome/Edge may suppress the dialog entirely | Transfer could die silently if started automatically (unlikely in current UX -- user clicks "Send") |
| **Mobile browsers** | Many mobile browsers (especially iOS Safari) do not reliably fire `beforeunload` | Mobile users may lose transfers when switching apps. This is a UX issue, not a security issue. |
| **Browser crash/kill** | `beforeunload` does not fire | Transfer dies. The mitigation is server-side resume (LF-6), not client-side prevention. |
| **`window.close()` from JS** | `beforeunload` fires but may be suppressed by pop-up blockers | Only relevant if SGraph Send opens in a pop-up (it should not). |
| **JavaScript disabled** | `beforeunload` handler never registered | Not applicable -- SGraph Send requires JavaScript for encryption. |
| **User force-closes tab** | Varies by browser | Transfer dies. Same mitigation: server-side resume. |

**Bottom line:** `beforeunload` is a valuable UX guard but is **not a security control**. The real protection is server-side transfer state and resume capability.

---

## 5. Recommendations: Priority Order for AppSec Reviews

### 5.1 Immediate (This Session)

| # | Action | Priority | Status |
|---|--------|----------|--------|
| **A-36** | Three-word key security review | P3 (but blocking) | **COMPLETED** in this document (Section 3) |

### 5.2 Next Session -- Triggered by Dev/Architect Output

| # | Action | Priority | Trigger |
|---|--------|----------|---------|
| **A-37** | Review Architect's three-word key technical design against TWK-1 through TWK-10 | P3 | Architect produces technical feasibility document |
| **A-38** | Review path-based routing implementation for URL manipulation risks (PR-1 through PR-4) | P1 | Dev implements SA dashboard routing |
| **A-39** | Audit cache browser for XSS risks (CB-1 through CB-4) | P0 | Dev builds cache service browser UI |
| **A-40** | Verify AU-1, AU-2, AU-3 on current admin UI code | P0 | Any session (carry-forward from v0.3.2) |

### 5.3 Ongoing -- Carry-Forward from v0.3.2

All 35 items from the [v0.3.2 action plan](../26-02-14/v0.3.2__action-plan__explorer-next-steps.md) remain active. The full register is not repeated here -- refer to that document for the complete list.

**Updated totals including this review:**

| Priority | Previous (v0.3.2) | New (v0.3.12) | Total |
|----------|-------------------|---------------|-------|
| P0 | 7 | 2 (A-39, A-40) | 9 |
| P1 | 18 | 2 (A-37, A-38) | 20 |
| P2 | 10 | 0 | 10 |
| P3 | 0 | 1 (A-36 -- completed) | 0 (completed) |
| **Total active** | **35** | **4** | **39** |

### 5.4 Risk Register Summary

| Risk ID Range | Source | Count |
|---------------|--------|-------|
| RF-1 to RF-30 | v0.2.x reviews | 30 |
| RF-31 to RF-37 | v0.3.2 action plan | 7 |
| RF-38 to RF-42 | This review (three-word keys) | 5 |
| **Total** | | **42** |

---

## 6. Summary for Other Roles

### For the Architect

You are unblocked to proceed with the three-word key technical feasibility analysis. Key constraints from this review:

1. **Preferred architecture:** Three words for lookup only, full AES-256-GCM key for decryption (Section 3.4)
2. **If "three words for everything":** Mandatory TWK-1 through TWK-10, especially TWK-9 (server-side salt) and TWK-4 (server-assigned words from 7,776+ word list)
3. **Dictionary:** Use Diceware or create a custom word list of 7,776+ words. Do NOT use the What3Words word list.
4. **AppSec review gate:** Submit your technical design for AppSec review before Dev implementation

### For the Dev

**Do not implement three-word keys yet.** Wait for:
1. This AppSec review (now complete)
2. The Architect's technical design (pending)
3. AppSec review of the Architect's design (A-37)

For other features in the brief:
- Cache browser: use `textContent` for ALL rendered content (CB-1)
- Path-based routing: validate all URL path segments (PR-2, PR-3)
- Upload progress events: keep error messages generic (UP-1)
- `beforeunload`: implement it, but know it is best-effort, not a guarantee

### For the Conductor

The three-word key review is complete. The dependency chain is now:

```
AppSec review (DONE) --> Architect technical design --> AppSec design review --> Dev implementation
```

The next blocking action is the Architect's technical feasibility document. This remains P3 per the brief -- it should not take priority over the P1 UX bug fixes or P2 SA dashboard work.

---

*AppSec action plan complete. This document addresses the v0.3.10 brief's single explicit AppSec task (three-word key security review) and provides security commentary on five additional features. The carry-forward register from v0.3.2 remains fully active with 39 total action items and 42 risk register entries. The next AppSec review will be triggered by the Architect's three-word key technical design and by the Dev's implementation of the SA dashboard cache browser.*
