# v0.2.1 — AppSec Response to MVP Infrastructure Brief

**Version:** v0.2.1
**Date:** 2026-02-10
**Role:** AppSec
**Responding to:** `team/humans/dinis_cruz/briefs/2026-02-10/v0.1.4__briefs__focus-on-mvp-release-infrastructure.md`

---

## 1. Security Review Scope

The brief expands the attack surface significantly by adding 7 deployment targets. This review covers:
- Encryption flow integrity
- Token auth model
- Pre-signed URL scoping
- No-plaintext-on-server guarantee
- Per-target security considerations

---

## 2. Encryption Flow Assessment

### 2.1 What's Correct

| Aspect | Status | Notes |
|---|---|---|
| Algorithm | AES-256-GCM | Industry standard authenticated encryption |
| Key generation | Client-side (Web Crypto API) | Key never sent to server |
| Encryption | Client-side (Web Crypto API) | Plaintext never leaves browser |
| Decryption | Client-side (Web Crypto API) | Server only serves ciphertext |
| Key exchange | Out-of-band (sender → receiver) | Not through our infrastructure |

### 2.2 Concerns

**C1: IV/Nonce Management**
AES-256-GCM requires a unique IV (initialisation vector) per encryption. The IV must be stored alongside the ciphertext for decryption. Current spec doesn't document where the IV is stored.

**Recommendation:** Prepend the 12-byte IV to the ciphertext blob. On decryption, extract the first 12 bytes as IV, remainder as ciphertext. This is the standard pattern. Document this in the encryption spec.

**C2: Key Derivation**
If the user-facing "key" is the raw AES key (base64-encoded), it will be 44 characters. If we want a shorter, more user-friendly key, we'd need a key derivation function (PBKDF2 or HKDF).

**Recommendation for MVP:** Use the raw AES-256 key, base64url-encoded. This gives 43 characters — acceptable for copy-paste. Key derivation adds complexity without security benefit for MVP.

**C3: Authentication Tag**
GCM produces an authentication tag that prevents tampering. If someone modifies the ciphertext, GCM decryption will fail with an auth error, not produce corrupted plaintext. This is good — it means "wrong key" and "tampered ciphertext" both produce clear failures, not silent corruption.

**Verified:** The brief's requirement "wrong key gives a clear error not a corrupted file" is inherently satisfied by AES-256-GCM. No additional code needed.

---

## 3. Token Auth Model

### 3.1 Current Implementation

The admin Lambda uses OSBot-Fast-API's built-in header/cookie auth:
- Key name and value configured via environment variable
- Same credential for header-based and cookie-based auth
- Single admin key per environment

### 3.2 Security Assessment

| Aspect | Risk | Mitigation |
|---|---|---|
| Single shared admin key | Medium — no per-user audit trail | Acceptable for MVP; multi-user auth in Phase 2 |
| Key in environment variable | Low — standard Lambda practice | AWS Secrets Manager for production |
| No rate limiting on auth | Medium — brute force possible | Lambda URL has implicit rate limiting; add explicit later |
| No key rotation mechanism | Low (MVP) | Document rotation procedure; implement automated rotation in Phase 2 |
| Admin Lambda URL discoverable | Low — random URL + auth required | Document that URL should not be shared publicly |

### 3.3 Recommendations

- **P0:** Verify that failed auth attempts are logged (action log should record `auth_failed` events)
- **P1:** Add rate limiting on admin auth failures (e.g., 5 failures per IP per minute)
- **P2:** Move admin key to AWS Secrets Manager for production
- **P2:** Consider per-user admin auth (API keys or OAuth) for audit trails

---

## 4. Pre-Signed URL Scoping

### 4.1 Requirements (when implemented)

Pre-signed URLs are marked as "future" in the system map (modes 2b/3b). When implemented:

| Scope Parameter | Required Value | Why |
|---|---|---|
| Expiry | 5 minutes (upload), 1 hour (download) | Minimise window of abuse |
| HTTP method | PUT (upload) or GET (download) | Prevent method confusion |
| Content-Type | `application/octet-stream` | Prevent content-type spoofing |
| Key prefix | `transfers/{transfer_id}/payload.enc` | Prevent accessing other transfers |
| Bucket | Environment-specific only | Prevent cross-environment access |

### 4.2 CORS for Pre-Signed URLs

When browser uploads directly to S3 via pre-signed URL:
- S3 bucket CORS must allow `PUT` from `send.sgraph.ai` (and dev/qa domains)
- CORS must NOT allow `*` origin
- CORS must not expose unnecessary headers

---

## 5. No-Plaintext-on-Server Guarantee

### 5.1 Verification Checklist

This is the fundamental security guarantee. It must be verified at every deployment:

| Check | Method | Automated |
|---|---|---|
| Encrypted file bytes in S3/storage | Read `payload.enc`, verify it's not valid UTF-8 / not recognisable as original format | Yes (smoke test) |
| No file name in metadata | Read `meta.json`, verify no `original_filename` field | Yes (unit test) |
| No decryption key on server | Grep all server logs and storage for key pattern | Yes (smoke test) |
| IP addresses hashed | Read event files, verify `ip_hash` field is SHA-256 hex, no raw IP | Yes (unit test) |
| CloudWatch logs clean | Search CloudWatch for raw file content or keys | Yes (post-deploy) |
| Lambda env vars don't contain keys | Inspect Lambda configuration | Manual (audit) |

### 5.2 Logging Safety

**Critical concern:** FastAPI access logs, error tracebacks, and Lambda CloudWatch logs must never contain:
- Decryption keys (these are never sent to the server, so this should be impossible)
- Original file names (ditto)
- Raw IP addresses (must be hashed before any logging)
- File content (only encrypted bytes transit the server)

**Recommendation:** Add a log sanitisation check to the smoke test suite. After running a full transfer cycle, search CloudWatch/stdout logs for:
- The known test file content
- The known test encryption key
- The known test IP address (should only appear as hash)

---

## 6. Per-Target Security Considerations

### 6.1 Lambda

| Concern | Mitigation |
|---|---|
| Function URL publicly accessible | Acceptable — content is encrypted, IDs are random |
| Lambda execution role too broad | Use least-privilege: S3 read/write on specific bucket only |
| Lambda layers from external sources | Pin versions in `admin__config.py` (already done) |

### 6.2 Docker / Container

| Concern | Mitigation |
|---|---|
| Base image vulnerabilities | Use `python:3.12-slim`, scan with Trivy in CI |
| Secrets in Docker image | Never bake secrets; pass via env vars at runtime |
| Container running as root | Add `USER nonroot` to Dockerfile |
| Exposed ports | Only expose 8080; no debug ports |

### 6.3 EC2 / AMI

| Concern | Mitigation |
|---|---|
| SSH access | Disable SSH or restrict to bastion; use SSM Session Manager |
| Unpatched OS | AMI baked from latest Amazon Linux; auto-update in user data |
| Exposed services | Security group: only 443 inbound |
| Secrets on disk | Use instance profile + Secrets Manager, not config files |

### 6.4 GCP Cloud Run

| Concern | Mitigation |
|---|---|
| Cross-cloud S3 access | HTTPS transit encryption; IAM credentials rotated |
| GCP IAM misconfiguration | Service account with minimal permissions |
| Container escapes | Cloud Run is sandboxed (gVisor) |

---

## 7. Security Testing Requirements

### 7.1 Tests That Must Exist Before Any Production Deployment

| Test | Level | Priority |
|---|---|---|
| Encrypted payload is not recognisable as original file | Unit | P0 |
| No raw IP in stored events | Unit | P0 |
| Admin endpoints return 401 without auth | Unit | P0 |
| Admin endpoints return 401 with wrong auth | Unit | P0 |
| GCM decryption fails cleanly with wrong key | Unit (browser simulation) | P0 |
| No plaintext in CloudWatch after transfer | Smoke | P0 |
| CORS headers restrict to expected origins | Integration | P1 |
| Rate limiting on auth failures | Integration | P1 |
| Pre-signed URL expiry enforced | Integration (when implemented) | P1 |
| Container image has no critical CVEs | CI (Trivy scan) | P1 |

---

## 8. Action Items for AppSec

- [ ] Document IV/nonce storage format for AES-256-GCM (P0)
- [ ] Verify GCM auth tag handling in frontend encryption code (P0)
- [ ] Review admin auth failure logging (P0)
- [ ] Create no-plaintext-on-server verification script (P0)
- [ ] Define pre-signed URL scoping parameters (P1)
- [ ] Add Trivy container scanning to CI (P1)
- [ ] Review CORS configuration when frontend is implemented (P1)
- [ ] Audit Lambda execution role permissions (P1)
- [ ] Define log sanitisation rules (P1)
- [ ] Review rate limiting strategy for admin auth (P2)

---

*This review is the AppSec master file for the v0.1.4 infrastructure brief response.*
