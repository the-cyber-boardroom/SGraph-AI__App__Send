# v0.2.33 -- AppSec Response to Daily Brief #2 (13 Feb 2026)

**Version:** v0.2.33
**Date:** 2026-02-13
**Role:** AppSec (Application Security)
**Context:** Response to `team/humans/dinis_cruz/briefs/02/13/v0.2.32__daily-brief__2__sgraph-send-13-feb-2026.md`
**Continues from:** `team/roles/appsec/reviews/26-02-13/v0.2.24__response-to-daily-brief__13-feb.md` (Brief #1 response)
**Focus:** GA removal risk assessment, no-cookie security posture, localStorage key caching, cache service security

---

## 1. Google Analytics Removal -- Security Risk Assessment

Brief #2 maps the GRC risk assessment function to AppSec. This section provides the security-oriented risk analysis supporting GA removal.

### 1.1 Risk of Keeping Google Analytics

| Risk ID | Risk | Likelihood | Impact | Severity |
|---------|------|------------|--------|----------|
| GA-K1 | **Third-party JavaScript on a zero-knowledge platform** -- GA's `gtag.js` executes in our origin. While it cannot read the URL hash fragment by default, it runs with full same-origin privileges. A compromised GA supply chain (Google-served `gtag.js` modified or hijacked) would have script execution in our security context. | Low | Critical | HIGH |
| GA-K2 | **Cookie-based tracking contradicts zero-knowledge promise** -- The `_ga` cookie (2-year expiry) creates a persistent pseudonymous identifier. Users who chose SGraph Send for privacy are being tracked across sessions by a third party. This is a trust contradiction, not just a compliance issue. | Certain | Medium | HIGH |
| GA-K3 | **Third-party data exposure** -- GA sends page view data, session duration, scroll depth, referrer, screen resolution, browser/OS, and language to Google servers. Google is a data processor with international data transfer implications (Schrems II). Even with IP anonymisation, Google receives behavioural telemetry about our users. | Certain | Medium | HIGH |
| GA-K4 | **Cookie consent infrastructure attack surface** -- Implementing a cookie consent banner requires additional JavaScript, DOM manipulation, and state management. Every line of consent infrastructure code is additional attack surface on a page that handles encryption keys. | Medium | Medium | MEDIUM |
| GA-K5 | **Compliance burden** -- PECR consent requirements, GDPR processor documentation, DPIA obligations, privacy policy disclosures, and cookie audit trail all require ongoing maintenance. Non-compliance risk is regulatory (ICO enforcement). | High | Medium | HIGH |
| GA-K6 | **GA page title capture could leak transfer IDs** -- Flagged in the v0.2.24 status report (P1 action). If `document.title` contains a transfer ID, GA captures it. This was identified as requiring an audit that has not yet been completed. Removing GA eliminates this risk entirely. | Medium | Medium | MEDIUM |

### 1.2 Risk of Removing Google Analytics

| Risk ID | Risk | Likelihood | Impact | Severity |
|---------|------|------------|--------|----------|
| GA-R1 | **Loss of traffic visibility during transition** -- Between GA removal and server-side analytics becoming operational, there is a gap in traffic visibility. | High | Low | LOW |
| GA-R2 | **Server-side analytics must be built** -- Development effort required. However, the cache service architecture in Brief #2 addresses this, and server-side events are already being logged. | Certain | Low | LOW |
| GA-R3 | **No historical data continuity** -- GA historical data will be lost once the property is deactivated. | Certain | Low | LOW |

### 1.3 Net Assessment

The risk profile is unambiguous. **Keeping GA introduces five HIGH-severity risks** (supply chain, trust contradiction, data exposure, compliance, transfer ID leakage) and one MEDIUM (consent infrastructure attack surface). **Removing GA introduces zero HIGH-severity risks** -- only LOW-severity operational gaps that are already addressed by the cache service design.

From a security perspective, removing GA also resolves two open AppSec actions from the v0.2.24 status report:
- **P1:** "Verify GA does not capture transfer IDs in page titles" -- eliminated (no GA to capture anything)
- **P0:** "Set `Referrer-Policy: no-referrer`" -- still required for general hygiene, but the GA-specific referrer leakage risk is eliminated

**AppSec RECOMMENDS removal of Google Analytics.** The third-party JavaScript execution risk alone is sufficient justification for a zero-knowledge platform. The additional compliance, trust, and data exposure risks reinforce this conclusion.

---

## 2. No-Cookie Security Posture

Brief #2 establishes the target state: **zero cookies**. This section assesses the security implications.

### 2.1 Attack Surface Eliminated

| Attack Class | Status with Cookies | Status without Cookies |
|--------------|--------------------|-----------------------|
| **Cookie theft via XSS** | Risk -- any XSS could exfiltrate `_ga` cookies (or any future session cookies) | **Eliminated** -- no cookies to steal |
| **Session hijacking** | Risk -- if session cookies are introduced, stolen cookies grant session access | **Eliminated** -- no session cookies exist |
| **CSRF via cookies** | Risk -- cookies are automatically attached to cross-origin requests by browsers, enabling CSRF if cookie-based auth is used | **Eliminated** -- auth uses `x-sgraph-access-token` header (not automatically attached) |
| **Session fixation** | Risk -- attacker sets a known cookie value before victim authenticates | **Eliminated** -- no cookie-based sessions |
| **Cookie scope misconfiguration** | Risk -- cookies scoped too broadly (e.g., `*.sgraph.ai`) could leak across subdomains | **Eliminated** -- no cookies to misconfigure |
| **Subdomain cookie injection** | Risk -- a compromised subdomain could set cookies for the parent domain | **Eliminated** -- no cookies to inject |
| **Third-party cookie tracking** | Active with GA -- `_ga` cookie enables cross-session tracking | **Eliminated** |

### 2.2 What Remains

The no-cookie posture does NOT eliminate all client-side risks:

| Remaining Risk | Mitigation |
|----------------|------------|
| **XSS** -- still possible; could access localStorage, DOM, or JavaScript variables | CSP, SRI, textContent (not innerHTML), no third-party JS |
| **Header-based auth token theft via XSS** -- the `x-sgraph-access-token` in localStorage is readable by any same-origin JS | Acceptable for beta (shared secret). Replaced by per-user tokens before public launch (v0.2.24 status report action) |
| **localStorage data accessible to same-origin JS** | See Section 3 below |

### 2.3 Security Verdict

**A no-cookie posture is a significant security improvement.** It eliminates an entire class of web attacks (cookie-based) and reduces the attack surface to XSS-only vectors, which are already mitigated by the existing security controls (no third-party JS post-GA removal, CSP, SRI, textContent-only rendering).

The no-cookie posture also enables a strong **verifiable claim**: users or auditors can open browser DevTools, check the Application tab, and confirm zero cookies. This is a provable security property, not just a policy statement.

---

## 3. Local Storage Security Review

Brief #2 proposes caching encryption keys in localStorage via a transparency panel. This requires careful security assessment.

### 3.1 What Would Be Stored

| Item | Sensitivity | Risk Level |
|------|-------------|------------|
| **Encryption keys** (AES-256-GCM, base64url-encoded) | **Critical** -- these keys decrypt user files. Possession of key + transfer ID = access to plaintext file content | HIGH |
| **Invitation token** | Low -- not a secret (sent in query string, visible to server) | LOW |
| **User preferences** (theme, language) | None -- no security relevance | NONE |

### 3.2 Threat Model for Key Caching

| Threat | Likelihood | Impact | Severity | Details |
|--------|------------|--------|----------|---------|
| **T1: XSS exfiltrates cached keys** | Low (with mitigations) | Critical | HIGH | Any XSS on `send.sgraph.ai` can read all localStorage entries. An attacker who obtains cached keys AND knows the corresponding transfer IDs can decrypt all cached files. Post-GA removal, the XSS attack surface is significantly reduced (no third-party JS), but the impact of a successful XSS becomes much higher if keys are cached. |
| **T2: Device theft / shared computer** | Medium | Critical | HIGH | localStorage persists indefinitely. A stolen laptop or a shared computer with keys cached means anyone with physical access to the browser can retrieve all cached decryption keys. Unlike cookies, localStorage has no expiry mechanism. |
| **T3: Browser extension reads localStorage** | Medium | Critical | HIGH | Extensions with `storage` or broad host permissions can read localStorage. This is the same risk class as hash-fragment exposure to extensions (R2 from v0.2.24 review), but cached keys have longer exposure windows -- they persist until explicitly cleared, whereas hash-fragment exposure is transient. |
| **T4: Forensic recovery** | Low | High | MEDIUM | Even after `localStorage.clear()`, data may be recoverable from disk (browser profile directories, swap files). This is a physical-access threat with no practical mitigation in a browser context. |
| **T5: Malicious browser profile sync** | Low | High | MEDIUM | If the user has browser sync enabled (Chrome Sync, Firefox Sync), localStorage contents may be synced to cloud servers. The encryption keys would then exist on Google/Mozilla infrastructure. |

### 3.3 Mitigations

| Mitigation | Addresses | Implementation |
|------------|-----------|----------------|
| **M1: Strict CSP** | T1 (XSS) | `Content-Security-Policy: default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self'; img-src 'self' data:; object-src 'none'; base-uri 'self'` -- no inline scripts, no external scripts. This is the single most important mitigation. |
| **M2: Subresource Integrity (SRI)** | T1 (XSS supply chain) | All `<script>` and `<link>` tags include `integrity` attributes. Prevents loading if content has been modified. |
| **M3: No third-party JavaScript** | T1 (XSS via 3rd party) | Post-GA removal, zero external scripts execute on the page. This is a strong position. |
| **M4: Key expiry in localStorage** | T2, T3 | Store keys with a timestamp. On page load, purge keys older than N hours (suggest 24h default, user-configurable). This limits the exposure window. |
| **M5: Opt-in only (default off)** | T1-T5 (all) | Key caching must be explicitly enabled by the user. Default behaviour: zero local storage. This is the most important design decision -- the user must consciously choose convenience over maximum security. |
| **M6: Zero-storage mode** | T1-T5 (all) | Provide a mode where nothing is stored locally. Every session is stateless. This is the maximum-privacy option that eliminates all localStorage risks. |
| **M7: Transparency panel** | T1-T5 (visibility) | Show exactly what is stored, with per-item delete and a "clear all" button. Users can audit and manage their cached data. |
| **M8: Referrer-Policy: no-referrer** | General | Already a P0 from v0.2.24 status report. Still required regardless of GA removal. Prevents any referrer leakage if user navigates from the SGraph Send page to an external site. |

### 3.4 Recommended Architecture

```
DEFAULT STATE: Zero local storage (nothing cached)
    |
    v
User opts in: "Remember my keys for convenience"
    |
    v
Keys stored with:
  - Timestamp (for automatic expiry)
  - Transfer ID association (so user knows which key is for which file)
  - NO file names (the zero-knowledge principle extends to localStorage)
    |
    v
On page load:
  1. Check key age â†’ purge expired keys
  2. Display in transparency panel
  3. User can delete individual keys or clear all
    |
    v
ZERO-STORAGE MODE: User explicitly chooses "Never store anything"
  - localStorage.clear() on every page unload
  - No persistence between sessions
  - Maximum privacy, maximum inconvenience
```

### 3.5 Security Verdict

**Key caching in localStorage is acceptable IF AND ONLY IF:**

1. It is **opt-in** (default off)
2. CSP is **strictly enforced** (no inline scripts, no external scripts)
3. SRI is applied to **all script and stylesheet references**
4. Keys have **automatic expiry** (24h default)
5. The transparency panel provides **full visibility and control**
6. A **zero-storage mode** exists as the maximum-security alternative
7. **No file names** are stored alongside keys (zero-knowledge extends to client storage)

Without conditions 1-3, AppSec would NOT approve key caching. The XSS impact escalation (from "can read current page state" to "can read all historically cached keys") is too significant without strong XSS prevention.

---

## 4. Cache Service Security Assessment

Brief #2 introduces the cache service as the data backbone. The cache hash mechanism requires security review.

### 4.1 Cache Hash: Token-to-ID Resolution

The flow: `human-friendly token` --> `hash(token)` --> `cache hash` --> `cache ID` --> `file tree`.

Security questions:

#### Q1: Is the hash collision-resistant?

**Assessment:** Depends on the hash function used. If SHA-256 is used (consistent with the IP hashing approach), collision resistance is approximately 2^128 (birthday bound). This is more than adequate -- two different tokens producing the same cache hash is computationally infeasible.

**Recommendation:** Use SHA-256 for the cache hash. Document the hash function in the architecture. Do NOT use MD5 or SHA-1 (collision attacks are practical for both).

#### Q2: Is the hash predictable?

**Assessment:** YES -- this is the intended design. The cache hash is deterministic: `hash("community-x")` always produces the same cache hash. This is a feature, not a bug -- it enables the human-friendly token lookup.

**However**, predictability means an attacker who knows or guesses the token string can compute the cache hash. The question becomes: does knowing the cache hash grant access?

#### Q3: Could an attacker enumerate tokens by guessing cache hashes?

**Assessment:** This is the primary security concern. Analysis:

| Attack Vector | Feasibility | Impact | Mitigation |
|---------------|-------------|--------|------------|
| **Brute-force token names** -- attacker tries common words, names, and patterns to guess human-friendly tokens | **HIGH feasibility** -- tokens like `community-x`, `football-123`, `beta-2025` are guessable. The human-friendly design inherently means low entropy. | Medium -- attacker could discover valid tokens and use them | Rate limiting on token resolution endpoint. Usage limits on tokens (already planned). Monitoring for token probing patterns. |
| **Cache hash enumeration** -- attacker tries to directly access cache entries by guessing cache hashes | **LOW feasibility** -- even if the hash function is known, the attacker would need to find the cache ID from the cache hash. If the lookup requires API authentication, this is blocked. | Medium -- depends on what the cache entry reveals | Ensure cache entries are not directly addressable by cache hash from unauthenticated endpoints. The hash-to-ID lookup must go through an authenticated or rate-limited API. |
| **Timing side-channel** -- attacker probes the token resolution endpoint and measures response time to distinguish "token exists" from "token does not exist" | **MEDIUM feasibility** -- network jitter may mask timing differences, but at scale, statistical analysis can reveal the difference | Low -- confirms token existence but does not grant access | Constant-time token lookup. Return the same response structure and HTTP status regardless of token validity. |

### 4.2 Recommendations for Cache Service Security

| # | Recommendation | Priority | Rationale |
|---|---------------|----------|-----------|
| CS-1 | **Use SHA-256 for cache hash** | P1 | Collision-resistant, consistent with existing IP hashing approach |
| CS-2 | **Salt the cache hash** | P1 | Add a static application-level salt to the hash input: `hash(salt + token)`. This prevents precomputation attacks. An attacker who knows the hash function but not the salt cannot compute cache hashes. |
| CS-3 | **Rate-limit token resolution** | P1 | Human-friendly tokens are inherently low-entropy and guessable. Rate limiting is the primary defence against brute-force token enumeration. |
| CS-4 | **Constant-time token lookup** | P2 | Prevent timing side-channels that reveal token existence. Return identical response structures for valid and invalid tokens. |
| CS-5 | **Token usage limits enforce access control** | P1 | Already planned in Brief #2. A token with 0 remaining uses cannot be exploited even if discovered. |
| CS-6 | **Audit trail on token probing** | P2 | Log failed token resolution attempts (with hashed IP). Detect patterns that suggest enumeration attacks. |
| CS-7 | **Cache entries must NOT be directly addressable from public endpoints** | P1 | The hash-to-ID lookup must be an internal server operation. Public API receives the human-friendly token, not the cache hash or cache ID. |

### 4.3 Security Verdict

The cache hash design is fundamentally sound for its purpose (deterministic lookup from human-friendly tokens). The primary risk is **token enumeration** due to the low entropy of human-friendly names. This risk is manageable through rate limiting (CS-3), salted hashing (CS-2), and the already-planned usage limits (CS-5).

**AppSec APPROVES the cache service design** with the condition that recommendations CS-1 through CS-3 and CS-5 are implemented before the token system is exposed to users.

---

## 5. Carry-Forward from Brief #1 Response

The following items from the v0.2.24 response to Brief #1 remain active:

| Item | Status | Update |
|------|--------|--------|
| **D014: Hash-fragment URLs APPROVED** | DONE | No change. Implementation can proceed. |
| **D019/D022: Separate observability S3 bucket** | Active | Still required. The cache service does not change this -- observability data and transfer data must be in separate storage. |
| **Text input uses `textContent` not `innerHTML`** | Active | Still required. No change. |
| **`history.replaceState` after decryption** | Active | Still required. Strip the hash from the URL bar after successful decryption. |
| **`Referrer-Policy: no-referrer` on all responses** | Active (P0) | Still required. GA removal reduces the urgency (no third-party analytics to leak to) but this remains a general security hygiene requirement. |
| **Per-user tokens before public launch** | Active | Brief #2's human-friendly token system with cache hash resolution is the implementation path for this. The shared access token (`SGRAPH_SEND__ACCESS_TOKEN`) must be replaced by per-user tokens before wider rollout. |
| **GA page title audit** | RESOLVED | Removing GA eliminates this risk entirely. No audit needed. |
| **Plan migration from shared to per-user tokens** | Active | Brief #2's token system addresses this. Design must include revocation capability. |

---

## 6. Updated AppSec Action Items

### Resolved by Brief #2

| # | Previous Action | Resolution |
|---|----------------|------------|
| 1 | "Verify GA does not capture transfer IDs" (v0.2.24, P1) | **RESOLVED** -- GA being removed entirely |
| 2 | Cookie consent infrastructure security review | **RESOLVED** -- no cookies, no consent infrastructure needed |

### Active Actions

| # | Action | Priority | Owner | Status |
|---|--------|----------|-------|--------|
| 1 | Implement `Referrer-Policy: no-referrer` on all responses | **P0** | Dev | Carried from v0.2.24 |
| 2 | Implement `history.replaceState` after decryption | P1 | Dev | Carried from v0.2.24 |
| 3 | Enforce strict CSP headers (prerequisite for localStorage key caching) | P1 | Dev | NEW -- blocks localStorage key caching |
| 4 | Implement SRI on all script/stylesheet references | P1 | Dev | NEW -- blocks localStorage key caching |
| 5 | Verify text input renders via `textContent` not `innerHTML` | P1 | Dev/QA | Carried from v0.2.24 |
| 6 | Design token resolution rate limiting | P1 | Architect/Dev | NEW -- blocks token system launch |
| 7 | Use SHA-256 with static salt for cache hash | P1 | Architect/Dev | NEW |
| 8 | Ensure cache entries not directly addressable from public API | P1 | Architect/Dev | NEW |
| 9 | Implement key expiry mechanism in localStorage | P2 | Dev | NEW -- when key caching is built |
| 10 | Design constant-time token lookup | P2 | Dev | NEW |
| 11 | Add token probing audit trail | P2 | Dev | NEW |
| 12 | Per-user token migration (replace shared access token) | P2 | Architect/Dev | Carried from v0.2.24 |
| 13 | Separate observability storage from transfer storage | P2 | DevOps | Carried from v0.2.24 |

### New Decisions This Session

| ID | Decision | Rationale |
|----|----------|-----------|
| -- | AppSec RECOMMENDS GA removal | Third-party JS on zero-knowledge platform is an unacceptable supply chain risk. Compliance and trust risks reinforce. |
| -- | Key caching APPROVED with conditions | Opt-in only, CSP required, SRI required, automatic expiry required, no file names stored |
| -- | Cache hash design APPROVED with conditions | SHA-256 with salt, rate limiting on token resolution, cache entries not publicly addressable |
| -- | No-cookie posture ENDORSED | Eliminates entire class of cookie-based attacks. Verifiable by users. Strong security property. |

---

*Next review: after cache service implementation and localStorage transparency panel are built. AppSec will review the actual CSP headers, SRI implementation, and token resolution rate limiting before these features go live.*
