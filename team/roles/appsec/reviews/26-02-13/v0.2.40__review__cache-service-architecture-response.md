# v0.2.40 -- AppSec Review: Cache Service Architecture

**Version:** v0.2.40
**Date:** 13 February 2026
**Role:** AppSec (Application Security)
**Context:** Response to `team/humans/dinis_cruz/briefs/02/13/v0.2.40__brief__cache-service-architecture.md`
**Continues from:** `team/roles/appsec/reviews/26-02-13/v0.2.33__response-to-daily-brief-2__13-feb.md` (Section 4 -- Cache Service Security Assessment)
**Focus:** Security review of cache service integration architecture -- shared S3 bucket, IN_MEMORY execution, admin route exposure, dependency supply chain, data classification

---

## Executive Summary

The cache service architecture introduces two external PyPI packages into the SGraph Send Lambda process and shares the existing S3 bucket with prefix-only isolation between user transfer data and admin/cache data. This review identifies **one HIGH-severity risk** (admin route exposure through accidental sub-app mounting), **two MEDIUM-severity risks** (prefix isolation without IAM enforcement, dependency supply chain), and confirms the architecture preserves the zero-knowledge guarantee. The overall design is sound, but specific implementation guardrails are required before deployment.

**Verdict: CONDITIONALLY APPROVED** -- subject to the six mandatory requirements listed in Section 8.

---

## 1. Shared S3 Bucket with Prefix Isolation

### 1.1 Current Architecture

The brief proposes a single S3 bucket with two prefix domains:

| Prefix | Owner | Data |
|--------|-------|------|
| `user/` | `Transfer__Service` via `Storage_FS__S3(s3_prefix="user/")` | Encrypted transfer payloads, transfer metadata |
| `admin/` | Cache service via `Storage_FS__S3(s3_prefix="admin/")` | Analytics events, token metadata, cost data, transfer event caches |

Both `Storage_FS__S3` instances share the same `s3_bucket` value.

### 1.2 How Prefix Isolation Works Today

Examining the existing `Storage_FS__S3` implementation (`sgraph_ai_app_send/lambda__user/storage/Storage_FS__S3.py`):

```python
def s3_key(self, path: Safe_Str__File__Path) -> str:
    key = str(path)
    if self.s3_prefix:
        prefix = self.s3_prefix if self.s3_prefix.endswith('/') else f"{self.s3_prefix}/"
        key    = f"{prefix}{key}"
    return key
```

The `s3_prefix` is prepended to every path operation -- read, write, delete, list. The `files__paths()` method also strips the prefix on read, and `clear()` only deletes within the prefix. This is **application-level isolation**, not IAM-level.

### 1.3 Risk Assessment: Can the Cache Service Access `user/` Data?

| Attack Vector | Feasibility | Analysis |
|---------------|-------------|----------|
| **Bug in cache service path construction** | LOW | The cache service uses its own `Storage_FS` instance with `s3_prefix="admin/"`. All path operations go through the Memory-FS abstraction. A bug would have to bypass both the cache service's path resolution AND the Storage_FS prefix logic. |
| **Path traversal via cache_key** | LOW | The `Safe_Str__File__Path` type from `osbot-utils` sanitises path inputs. A `cache_key` value of `../../user/transfers/...` would be sanitised before reaching S3. However, the effectiveness of this sanitisation must be verified against the specific `Safe_Str__File__Path` validation rules. |
| **Direct S3 API call bypassing Storage_FS** | VERY LOW | The project rules mandate all storage through Memory-FS. No code path should call S3 directly. However, both the cache service and SGraph Send share the same Lambda IAM role, which has full access to the entire bucket. |
| **Cache service admin endpoints reading arbitrary paths** | MEDIUM | The cache service has `/admin/storage/file/bytes/{path:path}` and `/admin/storage/files/all/{path:path}` endpoints that take raw paths. If these are accessible (see Section 3), an attacker could read `user/` prefix data by passing `user/transfers/...` as the path. The `{path:path}` parameter in FastAPI captures the full remaining path including slashes -- this is a path parameter, not filtered by namespace. |

### 1.4 Risk Severity: MEDIUM

Prefix isolation is adequate for the beta phase given that:
- The storage abstraction enforces prefix scoping on all normal operations
- `Safe_Str__File__Path` provides input sanitisation
- Both domains contain non-sensitive data by design (encrypted payloads in `user/`, hashed IPs in `admin/`)

However, the IAM role cannot distinguish between prefixes. A compromised or buggy code path with direct `admin_storage()` access could cross the boundary.

### 1.5 Recommendations

| # | Recommendation | Priority | Rationale |
|---|---------------|----------|-----------|
| S3-1 | **Verify `Safe_Str__File__Path` rejects path traversal** | P1 | Test that inputs like `../../user/transfers/` and `../user/` are sanitised to safe values. This is the primary defence against cross-prefix access. |
| S3-2 | **Add an integration test that asserts cross-prefix isolation** | P1 | Write a test that creates data in both prefixes and verifies that operations on one Storage_FS instance cannot see data in the other. |
| S3-3 | **Consider separate S3 buckets for v0.2.x** | P2 | When extracting the cache to its own Lambda (REMOTE mode), give it a separate bucket. This eliminates the cross-prefix risk entirely and aligns with the original D019/D022 recommendation for separate observability storage. |
| S3-4 | **Add S3 bucket policy restricting cache Lambda role to `admin/*` prefix** | P2 | When the cache service is extracted to its own Lambda, use an S3 bucket policy condition `s3:prefix` to restrict its IAM role to the `admin/` prefix only. This converts application-level isolation to IAM-level enforcement. |

---

## 2. IN_MEMORY Execution Mode

### 2.1 How It Works

The cache service runs inside the same Lambda process as SGraph Send. The `Cache__Service__Client` in `IN_MEMORY` mode creates a FastAPI `TestClient` that makes HTTP calls to the cache service's FastAPI app **within the same process**, with zero network latency.

```
Lambda Process
  |
  +-- SGraph Send FastAPI App (public, Lambda URL)
  |     +-- /transfers/*
  |     +-- /send/* (static)
  |     +-- /info/*
  |
  +-- Cache Service FastAPI App (internal, NOT on Lambda URL)
        +-- /{namespace}/{strategy}/store/*
        +-- /{namespace}/retrieve/*
        +-- /admin/storage/*         <-- CONCERN
        +-- /server/*
```

### 2.2 Security Implications

**Positive:**
- No network calls for cache operations -- eliminates network-level attack surface (MITM, DNS rebinding, SSRF)
- No separate authentication needed between SGraph Send and cache service
- No additional Lambda URL or API Gateway endpoint to secure
- Cache service endpoints are NOT exposed on the public Lambda URL

**Negative:**
- The cache service runs with the same IAM permissions as the main Lambda
- The cache service shares the same process memory -- a memory corruption bug in one could affect the other
- The TestClient provides access to ALL cache service endpoints internally, including admin endpoints
- Cold start time will increase with additional dependencies

### 2.3 Risk Severity: LOW

IN_MEMORY mode is the correct choice for the beta. The key security property is that the cache service's FastAPI app is **separate** from the public-facing SGraph Send FastAPI app. Users hitting the Lambda URL interact with `Fast_API__SGraph__App__Send__User`, which has no knowledge of the cache service's routes.

---

## 3. Admin Route Exposure -- CRITICAL ANALYSIS

### 3.1 The Cache Service Has Powerful Admin Endpoints

From the cache service LLM brief (`library/dependencies/cache-service/v0.5.68__cache-service__llm-brief.md`), the following admin endpoints exist:

```
GET  /admin/storage/bucket-name           -- Reveals S3 bucket name
GET  /admin/storage/file/exists/{path}    -- Check arbitrary file existence
GET  /admin/storage/file/bytes/{path}     -- Read arbitrary file bytes
GET  /admin/storage/file/json/{path}      -- Read arbitrary file as JSON
GET  /admin/storage/files/parent-path     -- List parent path files
GET  /admin/storage/files/all/{path}      -- List ALL files under path
GET  /admin/storage/folders               -- List all folders
DELETE /admin/storage/{path}              -- Delete arbitrary file
POST /server/create/test-fixtures         -- Create test data in storage
```

The cache service documentation itself notes: "Should be protected with authentication in production."

### 3.2 Are These Endpoints Exposed?

**In the IN_MEMORY architecture: NO.** The cache service FastAPI app is instantiated internally by `Cache__Service__Client` and accessed only via `TestClient`. The public Lambda URL serves `Fast_API__SGraph__App__Send__User`, which has its own route registration in `setup_routes()`:

```python
def setup_routes(self):
    self.setup_static_routes()
    self.add_routes(Routes__Info)
    self.add_routes(Routes__Transfers, transfer_service=self.transfer_service)
    self.add_routes(Routes__Set_Cookie)
```

No cache service routes are registered here. The two FastAPI apps are separate objects.

### 3.3 How This Could Go Wrong

| Scenario | Likelihood | Impact |
|----------|------------|--------|
| **Developer mounts cache app as sub-app** -- e.g., `self.app().mount("/cache", cache_service_app)` | MEDIUM | CRITICAL -- all cache admin endpoints accessible from public Lambda URL. Attacker could read arbitrary S3 files, delete data, enumerate storage. |
| **Developer adds cache routes to user app** -- e.g., `self.add_routes(Routes__Cache__Admin)` | LOW | CRITICAL -- same as above |
| **Future refactor merges the two apps** | LOW | CRITICAL -- admin endpoints become public |
| **Developer exposes cache client's internal TestClient** -- passes it to a route handler that proxies requests | VERY LOW | HIGH -- arbitrary cache service operations from public URL |

### 3.4 Risk Severity: HIGH (potential), currently LOW (actual)

The current architecture is safe because the two FastAPI apps are separate. But the risk of accidental exposure during future development is real and the impact would be critical. This requires a permanent guardrail.

### 3.5 Recommendations

| # | Recommendation | Priority | Rationale |
|---|---------------|----------|-----------|
| AR-1 | **Add a test that verifies admin endpoints are NOT accessible from the public Lambda URL** | P0 | Regression test: `GET /admin/storage/bucket-name` on the user Lambda app must return 404. `GET /admin/storage/files/all/user` must return 404. This test catches accidental mounting. |
| AR-2 | **Disable cache service admin endpoints in IN_MEMORY mode** | P1 | If the cache service supports disabling admin routes (e.g., `enable_admin=False` in config), use it. SGraph Send does not need to call `/admin/storage/*` through the HTTP interface -- it uses the Storage_FS abstraction directly. |
| AR-3 | **Document the separation in code comments** | P1 | Add a clear comment in `Fast_API__SGraph__App__Send__User.setup()` stating that the cache service app MUST NOT be mounted as a sub-app or have its routes registered on the public FastAPI app. |
| AR-4 | **Audit `Send__Cache__Client` wrapper to confirm it never calls `admin_storage()`** | P1 | The wrapper should only call store, retrieve, data, namespace, and info operations. It must not expose `admin_storage()` methods. Review the `Html_Cache__Client` reference -- it does call `admin_storage().files__all__path()` in its `namespace__all_files` method (line 334). If `Send__Cache__Client` follows this pattern, that method provides a path-based query that could potentially access files outside the intended namespace if the path parameter is not properly scoped. |

---

## 4. Dependency Supply Chain

### 4.1 New Dependencies

| Package | PyPI | GitHub Org | Current Version | Purpose |
|---------|------|-----------|-----------------|---------|
| `mgraph-ai-service-cache` | [link](https://pypi.org/project/mgraph-ai-service-cache/) | `the-cyber-boardroom` | v0.6.0+ | Cache service (FastAPI app) |
| `mgraph-ai-service-cache-client` | [link](https://pypi.org/project/mgraph-ai-service-cache-client/) | `the-cyber-boardroom` | v0.10.1 | Python client library |

Both packages are from the same GitHub organisation (`the-cyber-boardroom`) that maintains `osbot-utils`, `osbot-aws`, `osbot-fast-api`, and `osbot-fast-api-serverless` -- all of which SGraph Send already depends on.

### 4.2 Current Dependency Pinning

The existing Lambda dependencies are pinned to exact versions in `sgraph_ai_app_send/lambda__user/user__config.py`:

```python
APP__SEND__USER__LAMBDA_DEPENDENCIES = ['httpx==0.28.1',
                                         'memory-fs==v0.40.0',
                                         'osbot-fast-api-serverless==v1.33.0']
```

However, `pyproject.toml` uses wildcard versioning for core dependencies:

```toml
[tool.poetry.dependencies]
osbot-utils               = "*"
issues-fs-cli             = "*"
osbot-fast-api-serverless = "*"
```

### 4.3 Risk Assessment

| Risk | Severity | Analysis |
|------|----------|----------|
| **Compromised PyPI package** | MEDIUM | Both packages are from a trusted org. However, any PyPI package can be compromised (typosquatting, account takeover, build pipeline injection). The `mgraph-ai-service-cache` package includes a full FastAPI app that will run inside our Lambda process. |
| **Unpinned version allows silent upgrade** | MEDIUM | If the new packages are added with `"*"` versioning (matching `pyproject.toml` pattern), a compromised future version could be pulled in automatically. |
| **Transitive dependencies** | LOW | The cache client depends on `osbot-utils`, `osbot-fast-api`, and `requests` -- all already in the dependency tree. Minimal new transitive dependency surface. |
| **Lambda package size** | LOW | Additional packages increase cold start time. Monitor after integration. |

### 4.4 Recommendations

| # | Recommendation | Priority | Rationale |
|---|---------------|----------|-----------|
| DC-1 | **Pin exact versions in `APP__SEND__USER__LAMBDA_DEPENDENCIES`** | P0 | Add `mgraph-ai-service-cache==v0.6.0` and `mgraph-ai-service-cache-client==v0.10.1` (or whatever versions are verified). Do NOT use `"*"` or `">=v0.6.0"`. |
| DC-2 | **Pin exact versions in `pyproject.toml`** | P1 | Change from `"*"` to exact versions for all dependencies. This prevents silent upgrades during development. |
| DC-3 | **Verify package integrity** | P1 | Before first deployment, manually verify the PyPI package contents match the expected source. Check `pip show mgraph-ai-service-cache` to confirm the installed package metadata, entry points, and file list. |
| DC-4 | **Add dependency to admin Lambda config too** | P1 | The admin Lambda (`admin__config.py`) will likely also need the cache client dependency. Ensure `APP__SEND__ADMIN__LAMBDA_DEPENDENCIES` is updated with pinned versions. |
| DC-5 | **Monitor cold start impact** | P2 | Measure Lambda cold start time before and after adding the cache service dependencies. If cold start exceeds acceptable threshold (e.g., 3 seconds), consider lazy loading or dependency optimisation. |

---

## 5. Data Classification Confirmation

### 5.1 What the Cache Service Stores

| Data Domain | S3 Path | Contains | Sensitive? |
|-------------|---------|----------|------------|
| **Analytics raw events** | `admin/analytics/data/temporal/...` | Timestamp, ip_hash (SHA-256 with daily salt), action type, user agent hash, transfer_id, response time, status code | NO -- ip_hash is irreversible with daily salt rotation. No PII. |
| **Analytics aggregations** | `admin/analytics/data/key-based/aggregations/...` | Counts, averages, totals per time window | NO -- aggregate statistics, no individual identifiers |
| **Analytics pulse** | `admin/analytics/data/temporal-latest/pulse/...` | Request count in last 5 minutes | NO -- ephemeral count |
| **Token metadata** | `admin/tokens/data/key-based/...` | Token name, usage limit, creation date, status, ip_hash of creator | NO -- human-friendly names are not secrets (they're shared with invitees). ip_hash is irreversible. |
| **Token usage events** | `admin/tokens/.../data/events/...` | Timestamp, ip_hash, action, token name | NO -- all hashed/anonymised |
| **Cost data** | `admin/costs/data/key-based/...` | AWS cost figures per day/month | NO -- operational data, not user data |
| **Transfer event cache** | `admin/transfers/.../data/events/...` | transfer_id, timestamp, action (upload/download/expire), ip_hash | NO -- transfer_id is opaque (12 random chars). No file names. No encryption keys. No plaintext. |

### 5.2 Confirmation: All Backend Data Is Non-Sensitive

**CONFIRMED.** The cache service stores only:
- Hashed identifiers (ip_hash -- SHA-256 with daily salt)
- Opaque identifiers (transfer_id -- 12 random characters)
- Operational metadata (timestamps, counts, status codes)
- Human-friendly token names (shared deliberately with invitees)
- Aggregate statistics (counts, averages)

**No file names, no encryption keys, no plaintext file content, no PII** enters the cache service.

### 5.3 One Caveat: Transfer IDs

Transfer IDs appear in both `user/` and `admin/` prefixes. In `user/`, the transfer_id is the folder name containing the encrypted payload. In `admin/`, the transfer_id appears in analytics events and transfer event caches. This is acceptable because:

1. The transfer_id alone does not grant access -- the download endpoint requires the transfer_id but returns only the encrypted ciphertext
2. The encryption key is never stored on the server
3. Knowing a transfer_id without the key yields only: "a transfer exists with this ID" -- which is already inferable from the download endpoint returning 200 vs 404

**No change needed.** Transfer IDs in analytics data do not compromise zero-knowledge.

---

## 6. Zero-Knowledge Principle Preserved

### 6.1 Data Flow Analysis

```
User Browser                     Lambda Process
    |                                |
    |-- encrypt(file, key) --------->|
    |   (AES-256-GCM)               |
    |                                |-- Store ciphertext --> S3 user/
    |                                |-- Record event -----> Cache (admin/)
    |                                |     (transfer_id, ip_hash, timestamp)
    |                                |     NO file name, NO key, NO plaintext
    |                                |
    |<-- {transfer_id, upload_url} --|
    |                                |
    | (user shares link+key out-of-band)
    |                                |
Recipient Browser                   |
    |-- GET /transfers/download/id ->|
    |                                |-- Read ciphertext <-- S3 user/
    |                                |-- Record event -----> Cache (admin/)
    |<-- ciphertext -----------------|
    |                                |
    |-- decrypt(ciphertext, key)     |
    |   (AES-256-GCM, in browser)   |
    |                                |
    |-- plaintext (never leaves      |
    |   the browser)                 |
```

### 6.2 Verification Points

| Property | Status | Evidence |
|----------|--------|----------|
| Server never sees plaintext | PRESERVED | Cache service handles only metadata (ip_hash, transfer_id, timestamps). Encrypted payloads flow through Transfer__Service to `user/` prefix. Cache service has no code path to read from `user/` prefix. |
| Server never sees file names | PRESERVED | No file name field exists in any analytics event schema or token metadata schema. |
| Server never sees encryption keys | PRESERVED | Keys exist only in browser memory and URL hash fragments. No cache service operation accepts or stores a key parameter. |
| Encryption happens client-side only | PRESERVED | Cache service is server-side only. No client-side code changes. |
| Cache service cannot decrypt uploads | PRESERVED | Even if the cache service could read `user/transfers/{id}/payload`, it would get ciphertext. Without the AES-256-GCM key (which is never on the server), the data is cryptographically useless. |

**CONFIRMED: The zero-knowledge guarantee is fully preserved.** The cache service operates in a completely separate data domain (metadata and analytics) from the encryption domain (keys and plaintext).

---

## 7. Carry-Forward from Previous Reviews

### 7.1 Items from v0.2.33 Response (Section 4 -- Cache Service Security)

| Previous Item | Status | Update |
|---------------|--------|--------|
| CS-1: Use SHA-256 for cache hash | CONFIRMED | Cache service LLM brief confirms SHA-256 is the default hash algorithm (`Cache__Hash__Generator` defaults to SHA-256). |
| CS-2: Salt the cache hash | STILL REQUIRED | The cache service uses content-based hashing (hash of the stored data). For human-friendly token names, the hash is computed from the `cache_key` field via `json_field_path='cache_key'`. This means `hash("community-x")` is deterministic and predictable. A static application-level salt is still recommended for the token namespace. |
| CS-3: Rate-limit token resolution | STILL REQUIRED | The `Send__Cache__Client` wrapper must implement rate limiting on token lookup operations. The cache service itself does not provide rate limiting. |
| CS-4: Constant-time token lookup | STILL REQUIRED (P2) | No change. |
| CS-5: Token usage limits | CONFIRMED | Token metadata includes usage limits. Already planned. |
| CS-6: Audit trail on token probing | STILL REQUIRED (P2) | Analytics event recording on every request (Phase 1) provides the foundation. Specific failed-lookup alerting is a P2 item. |
| CS-7: Cache entries not directly addressable from public endpoints | CONFIRMED BY ARCHITECTURE | IN_MEMORY mode means cache service endpoints are not on the public Lambda URL. The `Send__Cache__Client` wrapper is the only interface. Public API receives human-friendly token names, not cache hashes or cache IDs. |

### 7.2 Items from v0.2.24 Response

| Previous Item | Status | Update |
|---------------|--------|--------|
| D019/D022: Separate observability S3 bucket | DEFERRED | The cache service architecture uses the same bucket with prefix isolation. This is acceptable for beta. Separate bucket recommended when cache service is extracted to its own Lambda. |
| Referrer-Policy: no-referrer | STILL REQUIRED (P0) | No change. Not related to cache service. |
| history.replaceState after decryption | STILL REQUIRED (P1) | No change. Not related to cache service. |
| Per-user tokens before public launch | IN PROGRESS | The cache service token system (Phase 1 of the brief) is the implementation path for this requirement. |

---

## 8. Mandatory Requirements Before Deployment

These are the conditions under which AppSec approves the cache service integration:

| # | Requirement | Priority | Blocks |
|---|-------------|----------|--------|
| **M1** | **Regression test: admin endpoints return 404 on public Lambda URL** -- Test that `GET /admin/storage/bucket-name`, `GET /admin/storage/files/all/user`, and `DELETE /admin/storage/user` all return 404 when called against `Fast_API__SGraph__App__Send__User`. | P0 | Deployment |
| **M2** | **Pin exact dependency versions** -- Add `mgraph-ai-service-cache==v0.X.Y` and `mgraph-ai-service-cache-client==v0.10.1` to `APP__SEND__USER__LAMBDA_DEPENDENCIES` with exact version pins. | P0 | Deployment |
| **M3** | **Cross-prefix isolation test** -- Write a test that creates a `Storage_FS__S3` with `s3_prefix="admin/"` and another with `s3_prefix="user/"`, stores data in both, and verifies that operations on one cannot see or modify data in the other. Include a path traversal test case (`../../user/...`). | P1 | Deployment |
| **M4** | **`Send__Cache__Client` does not expose `admin_storage()` methods** -- The wrapper must not delegate to `client.admin_storage()`. Audit the wrapper before merging. If namespace file listing is needed, route it through the namespace API (`client.namespace()`), not through raw storage admin operations. | P1 | Deployment |
| **M5** | **Document the architecture boundary in code** -- Add a comment block in `Fast_API__SGraph__App__Send__User.setup()` explicitly stating: "The cache service FastAPI app runs in-process via TestClient. It MUST NOT be mounted as a sub-app or have its routes registered on this FastAPI app." | P1 | Merge |
| **M6** | **Rate limiting on token resolution** -- Before the token system is exposed to users, implement request-level rate limiting on token lookup operations in `Send__Cache__Client` or in the route handler. | P1 | Token system launch |

---

## 9. Updated AppSec Action Items

### Resolved by This Brief

| # | Previous Action | Resolution |
|---|----------------|------------|
| 1 | CS-1: Use SHA-256 for cache hash (v0.2.33) | **RESOLVED** -- Cache service defaults to SHA-256 |
| 2 | CS-5: Token usage limits (v0.2.33) | **RESOLVED** -- Built into cache service token metadata |
| 3 | CS-7: Cache entries not publicly addressable (v0.2.33) | **RESOLVED** -- IN_MEMORY mode ensures cache endpoints are not on public URL |

### Active Actions (cumulative)

| # | Action | Priority | Owner | Status |
|---|--------|----------|-------|--------|
| 1 | Implement `Referrer-Policy: no-referrer` on all responses | **P0** | Dev | Carried from v0.2.24 |
| 2 | Regression test: admin endpoints return 404 on public Lambda URL | **P0** | QA/Dev | NEW -- M1 |
| 3 | Pin cache service dependency versions in Lambda config | **P0** | Dev | NEW -- M2 |
| 4 | Implement `history.replaceState` after decryption | P1 | Dev | Carried from v0.2.24 |
| 5 | Enforce strict CSP headers | P1 | Dev | Carried from v0.2.33 |
| 6 | Implement SRI on all script/stylesheet references | P1 | Dev | Carried from v0.2.33 |
| 7 | Cross-prefix isolation test (Storage_FS path traversal) | P1 | QA/Dev | NEW -- M3 |
| 8 | Audit `Send__Cache__Client` -- no `admin_storage()` exposure | P1 | AppSec/Dev | NEW -- M4 |
| 9 | Document architecture boundary in code | P1 | Dev | NEW -- M5 |
| 10 | Rate limiting on token resolution | P1 | Dev | Carried from v0.2.33 (CS-3), now M6 |
| 11 | Salt the cache hash for token namespace | P1 | Dev | Carried from v0.2.33 (CS-2) |
| 12 | Verify text input renders via `textContent` not `innerHTML` | P1 | Dev/QA | Carried from v0.2.24 |
| 13 | Implement key expiry mechanism in localStorage | P2 | Dev | Carried from v0.2.33 |
| 14 | Design constant-time token lookup | P2 | Dev | Carried from v0.2.33 (CS-4) |
| 15 | Add token probing audit trail | P2 | Dev | Carried from v0.2.33 (CS-6) |
| 16 | Per-user token migration (replace shared access token) | P2 | Architect/Dev | Carried from v0.2.24 |
| 17 | Separate S3 bucket when cache service extracted to own Lambda | P2 | DevOps | Updated from D019/D022 |
| 18 | Monitor Lambda cold start impact from new dependencies | P2 | DevOps | NEW -- DC-5 |
| 19 | Pin all `pyproject.toml` dependencies to exact versions | P2 | Dev | NEW -- DC-2 |

---

## 10. Decision Summary

| ID | Decision | Rationale |
|----|----------|-----------|
| -- | Cache service IN_MEMORY architecture **CONDITIONALLY APPROVED** | Zero-knowledge preserved. Admin endpoints not exposed on public URL. Requires M1-M6 before deployment. |
| -- | Shared S3 bucket with prefix isolation **APPROVED for beta** | Application-level isolation is adequate when combined with `Safe_Str__File__Path` sanitisation and cross-prefix tests. Separate buckets recommended for production extraction. |
| -- | New PyPI dependencies **APPROVED with exact version pinning** | Both packages from trusted org. Must be pinned to exact versions. |
| -- | Data classification **CONFIRMED non-sensitive** | All cache service data is hashed, anonymised, or aggregate. No PII, no file names, no keys, no plaintext. |

---

*Next review: after `Send__Cache__Client` wrapper is implemented. AppSec will audit the wrapper code, verify admin endpoint isolation test exists, and confirm dependency versions are pinned before the first deployment with cache service integration.*
