# v0.2.24 — AppSec Response to Daily Brief (13 Feb 2026)

**Version:** v0.2.24
**Date:** 2026-02-13
**Role:** AppSec
**Context:** Response to `team/humans/dinis_cruz/briefs/02/13/v0.2.16__daily-brief__sgraph-send-13-feb-2026.md`
**Focus:** Security review of hash-fragment approach for one-click file access

---

## 1. Hash-Fragment Security Analysis — APPROVED

### Core Question: Does the Hash Fragment Leave the Client?

**Answer: No.** The hash fragment is client-only by specification and implementation.

### Evidence

| Vector | Hash Fragment Exposed? | Details |
|--------|----------------------|---------|
| HTTP request line | **No** | RFC 3986 §3.5: fragment is stripped before transmission |
| TLS/HTTPS payload | **No** | Fragment not included in encrypted request |
| Server access logs | **No** | Never transmitted, never logged |
| CloudFront logs | **No** | CloudFront only logs the request URI (no fragment) |
| Lambda event object | **No** | `event['rawPath']` and `event['rawQueryString']` exclude fragments |
| Referrer header | **No** | Fetch spec strips fragment from `Referer`. Verified in Chromium, Firefox, Safari |
| DNS queries | **No** | DNS resolves hostname only |
| HTTPS proxy (MITM) | **No** | Fragment never on the wire, even if TLS is intercepted |

### Accepted Risks (Low Severity for Beta)

These are inherent to any URL-based secret sharing and are accepted tradeoffs:

#### R1: Browser History
- **Risk:** Full URL (including `#key`) is saved in browser history
- **Severity:** Low (single-user device) / Medium (shared device)
- **Mitigation:** After successful decryption, call `history.replaceState(null, '', '/send/v0/v0.1/v0.1.0/download.html')` to strip the hash from the URL bar and history entry
- **Recommendation:** Implement this mitigation

#### R2: Browser Extensions
- **Risk:** Extensions with `tabs` or `activeTab` permission can read `window.location.href` including hash
- **Severity:** Low — this is true for any URL-based secret (same risk as 1Password share links, Firefox Send, etc.)
- **Mitigation:** None practical. User's browser extension trust model is outside our scope
- **Recommendation:** Accept for beta. Document in security model

#### R3: URL in Clipboard
- **Risk:** When user copies the URL from the browser address bar, hash is included. Other apps can read clipboard
- **Severity:** Low — this is the intended behaviour (sharing the combined link). Same as any password manager sharing link
- **Mitigation:** N/A — this is the feature
- **Recommendation:** Accept

#### R4: URL in Chat/Email Logs
- **Risk:** The combined URL (with key) persists in whatever channel the user shares it through (Slack, email, WhatsApp)
- **Severity:** Medium — but identical to current flow where user sends link + key in the same message anyway
- **Mitigation:** Consider adding optional per-transfer expiry and download limits
- **Recommendation:** Accept. This risk exists regardless of URL format — users already send link and key together

#### R5: URL Length
- **Risk:** Transfer ID (12 chars) + key (43 chars base64url) + path = ~120 chars total. Well within URL length limits (2048+ chars in all browsers)
- **Severity:** None
- **Mitigation:** N/A

### Comparison: Current Flow vs Hash-Fragment Flow

| Property | Current (link + key separate) | Hash-Fragment (combined URL) |
|----------|------------------------------|------------------------------|
| Server sees key | No | No |
| Key in HTTP request | No | No |
| Key in server logs | No | No |
| Key in browser history | No (key is copied, not in URL) | Yes (mitigated by history.replaceState) |
| Key in shared message | Yes (user sends it alongside link) | Yes (embedded in URL) |
| Zero-knowledge maintained | Yes | Yes |
| UX friction | High (copy 2 things, paste 2 things) | Low (copy 1 link, paste 1 link) |

### Net Security Assessment

**The hash-fragment approach does NOT weaken the zero-knowledge guarantee.** The server never sees the key in either flow. The only new exposure is browser history, which is mitigable. All other "risks" exist equally in the current flow.

**VERDICT: APPROVED for implementation.**

---

## 2. Implementation Recommendations

### Must-Have (before shipping)
1. **`history.replaceState` after decryption** — strip hash from URL bar
2. **Input validation** — validate transfer ID format (12 chars) and key format (base64url) before using
3. **Error handling** — wrong key should show clear error, not crash. Already implemented in current `crypto.js`

### Should-Have (before public launch)
4. **Transfer expiry** — auto-expire transfers after N hours/days (limits window of URL exposure)
5. **Download limit** — allow sender to set max downloads (1, 3, 5, unlimited)
6. **CSP headers** — ensure Content-Security-Policy doesn't leak data via `report-uri`

### Nice-to-Have (future)
7. **Client-side URL self-destruct** — after decryption, offer to "burn" the link (mark transfer as consumed)
8. **Optional password** — additional passphrase on top of the URL key (defence in depth for sensitive files)

---

## 3. Text Input Feature — Security Notes

The text input feature (encrypt text, not just files) has no additional security concerns:

- Text is converted to bytes (`TextEncoder`) and encrypted identically to files
- Same AES-256-GCM, same IV, same key generation
- Server receives identical encrypted blob — cannot distinguish text from file
- **One consideration:** text might be displayed in the browser after decryption (not downloaded as file). Ensure XSS protection: render as `textContent`, never `innerHTML`

---

## 4. Admin Token URLs — Security Notes

Token goes in the query string (`?token=xxx`) — this is correct. The token is **not** a secret in the same way the encryption key is. The purpose is for the backend to track token usage.

However:
- **Tokens should be single-use or limited-use** — prevent sharing of invitation links
- **Tokens should expire** — 7-day window is reasonable
- **Token format** — use cryptographically random strings (UUID v4 or similar), not sequential

---

## 5. Observability — Security Boundaries

The collector pipeline (S3 data lake) will aggregate sensitive-ish data:
- IP hashes (already anonymised with daily salt — good)
- Usage patterns (who uploads when, how often)
- Token usage trails

**Recommendations:**
- S3 bucket for observability data should be separate from transfer storage
- Bucket policy: no public access, encrypted at rest (SSE-S3 or SSE-KMS)
- DPO should review what's collected before we expose event data to users

---

## Summary: AppSec Actions

| # | Action | Priority | Status |
|---|---|---|---|
| 1 | Hash-fragment approach security review | P1 | **APPROVED** |
| 2 | Require `history.replaceState` after decryption | P1 | Recommendation to Dev |
| 3 | Text input XSS protection (textContent not innerHTML) | P1 | Recommendation to Dev |
| 4 | Token security requirements (single-use, expiry, random) | P2 | Recommendation to Architect |
| 5 | Observability S3 bucket security | P2 | Recommendation to DevOps |
| 6 | DPO review of event data before UI exposure | P2 | Blocks event data UI |
