# DevOps Review — Commit 07f1b09

**Version:** v0.1.4
**Date:** 2026-02-10
**Commit:** `07f1b09b227744a513177b1cf24f27fce874a0f6` — "added first implementation of Fast_API infrastructure"
**Author:** DevOps role (Claude)
**Status:** Review complete

---

## 1. Lambda Deployment Architecture

### Handler structure

`lambda_handler__admin.py` follows the correct Lambda pattern:
- **Module-level initialisation** (lines 18-34): runs once on cold start, persists across warm invocations
- **`run(event, context)`** (lines 36-39): the actual Lambda handler, delegates to Mangum

The dependency-loading guard at line 3 (`if os.getenv('AWS_REGION')`) correctly loads Lambda layer dependencies only when running in AWS. However, `AWS_REGION` is set in many non-Lambda environments (EC2, ECS, CI runners). A more precise check would be `AWS_LAMBDA_FUNCTION_NAME`, which is only set inside an actual Lambda function.

### Deploy__Service

`Deploy__Service` extends `Deploy__Serverless__Fast_API` and provides:
- `deploy_lambda()`: adds the UI admin folder to the deployment zip (line 11)
- `handler()`: returns the `run` function reference (line 16)
- `lambda_dependencies()`: returns pinned dependency list from config (line 18)
- `lambda_name()`: returns the service name from config (line 22)

Line 12 has a commented-out `set_env_variable` template — env var injection is not yet wired for production.

### Mangum integration

The Mangum adapter is obtained via `fast_api.handler()` (line 28 of the handler). This correctly wraps the ASGI app for Lambda URL Functions and API Gateway v2 events.

### Two-Lambda independence

Clean separation: `lambda__admin/` and `lambda__user/` are completely independent directories. Each can have its own:
- IAM execution role
- Concurrency limits
- Memory/timeout settings
- Environment variables
- Deploy pipeline

---

## 2. Package Structure & Bundling

### Lambda packaging model

```
Lambda zip:
├── sgraph_ai_app_send/lambda__admin/   (application code)
├── sgraph_ai_app_send__ui__admin/       (static assets, added via Deploy__Service.add_folder)
└── Lambda layers:
    ├── osbot-fast-api-serverless==v1.33.0
    ├── osbot-aws==v2.29.9
    └── memory-fs==v0.40.0
```

Dependencies are in Lambda layers (not bundled in the zip). The `Deploy__Service.deploy_lambda()` method adds the UI package directory to the zip. This is a clean separation between code and dependencies.

### pyproject.toml analysis

```toml
osbot-utils                 = "*"
osbot-fast-api-serverless   = "*"
memory-fs                   = "*"
```

**Risk:** All three runtime deps use `"*"` (any version). While `poetry.lock` pins them locally, a `pip install` from pyproject.toml directly (e.g., in a Docker build) would get unpinned versions. The Lambda layers pin specific versions (`v1.33.0`, `v2.29.9`, `v0.40.0`) — there is no guarantee the local dev versions match.

**Recommendation:** Pin minimum versions in pyproject.toml to match the Lambda layer versions:
```toml
osbot-fast-api-serverless   = ">=1.33.0"
```

### UI packages not in pyproject.toml packages

The UI packages (`sgraph_ai_app_send__ui__admin`, `sgraph_ai_app_send__ui__user`) are not listed in `[tool.poetry.packages]`. They are picked up by `Deploy__Service.add_folder()` for Lambda deployment, but would be missing from a wheel build.

---

## 3. Static Asset Serving

### How it works

1. `sgraph_ai_app_send__ui__admin/__init__.py` exports `path = __path__[0]` (filesystem path to package)
2. `Fast_API__SGraph__App__Send__Admin.setup_static_routes()` mounts `StaticFiles(directory=path)` at `/admin`
3. A separate route at `/admin` returns a 307 redirect to the versioned path

### Versioned path pattern

```
/admin/v0/v0.1/v0.1.0/index.html
       ^   ^     ^       ^
       |   |     |       └── start page
       |   |     └── patch version (APP_SEND__UI__ADMIN__LATEST__VERSION)
       |   └── minor version (implicit)
       └── major version (APP_SEND__UI__ADMIN__MAJOR__VERSION)
```

**Practical assessment:** This supports serving multiple versions simultaneously and cache-busting via path changes. Config-driven redirect makes version promotion a single constant change. However, the three-level nesting (`v0/v0.1/v0.1.0`) creates deep directory trees for a single file. Consider whether two levels (`v0.1/v0.1.0/`) would suffice.

### Lambda implications

Each static file request consumes a Lambda invocation and ~100ms of billed compute. This is acceptable for the admin console (low traffic, internal users). For the user-facing Lambda, static assets should be served via CloudFront + S3 in production.

---

## 4. Environment Configuration

### Auth configuration

Two environment variables control API key auth:
- `ENV_VAR__FAST_API__AUTH__API_KEY__NAME` — header name
- `ENV_VAR__FAST_API__AUTH__API_KEY__VALUE` — secret key value

These are set in tests at `Fast_API__Test_Objs__SGraph__App__Send__Admin.py:28-29`. For production, they need to be injected via the Deploy__Service (commented-out `set_env_variable` at `Deploy__Service.py:12`) or via infrastructure-as-code.

### Hardcoded values

- Lambda layer dependency versions in `admin__config.py:6-8` — appropriate to pin here
- Service name derived from `package_name` — good, avoids drift
- UI route paths and version strings in `admin__config.py:11-14` — appropriate for config

### Missing configuration

- No CORS configuration
- No logging level configuration
- No timeout/memory settings
- No environment tier detection (dev/qa/prod)

---

## 5. CI/CD Readiness

### Can tests run in CI today?

**Partially.** Using `poetry install && poetry run pytest` would work. However:

- `requirements-test.txt` is incomplete — lists only `osbot-utils`, `issues-fs`, and test tools. Missing: `osbot-fast-api-serverless`, `fastapi`, `starlette`, `mangum`, `httpx`.
- **Risk:** If the CI runner has `AWS_REGION` set (common on AWS-hosted runners like CodeBuild), the Lambda dependency loading guard at `lambda_handler__admin.py:3` would trigger and fail (no Lambda layers available). Should use `AWS_LAMBDA_FUNCTION_NAME` instead.
- No CI workflow file (`.github/workflows/`) exists yet.

### What's missing for a complete deploy pipeline

1. GitHub Actions workflow file
2. Lambda packaging step (zip creation with Deploy__Service)
3. Environment variable injection for auth keys
4. S3 bucket creation for storage
5. Lambda function creation/update step
6. Lambda URL Function configuration
7. Smoke test post-deploy
8. Environment promotion (dev → qa → prod)

---

## 6. Operational Concerns

### Cold start

- Module-level init creates the FastAPI app and Mangum handler — correct for warm reuse
- Lambda layer loading adds to cold start time (3 layers)
- Error capture (lines 30-34) prevents cold-start failures from crashing the Lambda entirely
- No provisioned concurrency configured (acceptable for admin Lambda)

### Logging and observability

**No logging anywhere.** This is the most significant operational gap:
- Initialization errors are captured as strings but never logged to CloudWatch
- No `logging.getLogger()` or structured log output
- No request logging middleware
- CloudWatch would show nothing useful on cold-start failure

**Recommendation:** Add structured logging at minimum for:
- Cold start success/failure
- Auth rejection events
- Request/response summary

### Error handling

**The error path in `run()` returns a raw string** (lines 37-38):
```python
def run(event, context=None):
    if error:
        return error
```

API Gateway and Lambda URL Functions expect a dict with `statusCode`, `headers`, and `body`. Returning a plain string will produce either:
- A 502 Bad Gateway (API Gateway can't parse it)
- A masked 200 with the error as the body (Lambda URL Function wraps it)

**Fix required:**
```python
if error:
    return {"statusCode": 500, "body": error, "headers": {"Content-Type": "text/plain"}}
```

---

## 7. Key Observations & Recommendations

### What's well done

1. **Clean two-Lambda separation** — fully independent directories, configs, handlers, deploy services
2. **Static assets in separate packages** — discoverable, deployable, testable independently
3. **Deploy__Service pattern** — clean template for Lambda deployment with folder injection
4. **Error capture on cold start** — prevents total Lambda failure on import errors

### Recommendations (priority order)

| # | Priority | Recommendation |
|---|----------|---------------|
| 1 | **P0** | Fix error return in `run()` to return proper `{statusCode: 500}` dict |
| 2 | **P0** | Add structured logging (cold start, auth failures, errors) |
| 3 | **P1** | Use `AWS_LAMBDA_FUNCTION_NAME` instead of `AWS_REGION` for Lambda detection |
| 4 | **P1** | Pin minimum versions in pyproject.toml to match Lambda layers |
| 5 | **P1** | Wire up env var injection in Deploy__Service |
| 6 | **P2** | Complete `requirements-test.txt` or remove in favour of `poetry install` |
| 7 | **P2** | Add CI workflow file (GitHub Actions) |
| 8 | **P2** | Add CORS configuration for the admin Lambda |
