# CI Tagging Strategy — Standalone Reference

**Role:** DevOps
**Version:** v0.3.3
**Date:** 15/02/2026
**Purpose:** Shareable reference document for CI tagging strategy. Designed to be understood independently of other SGraph Send documentation.

---

## Overview

SGraph Send uses **automated Git tagging** as part of its CI/CD pipeline. Every push to `dev` or `main` triggers a pipeline that runs tests, increments a Git tag, and optionally publishes to PyPI and deploys.

Tags are never created manually — the CI pipeline is the sole authority for version tags.

---

## Architecture: Three-File Workflow

The CI system uses a **three-file pattern**: two branch-specific trigger pipelines delegate to one shared base pipeline.

```
.github/workflows/
├── ci-pipeline__dev.yml      # Trigger: push to dev
├── ci-pipeline__main.yml     # Trigger: push to main
└── ci-pipeline.yml           # Shared base pipeline (workflow_call)
```

### Trigger Pipelines

**`ci-pipeline__dev.yml`** — fires on push to `dev` (+ manual dispatch):
```yaml
uses: ./.github/workflows/ci-pipeline.yml
with:
  git_branch          : 'dev'
  release_type        : 'minor'          # patch-level bump
  target_deploy       : 'dev'
  should_increment_tag: true
  should_publish_pypi : false            # no PyPI on dev
secrets: inherit
```

**`ci-pipeline__main.yml`** — fires on push to `main` (+ manual dispatch):
```yaml
uses: ./.github/workflows/ci-pipeline.yml
with:
  git_branch          : 'main'
  release_type        : 'major'          # minor-level bump
  should_increment_tag: true
  should_publish_pypi : true             # publishes to PyPI
  target_deploy       : 'qa'
secrets: inherit
```

### Key Differences by Branch

| Aspect | `dev` branch | `main` branch |
|--------|-------------|---------------|
| Release type | `minor` (patch bump) | `major` (minor bump) |
| Tag example | v0.2.15 → v0.2.16 | v0.2.16 → v0.3.0 |
| PyPI publish | No | Yes |
| Deploy target | `dev` environment | `qa` environment |
| Trigger | Push to `dev` or manual | Push to `main` or manual |

---

## Tag Increment Mechanism

### External Action

Tags are incremented by a reusable GitHub Action from the OWASP OSBot project:

```
owasp-sbot/OSBot-GitHub-Actions/.github/actions/git__increment-tag@dev
```

This action:
1. Reads the latest Git tag on the branch
2. Bumps the appropriate version component based on `release_type`
3. Creates and pushes the new tag

### Release Types

| `release_type` param | What it bumps | Pattern | Example |
|---------------------|---------------|---------|---------|
| `minor` | Third number (patch) | `v0.X.Y → v0.X.(Y+1)` | v0.2.15 → v0.2.16 |
| `major` | Second number (minor), resets third | `v0.X.Y → v0.(X+1).0` | v0.2.16 → v0.3.0 |

> **Note:** Despite the parameter names, `minor` bumps the patch version and `major` bumps the minor version. The first number (major) is only bumped manually for breaking changes.

### Version File

The repository also maintains a version file at `sgraph_ai_app_send/version`. This is updated by the same CI action and used by the Python package for `__version__`.

---

## Pipeline Execution Flow

```
                            ┌─────────────────┐
                            │  Run Unit Tests  │
                            │  (tests/unit/)   │
                            │     ~20s         │
                            └────────┬────────┘
                                     │
                    ┌────────────────┼────────────────┐
                    │                                  │
           ┌────────▼────────┐              ┌─────────▼─────────┐
           │  Increment Tag  │              │ Check AWS Creds   │
           │  (minor/major)  │              │ (4 secrets check) │
           │     ~8s         │              │     ~3s            │
           └────────┬────────┘              └─────────┬─────────┘
                    │                                  │
       ┌────────────┼──────────┐                       │
       │            │          │                       │
┌──────▼──────┐     │          │                       │
│Publish PyPI │     │    ┌─────▼───────────────────────▼──────┐
│(main only)  │     │    │                                     │
└─────────────┘     │    │  ┌─────────────┐  ┌──────────────┐  │
                    │    │  │Admin Lambda  │  │User Lambda   │  │
                    │    │  │Deploy ~49s   │  │Deploy ~41s   │  │
                    │    │  └─────────────┘  └──────────────┘  │
                    │    │       (parallel deployment)          │
                    │    └─────────────────────────────────────┘
                    │
                    └── Total pipeline: ~1m 26s
```

### Job Dependencies

| Job | Depends on | Condition |
|-----|-----------|-----------|
| **Run Unit Tests** | — | Always runs |
| **Increment Tag** | Run Unit Tests | `should_increment_tag: true` |
| **Check AWS Credentials** | Run Unit Tests | Always runs |
| **Publish to PyPI** | Increment Tag | `should_publish_pypi: true` AND tag succeeded |
| **Admin Lambda Deploy** | Increment Tag + Check AWS Creds | AWS credentials exist |
| **User Lambda Deploy** | Increment Tag + Check AWS Creds | AWS credentials exist |

### Critical Ordering

1. **Tag increment happens AFTER tests pass** — failed tests = no tag
2. **Tag increment happens BEFORE deployment** — deployed code is always tagged
3. **Lambda deploys wait for BOTH tag increment AND credential check** — ensures tag exists and AWS is available
4. **Admin and User Lambdas deploy in parallel** — no dependency between them

---

## Graceful Degradation

The pipeline is designed to degrade gracefully when optional resources are missing:

| Scenario | Behaviour |
|----------|-----------|
| Tests fail | Pipeline stops. No tag, no deploy, no publish. |
| AWS credentials missing | Tag increments. PyPI publishes. Deploy is skipped (not failed). |
| `should_publish_pypi: false` | PyPI step is skipped entirely. |
| `should_increment_tag: false` | Tag step is skipped. Deploy still runs (uses existing latest tag). |

This means the pipeline **never fails** due to missing AWS credentials — it just skips deployment. Tag management and PyPI publishing are independent of AWS.

---

## Secrets Required

The pipeline uses **10 GitHub Actions secrets**, passed via `secrets: inherit`:

| Secret | Purpose | Required for |
|--------|---------|-------------|
| `AWS_ACCESS_KEY_ID` | AWS authentication | Lambda deploy |
| `AWS_SECRET_ACCESS_KEY` | AWS authentication | Lambda deploy |
| `AWS_DEFAULT_REGION` | Target AWS region | Lambda deploy |
| `AWS_ACCOUNT_ID` | Account identification | Lambda deploy + credential check |
| `FAST_API__AUTH__API_KEY__NAME` | FastAPI auth key name | Lambda environment |
| `FAST_API__AUTH__API_KEY__VALUE` | FastAPI auth key value | Lambda environment |
| `CACHE__SERVICE__BUCKET_NAME` | Cache service S3 bucket | Lambda environment |
| `SGRAPH_SEND__ADMIN__BASE_URL` | Admin service URL | User Lambda environment |
| `SGRAPH_SEND__ADMIN__API_KEY__NAME` | Admin API key name | User Lambda environment |
| `SGRAPH_SEND__ADMIN__API_KEY__VALUE` | Admin API key value | User Lambda environment |

The **credential check job** validates only the first 4 (AWS-related) secrets.

---

## Deployment Targets

| Target | Triggered by | Lambda stage names | Tag type | PyPI |
|--------|-------------|-------------------|----------|------|
| `dev` | Push to `dev` | `admin-dev`, `user-dev` | minor | No |
| `qa` | Push to `main` | `admin-qa`, `user-qa` | major | Yes |
| `prod` | Manual only | `admin-prod`, `user-prod` | N/A | N/A |

- **dev**: Fully automated. Every push to `dev` triggers the full pipeline.
- **qa**: Fully automated. Every push to `main` triggers pipeline + PyPI publish.
- **prod**: Test classes exist but no CI trigger. Production deployment is manual.

---

## Deployment Mechanism

Deployments are **pytest-driven** — a novel pattern where deployment steps are executed as test methods with assertions.

```
.github/actions/aws__deploy__lambda/action.yml
```

This composite action:
1. Checks out code
2. Sets up Python 3.12
3. Installs dependencies
4. Pulls latest tags
5. Runs `pytest` against the target-specific deploy test

```bash
pytest -rs ./tests/deploy/{lambda_type}__Lambda/deploy_aws/test_Deploy__{lambda_type}__Service__to__{target}.py
```

### Deploy Test Sequence

Each deployment test runs these steps in order:
1. **Check stages** — verify stage name matches target
2. **Upload dependencies** — upload Lambda layer deps to S3
3. **Create Lambda function** — create/update the Lambda function
4. **Update runtime** — upgrade to Python 3.13
5. **Invoke function** — invoke Lambda, verify FastAPI response
6. **Test Function URL** — hit health endpoint, expect `{"status": "ok"}`

---

## Lambda Naming Convention

Lambda function names follow: `{package_name}-{type}-{env}`

| Lambda | Dev | QA | Prod |
|--------|-----|-----|------|
| Admin | `sgraph_ai_app_send-admin-dev` | `sgraph_ai_app_send-admin-qa` | `sgraph_ai_app_send-admin-prod` |
| User | `sgraph_ai_app_send-user-dev` | `sgraph_ai_app_send-user-qa` | `sgraph_ai_app_send-user-prod` |

---

## PyPI Package

- **Package name:** `sgraph-ai-app-send`
- **Published only on `main` branch** pushes
- **Uses trusted publisher** (OIDC via `id-token: write` permission)
- **Action:** `owasp-sbot/OSBot-GitHub-Actions/.github/actions/pypi__publish@dev`

---

## Quick Reference

```
Push to dev  → Tests → Tag (patch bump) → Deploy to dev
Push to main → Tests → Tag (minor bump) → PyPI publish → Deploy to qa
Manual       →                                           → Deploy to prod
```

---

## Source Files

| File | Purpose |
|------|---------|
| `.github/workflows/ci-pipeline.yml` | Base pipeline (all jobs) |
| `.github/workflows/ci-pipeline__dev.yml` | Dev branch trigger |
| `.github/workflows/ci-pipeline__main.yml` | Main branch trigger |
| `.github/actions/aws__deploy__lambda/action.yml` | Lambda deploy composite action |
| `sgraph_ai_app_send/version` | Version file (updated by CI) |
