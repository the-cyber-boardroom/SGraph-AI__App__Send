# AWS Deployment Architecture â€” Documentation and Assessment

**Role:** DevOps
**Version:** v0.2.15
**Date:** 12/02/2026
**Source:** `team/roles/devops/reviews/26-02-12/v0.2.15__briefing__mvp-review-devops-tasks.md`

---

## TASK-1: AWS Deployment Architecture

### 1.1 Pipeline Flow

The CI/CD system uses a **three-file workflow** pattern with two trigger pipelines delegating to one shared base pipeline.

#### Trigger Pipelines

**`ci-pipeline__dev.yml`** (push to `dev` branch + manual dispatch):
```yaml
uses: ./.github/workflows/ci-pipeline.yml
with:
  git_branch          : 'dev'
  release_type        : 'minor'          # minor version bump
  target_deploy       : 'dev'
  should_increment_tag: true
  should_publish_pypi : false            # no PyPI publish on dev
secrets: inherit
```

**`ci-pipeline__main.yml`** (push to `main` branch + manual dispatch):
```yaml
uses: ./.github/workflows/ci-pipeline.yml
with:
  git_branch          : 'main'
  release_type        : 'major'          # major version bump
  should_increment_tag: true
  should_publish_pypi : true             # publishes to PyPI
  target_deploy       : 'qa'
secrets: inherit
```

Key differences:
| Aspect | DEV Pipeline | MAIN Pipeline |
|--------|-------------|---------------|
| Trigger branch | `dev` | `main` |
| Release type | minor | major |
| PyPI publish | No | Yes |
| Deploy target | `dev` | `qa` |

#### Base Pipeline (`ci-pipeline.yml`)

The shared base pipeline orchestrates the following job graph:

```
                                +-----------------+
                                | Run Unit Tests  |
                                |  (tests/unit/)  |
                                +--------+--------+
                                         |
                        +----------------+----------------+
                        |                                 |
               +--------v--------+              +---------v---------+
               | Increment Tag   |              | Check AWS Creds   |
               | (minor or major)|              | (4 secrets check) |
               +--------+--------+              +---------+---------+
                        |                                 |
          +-------------+-------------+                   |
          |             |             |                   |
+---------v---+ +------v------+      |                   |
|Publish PyPI | |             |      |                   |
|(main only)  | |             |      |                   |
+-------------+ |  +----------v------v--------+  +-------v-----------+
                |  | Admin - Deploy AWS Lambda |  | User - Deploy AWS |
                |  | (needs: check-creds,      |  | Lambda (needs:    |
                |  |  increment-tag)           |  |  check-creds,     |
                |  +---------------------------+  |  increment-tag)   |
                |                                 +-------------------+
                +--- (parallel) ------------------+
```

**Execution flow (confirmed working, CI Pipeline - DEV #25, 1m 26s):**
1. **Run Unit Tests** (20s) -- `pytest tests/unit/`
2. **Increment Tag** (8s) -- waits for tests; uses `owasp-sbot/OSBot-GitHub-Actions/.github/actions/git__increment-tag@dev`
3. **Check AWS Credentials** (3s) -- waits for tests; verifies 4 AWS secrets exist
4. **Publish to PyPI** (main only, 0s on dev) -- waits for tag increment
5. **Admin Lambda Deploy** (49s) -- waits for both tag increment AND credential check
6. **User Lambda Deploy** (41s) -- waits for both tag increment AND credential check (runs in parallel with Admin)

Admin and User Lambda deploys run **in parallel** after their shared dependencies complete.

### 1.2 Lambda Deployment Mechanism

The deployment is **pytest-driven** -- a novel pattern where deployments are executed as test methods. This ensures the deployment itself is tested (assertions on every step) and repeatable.

#### The Composite Action (`.github/actions/aws__deploy__lambda/action.yml`)

This GitHub Actions composite action:
1. Checks out the code
2. Sets up Python 3.12
3. Installs test + package dependencies (`requirements-test.txt` + `pip install -e .`)
4. Updates the branch (pulls latest tags via `git__update_branch`)
5. Runs `pytest` against the target-specific deploy test:
   ```bash
   pytest -rs ./tests/deploy/{lambda_type}__Lambda/deploy_aws/test_Deploy__{lambda_type}__Service__to__{target}.py
   ```

Inputs:
- `lambda_type`: `Admin` or `User`
- `target`: `dev`, `qa`, or `prod`

#### Deploy Test Hierarchy

**Base class** (shared by Admin and User):
```
test_Deploy__{Admin|User}__Service__base
  test_1__check_stages()          -- Verify stage name matches
  test_2__upload_dependencies()   -- Upload Lambda layer deps to S3
  test_4_create__lambda_function() -- Create/update the Lambda function
  test_5__update_lambda_runtime__to_3_13() -- Upgrade runtime to Python 3.13
  test_6__invoke()                -- Invoke Lambda, verify FastAPI response
  test_7__invoke__function_url()  -- Hit Function URL at /info/health, expect {"status": "ok"}
```

Note: `test_3__create_lambda_iam_user()` and `test_8__delete()` are commented out -- IAM role creation is manual/pre-existing, and deletion is not automated yet.

**Target classes** (one per environment):
```python
# Admin targets
test_Deploy__Admin__Service__to__dev  (stage='admin-dev')
test_Deploy__Admin__Service__to__qa   (stage='admin-qa')
test_Deploy__Admin__Service__to__prod (stage='admin-prod')

# User targets
test_Deploy__User__Service__to__dev   (stage='user-dev')
test_Deploy__User__Service__to__qa    (stage='user-qa')
test_Deploy__User__Service__to__prod  (stage='user-prod')
```

#### Deploy__Service Classes

Both Admin and User have a `Deploy__Service` class that extends `Deploy__Serverless__Fast_API` from `osbot-fast-api-serverless`:

```python
class Deploy__Service(Deploy__Serverless__Fast_API):
    def deploy_lambda(self):
        with super().deploy_lambda() as _:
            _.add_folder(sgraph_ai_app_send__ui__{admin|user}.path)  # Include UI assets
            return _

    def handler(self):
        return run                    # The Lambda handler function

    def lambda_dependencies(self):
        return APP__SEND__{ADMIN|USER}__LAMBDA_DEPENDENCIES

    def lambda_name(self):
        return APP__SEND__{ADMIN|USER}__SERVICE_NAME
```

The deployment sequence (orchestrated by `Deploy__Serverless__Fast_API`):
1. Upload Lambda dependencies (layers) to S3
2. Create/update the Lambda function with code + handler + layers
3. Update runtime to Python 3.13
4. Invoke the function to verify it responds
5. Hit the Function URL to verify health endpoint

#### Lambda Dependencies

Both Admin and User Lambdas share the same dependency set:
```python
['httpx==0.28.1',
 'memory-fs==v0.40.0',
 'osbot-fast-api-serverless==v1.33.0']
```

These are uploaded as Lambda layers to S3, then attached to the Lambda function.

#### Lambda Naming Convention

The Lambda function name is derived from `package_name = 'sgraph_ai_app_send'`, combined with the stage:
- Admin dev: `sgraph_ai_app_send-admin-dev`
- User dev: `sgraph_ai_app_send-user-dev`
- (similarly for qa and prod)

### 1.3 AWS Resources

#### Currently Provisioned

| Resource | Purpose | Notes |
|----------|---------|-------|
| **Lambda Functions** (2 per env) | Admin + User FastAPI apps | Python 3.13 runtime, Mangum adapter |
| **Lambda Function URLs** | Direct HTTPS endpoints | No API Gateway needed |
| **S3 Bucket** (dependencies) | Lambda layer storage | Stores dependency ZIPs for Lambda layers |
| **IAM Role** | Lambda execution role | Pre-existing; `test_3__create_lambda_iam_user` is commented out |

#### Not Yet Provisioned (Future)

| Resource | Purpose | Brief Reference |
|----------|---------|-----------------|
| **S3 Bucket** (file storage) | Memory-FS S3 backend for encrypted file transfers | v0.2.4 brief |
| **CloudFront** | CDN for Lambda Function URLs | v0.2.4 brief |
| **IAM Policies** (locked down) | Least-privilege for Lambda runtime + deployment | v0.2.4 brief |
| **DNS/Certificates** | send.sgraph.ai routing | Deferred |

### 1.4 Secrets Management

The pipeline uses **7 GitHub Actions secrets**, passed via `secrets: inherit`:

| Secret | Purpose | Used By |
|--------|---------|---------|
| `AWS_ACCESS_KEY_ID` | AWS authentication | Deploy action |
| `AWS_SECRET_ACCESS_KEY` | AWS authentication | Deploy action |
| `AWS_DEFAULT_REGION` | Target AWS region | Deploy action |
| `AWS_ACCOUNT_ID` | Account identification | Deploy action, credential check |
| `FAST_API__AUTH__API_KEY__NAME` | FastAPI auth key name | Lambda environment |
| `FAST_API__AUTH__API_KEY__VALUE` | FastAPI auth key value | Lambda environment |
| `AUTH__TARGET_SERVER__CACHE_SERVICE__BASE_URL` | Cache service URL | Lambda env (as `URL__TARGET_SERVER__CACHE_SERVICE`) |

The **credential check job** only validates the first 4 (AWS-related) secrets. If any are missing, Lambda deployment is skipped gracefully (the pipeline still succeeds for tag increment and PyPI publish).

Secret mapping note: `AUTH__TARGET_SERVER__CACHE_SERVICE__BASE_URL` is mapped to `URL__TARGET_SERVER__CACHE_SERVICE` environment variable in the deploy action.

### 1.5 Deployment Targets

| Target | Triggered By | Stage Names | Tag Type | PyPI |
|--------|-------------|-------------|----------|------|
| `dev` | Push to `dev` branch | `admin-dev`, `user-dev` | minor | No |
| `qa` | Push to `main` branch | `admin-qa`, `user-qa` | major | Yes |
| `prod` | Manual (test classes exist but not wired to CI) | `admin-prod`, `user-prod` | N/A | N/A |

Current state:
- **dev**: Fully automated. Push to `dev` triggers test + deploy. Confirmed working.
- **qa**: Pipeline exists. Push to `main` triggers test + deploy + PyPI publish.
- **prod**: Test classes exist (`test_Deploy__*__Service__to__prod.py`) but no CI trigger yet. Production deployment would require a separate workflow or manual execution.

### 1.6 Tag Management

Tags are managed by `owasp-sbot/OSBot-GitHub-Actions/.github/actions/git__increment-tag@dev`:

| Branch | Release Type | Tag Pattern | Example |
|--------|-------------|-------------|---------|
| `dev` | minor | `v0.X.Y` | v0.2.15 -> v0.2.16 |
| `main` | major | `vX.Y.0` | v0.2.15 -> v0.3.0 |

The tag increment happens **after tests pass** but **before deployment**, ensuring the deployed code is always tagged.

---

## TASK-2: Cross-Reference with DevOps Productization Brief (v0.2.4)

### 2.1 What the v0.2.4 Brief Requires

The brief (dated 11 Feb 2026) calls for a fully **productized, declarative, testable** deployment system with:

1. **Class architecture**: `app__deploy__aws__<component>` with uniform lifecycle methods
2. **Common pattern**: `create()`, `exists()`, `verify()`, `lock_down()`, `delete()`, `verify_deleted()`
3. **Configuration layers**: Base (project-wide) + Specific (per-Lambda)
4. **Deployment orchestrator**: Sequences component creation/deletion in dependency order
5. **Testing**: LocalStack for unit tests, real AWS for integration tests
6. **Round-trip**: create -> verify -> delete -> verify_deleted -> create again
7. **Multi-region**: Same orchestrator, different region config
8. **Components**: IAM, S3, Lambda, CloudFront

### 2.2 Gap Analysis: What Exists vs What Is Outstanding

#### Already Addressed (Partially or Fully)

| v0.2.4 Requirement | Current Status | Evidence |
|---------------------|---------------|----------|
| Lambda deployment (create) | **Working** | `Deploy__Service.create()` via `Deploy__Serverless__Fast_API` |
| Lambda verification (invoke) | **Working** | `test_6__invoke()` and `test_7__invoke__function_url()` |
| Lambda dependencies (S3 upload) | **Working** | `test_2__upload_dependencies()` |
| Two Lambda deployments (Admin + User) | **Working** | Separate `Deploy__Service` classes per Lambda |
| Per-environment config (dev/qa/prod) | **Working** | Stage-based naming (`admin-dev`, `user-qa`, etc.) |
| CI/CD integration | **Working** | `ci-pipeline.yml` automates test -> tag -> deploy |
| Python runtime update | **Working** | `test_5__update_lambda_runtime__to_3_13()` |
| osbot-aws usage (not raw boto3) | **Working** | All deploy code uses osbot-aws / osbot-fast-api-serverless |
| Type_Safe patterns | **Partial** | `Deploy__Serverless__Fast_API` uses Type_Safe internally |

#### Outstanding (Not Yet Implemented)

| v0.2.4 Requirement | Gap | Priority |
|---------------------|-----|----------|
| **`exists()` method** for Lambda | Not exposed in test sequence | High |
| **`verify()` method** (correctness check, not just existence) | No verification of configuration correctness | High |
| **`lock_down()` method** for Lambda | No security hardening step | Medium |
| **`delete()` method** for Lambda | Commented out in test base | High |
| **`verify_deleted()` method** | Not implemented | High |
| **IAM component class** (`app__deploy__aws__iam`) | IAM role creation is commented out; no lifecycle | High |
| **S3 component class** (`app__deploy__aws__s3`) | S3 bucket for file storage not provisioned | High |
| **CloudFront component class** (`app__deploy__aws__cloudfront`) | Not started | Medium |
| **Deployment orchestrator** | No sequencing class; each component deployed independently | High |
| **Base/specific config split** | Config exists per-Lambda but not structured as base + specific | Medium |
| **`app__deploy__aws__*` naming convention** | Classes use existing `Deploy__Service` naming | Low |
| **LocalStack unit tests** | No LocalStack setup; tests are real-AWS only | Medium |
| **Round-trip test** (create -> delete -> create again) | delete() is commented out; no round-trip | High |
| **Multi-region support** | Single region only; no region-agnostic config | Low |
| **Production deployment trigger** | prod test classes exist but no CI trigger | Medium |

### 2.3 Proposed Implementation Roadmap

#### Phase A: Lifecycle Completion (Priority: High)

**Goal**: Complete the 6-method lifecycle pattern for Lambda and IAM.

1. **Uncomment and fix `delete()`** in both Admin and User deploy test bases
2. **Implement `exists()` method** -- check if Lambda function exists before create/update
3. **Implement `verify()` method** -- verify configuration matches expected (runtime, handler, memory, timeout, layers, environment variables, Function URL config)
4. **Implement `verify_deleted()` method** -- confirm function is gone after delete
5. **Implement `lock_down()` method** -- apply resource policy restrictions on Function URL
6. **Enable IAM role lifecycle** -- uncomment `test_3__create_lambda_iam_user()`, implement full create/exists/verify/delete cycle

Deliverables:
- Extended `Deploy__Service` with `exists()`, `verify()`, `lock_down()`, `delete()`, `verify_deleted()`
- Round-trip test: create -> verify -> delete -> verify_deleted -> create -> verify

#### Phase B: Component Architecture (Priority: High)

**Goal**: Restructure into the `app__deploy__aws__<component>` class hierarchy.

1. **Create base config class** -- project-wide settings (account ID, project name, region, tags)
2. **Create per-deployment config** -- Admin-specific and User-specific settings
3. **Create `app__deploy__aws__lambda`** -- wraps current Deploy__Service with full lifecycle
4. **Create `app__deploy__aws__iam`** -- IAM role lifecycle
5. **Create `app__deploy__aws__s3`** -- S3 bucket lifecycle (for Memory-FS storage)
6. **Create deployment orchestrator** -- sequences: IAM -> S3 -> Lambda -> CloudFront

#### Phase C: S3 Storage Backend (Priority: High, blocking)

**Goal**: Add S3 bucket for Memory-FS to enable multi-instance Lambda support.

(See TASK-3 below for detailed assessment)

#### Phase D: Testing Infrastructure (Priority: Medium)

**Goal**: LocalStack-based unit tests + real-AWS integration tests.

1. **Set up LocalStack** in CI (Docker service container)
2. **Mirror component tests** against LocalStack
3. **Full round-trip integration test** against real AWS (create -> verify -> delete -> verify_deleted -> create)

#### Phase E: CloudFront + Multi-Region (Priority: Low)

**Goal**: CDN layer and region-agnostic deployment.

1. **Create `app__deploy__aws__cloudfront`** -- CloudFront distribution lifecycle
2. **Abstract region out of config** -- make region a parameter, not a constant
3. **Matrix deployment** -- deploy to N regions in parallel

---

## TASK-3: Memory-FS S3 Storage Backend Assessment

### 3.1 Current State

The current MVP uses **in-memory storage** (`Storage_FS__Memory`). This means:
- Every file upload goes to the RAM of a specific Lambda instance
- Downloads must hit the **same** Lambda instance (no instance sharing)
- Data is lost when the Lambda instance is recycled
- This is acceptable for demo/proof-of-concept but not for production

### 3.2 S3 Resources Required

#### S3 Bucket

| Setting | Value | Rationale |
|---------|-------|-----------|
| Bucket name | `sgraph-send-{env}-storage` (e.g., `sgraph-send-dev-storage`) | Per-environment isolation |
| Region | Same as Lambda region | Minimize latency |
| Versioning | Disabled | Not needed; Memory-FS handles its own versioning |
| Encryption | SSE-S3 (AES-256) | Encrypted at rest; data is already client-side encrypted |
| Public access | Blocked (all 4 settings) | No public access; all access via Lambda IAM role |
| Lifecycle rules | Auto-delete after N days (configurable per env) | TTL for transfer objects |
| Object lock | Not required | Files are already encrypted ciphertext |

#### IAM Policy (Lambda Execution Role)

The Lambda execution role needs an S3 policy scoped to the storage bucket:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::sgraph-send-{env}-storage",
        "arn:aws:s3:::sgraph-send-{env}-storage/*"
      ]
    }
  ]
}
```

This follows the Memory-FS `Storage_FS__S3` interface requirements:
- `file__save()` -> `s3:PutObject`
- `file__bytes()` / `file__json()` / `file__str()` -> `s3:GetObject`
- `file__delete()` -> `s3:DeleteObject`
- `files__paths()` -> `s3:ListBucket`
- `file__exists()` -> `s3:GetObject` (head request) or `s3:ListBucket`

#### CORS Configuration

Since the server (Lambda) accesses S3 directly (not the browser), **no CORS configuration is needed on the S3 bucket**. The architecture is:

```
Browser --[encrypted data]--> Lambda Function URL --[stores via Memory-FS]--> S3
Browser <--[encrypted data]-- Lambda Function URL <--[reads via Memory-FS]-- S3
```

The browser never touches S3 directly. All S3 access is server-side via the Lambda execution role. CORS is handled on the Lambda Function URL itself, not on S3.

If the architecture later changes to use **pre-signed S3 URLs** (browser uploads directly to S3), then CORS would be needed:
```json
[
  {
    "AllowedOrigins": ["https://send.sgraph.ai"],
    "AllowedMethods": ["GET", "PUT"],
    "AllowedHeaders": ["*"],
    "ExposeHeaders": ["ETag"],
    "MaxAgeSeconds": 3600
  }
]
```

But for the current Memory-FS integration path, this is not needed.

### 3.3 Memory-FS S3 Integration Code

Based on the Memory-FS architecture document (v0.36.2), the integration is straightforward:

```python
from memory_fs.storage_fs.providers.Storage_FS__S3 import Storage_FS__S3
from memory_fs.helpers.Memory_FS__Latest           import Memory_FS__Latest

# In the Lambda function initialization:
storage_s3 = Storage_FS__S3(
    bucket_name = "sgraph-send-dev-storage",
    prefix      = "transfers/"
)
memory_fs = Memory_FS__Latest()
memory_fs.set_storage(storage_s3)
```

The application code (`Storage_FS` interface) does not change -- it already works with the in-memory backend and will work identically with S3.

### 3.4 Fit Into the Deployment Orchestrator

The S3 bucket should be a first-class component in the deployment orchestrator, created **before** Lambda (since Lambda depends on having the bucket):

**Creation order:**
1. IAM Role (Lambda execution role)
2. S3 Bucket (storage for Memory-FS + dependencies)
3. Lambda Functions (Admin + User, with IAM role + S3 bucket reference)
4. CloudFront (optional, CDN in front of Lambda Function URLs)

**Deletion order (reverse):**
1. CloudFront
2. Lambda Functions
3. S3 Bucket (must be emptied first)
4. IAM Role

The `app__deploy__aws__s3` component class should implement the full lifecycle:

| Method | Implementation |
|--------|---------------|
| `create()` | Create bucket with encryption, block public access, lifecycle rules |
| `exists()` | `s3.head_bucket()` |
| `verify()` | Check encryption, public access block, lifecycle rules match expected |
| `lock_down()` | Verify bucket policy denies non-SSL access; block public access |
| `delete()` | Empty bucket (delete all objects), then delete bucket |
| `verify_deleted()` | Confirm `head_bucket()` returns 404 |

### 3.5 Configuration

The S3 bucket configuration should be part of the **base config** (shared across Admin and User) since both Lambda functions write to the same bucket:

```
Base Config:
  account_id       : from AWS_ACCOUNT_ID
  region           : from AWS_DEFAULT_REGION
  project_name     : "sgraph-send"
  environment      : "dev" | "qa" | "prod"
  storage_bucket   : "sgraph-send-{env}-storage"

Per-Lambda Config (extends Base):
  lambda_name      : "sgraph_ai_app_send-{type}-{env}"
  lambda_type      : "admin" | "user"
  ui_assets_path   : path to UI static files
  dependencies     : Lambda layer dependency list
```

---

## Summary of Findings

### What Is Working Well

1. **CI/CD pipeline** -- fully automated test -> tag -> deploy for dev and qa
2. **Pytest-driven deployment** -- deployment assertions catch failures early
3. **Parallel Lambda deployment** -- Admin and User deploy simultaneously
4. **Graceful degradation** -- missing AWS credentials skip deploy without failing pipeline
5. **Secret management** -- 7 secrets cleanly separated; credential check before deploy
6. **Tag management** -- automated minor/major versioning tied to branch

### Key Gaps (Ordered by Priority)

1. **No `delete()`/`verify_deleted()` lifecycle** -- cannot destroy and recreate (blocking round-trip)
2. **No S3 storage bucket** -- blocking multi-instance Lambda support (users must hit same instance)
3. **No deployment orchestrator** -- components deployed independently, not sequenced
4. **No IAM automation** -- roles created manually, not part of lifecycle
5. **No LocalStack testing** -- all deploy tests require real AWS credentials
6. **No production deployment trigger** -- test classes exist but no CI workflow
7. **No CloudFront** -- Lambda Function URLs exposed directly

### Recommended Next Steps

1. **Immediate**: Implement S3 bucket provisioning (unblocks multi-instance)
2. **Short-term**: Complete Lambda lifecycle (exists/verify/delete/verify_deleted)
3. **Short-term**: Create deployment orchestrator with creation/deletion ordering
4. **Medium-term**: Add IAM role lifecycle automation
5. **Medium-term**: Set up LocalStack in CI
6. **Later**: CloudFront, multi-region, production triggers

---

## Issues Created

The following issues have been created in `team/roles/devops/.issues/issues/`:

| Issue | Title | Priority | Status |
|-------|-------|----------|--------|
| Task-1 | Implement S3 storage bucket provisioning | P0 | backlog |
| Task-2 | Complete Lambda lifecycle methods | P0 | backlog |
| Task-3 | Create deployment orchestrator class | P1 | backlog |
| Task-4 | Automate IAM role lifecycle | P1 | backlog |
| Task-5 | Set up LocalStack testing in CI | P2 | backlog |
| Task-6 | Add production deployment CI trigger | P2 | backlog |
| Task-7 | Implement CloudFront component class | P3 | backlog |

See: `team/roles/devops/.issues/issues/Task-{1..7}/issue.json`
