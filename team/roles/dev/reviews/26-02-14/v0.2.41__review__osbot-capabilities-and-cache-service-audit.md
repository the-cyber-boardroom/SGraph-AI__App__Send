# v0.2.41 — Dev Review: osbot-* Capabilities & Cache Service Audit

**Version:** v0.2.41
**Date:** 14 February 2026
**Role:** Dev
**Context:** Audit of all osbot-* package capabilities and MGraph-AI cache service features currently used by SGraph Send

---

## 1. Executive Summary

SGraph Send uses **four osbot-* packages** and **two MGraph-AI cache packages** as its foundation. This review catalogues every capability we use, identifies underutilised features, and flags areas where we could leverage more from these libraries rather than building custom code.

The headline finding: we're using the osbot ecosystem well for its core patterns (Type_Safe, routes, serverless deployment), but we've barely scratched the surface of the cache service's storage strategies and the Service Registry's full capability set.

---

## 2. Package Inventory

### Direct Dependencies (pyproject.toml)

| Package | Purpose |
|---------|---------|
| `osbot-utils` | Type system, safe primitives, utilities |
| `osbot-fast-api-serverless` | Serverless FastAPI base class, deployment |

### Transitive Dependencies

| Package | Pulled In By | Purpose |
|---------|-------------|---------|
| `osbot-fast-api` | osbot-fast-api-serverless | Routes, decorators, Service Registry, auth |
| `osbot-aws` | osbot-fast-api-serverless | AWS S3, Lambda, config (no direct boto3) |

### Cache Service Dependencies

| Package | Purpose |
|---------|---------|
| `mgraph-ai-service-cache` | In-process cache service (FastAPI app) |
| `mgraph-ai-service-cache-client` | Client facade for cache service API |

---

## 3. osbot-utils: What We Use

### 3.1 Type_Safe — The Foundation

Every data container in the application extends `Type_Safe`. This is the single most important osbot capability we use.

**Files using Type_Safe as base class (15+):**

| Category | Classes | Files |
|----------|---------|-------|
| Schemas | `Schema__Transfer`, `Schema__Transfer__Event`, `Schema__Transfer__Transparency`, `Schema__Transfer__Create` | `lambda__user/schemas/` |
| Schemas | `Schema__Token__Metadata`, `Schema__Token__Create__Request`, `Schema__Token__Usage_Event` | `lambda__admin/schemas/` |
| Schemas | `Schema__Analytics__Pulse`, `Schema__Analytics__Raw_Event` | `lambda__admin/schemas/` |
| Services | `Transfer__Service`, `Service__Tokens`, `Admin__Service__Client`, `Send__Cache__Client` | Both lambdas |
| Config | `Send__Config` | `lambda__user/storage/` |
| Utils | `Version` | `utils/` |

**What Type_Safe gives us:**
- Declarative field definitions with type enforcement
- Default values that appear in Swagger UI (important for `usage_limit=50`)
- No Pydantic dependency — lighter, no validation surprises
- Consistent `json()` serialisation across all data objects

### 3.2 Safe Primitives — Domain-Specific Types

After the v0.2.41 Type_Safe audit, we migrated from generic `str`/`int` to domain-specific safe types:

| Primitive | Used For | Files |
|-----------|----------|-------|
| `Safe_UInt` | Counters (download_count, usage_count, usage_limit) | 6 schema files, 2 route files |
| `Safe_UInt__FileSize` | File sizes (bytes) — gives `.to_kb()`, `.to_mb()` for free | Schema__Transfer, Schema__Transfer__Transparency |
| `Safe_Str__Id` | Token names, transfer IDs, event IDs, status codes, action names | All schema + route files |
| `Safe_Str__File__Path` | Storage paths, URL paths | Storage_FS__S3, Schema__Transfer, Schema__Analytics__Raw_Event |
| `Safe_Str__Http__Content_Type` | MIME types (preserves `/`) | Schema__Transfer |
| `Safe_Str__Http__User_Agent` | Browser user-agent strings (preserves `/`, `()`, `;`) | Schema__Transfer__Event |
| `Safe_Str__Cache_Hash` | SHA-256 hashes (ip_hash) | Schema__Transfer__Transparency, Schema__Analytics__Raw_Event |
| `Safe_Str__Version` | Version strings | Version.py |
| `Random_Guid` | UUID generation | Transfer_Id.py |
| `Timestamp_Now` | ISO timestamps (milliseconds) | Event and analytics schemas |

**Lesson learned (from v0.2.41 session):** `Safe_Str__Id` strips `/`, `:`, `+`. Always test safe types with real data. We caught this when MIME types and URL paths were silently stripped.

### 3.3 Utilities

| Module | Functions Used | Where |
|--------|---------------|-------|
| `osbot_utils.utils.Env` | `get_env()`, `set_env()`, `load_dotenv()` | Config files, deploy, tests |
| `osbot_utils.utils.Files` | `file_contents()`, `path_combine()`, `parent_folder()`, `file_exists()` | Version.py, tests |
| `osbot_utils.utils.Json` | `bytes_to_json()` | Storage_FS__S3.py |
| `osbot_utils.utils.Misc` | `list_set()` | Tests |
| `osbot_utils.helpers.cache.Cache__Hash__Generator` | `from_string()` | Send__Cache__Client, Send__Cache__Setup |

### 3.4 Type_Safe Decorators

```python
from osbot_utils.type_safe.type_safe_core.decorators.type_safe import type_safe

@type_safe
def file__bytes(self, path: Safe_Str__File__Path) -> bytes:
```

Used in `Storage_FS__S3.py` to enforce type safety on method parameters and return values at runtime.

---

## 4. osbot-fast-api: What We Use

### 4.1 Routes Base Class

All three route classes extend `Fast_API__Routes`:

```python
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes
```

| Route Class | Methods | Lambda |
|-------------|---------|--------|
| `Routes__Transfers` | `create`, `info__transfer_id`, `upload__transfer_id`, `complete__transfer_id`, `download__transfer_id` | User |
| `Routes__Tokens` | `create`, `lookup__token_name`, `use`, `revoke__token_name`, `list_all` | Admin |
| `Routes__Analytics` | `pulse` | Admin |

**Pattern:** `self.add_route_post(self.create)` and `self.add_route_get(self.info__transfer_id)` — the base class handles path registration, OpenAPI schema generation, and HTTP method binding.

### 4.2 Route Decorators

```python
from osbot_fast_api.api.decorators.route_path import route_path
```

Used for:
- Root redirect (`/` → latest version page)
- Console redirect (`/send` → latest version page)
- Health pulse endpoint (`/health/pulse`)

### 4.3 Built-in Routes

```python
from osbot_fast_api.api.routes.Routes__Set_Cookie import Routes__Set_Cookie
```

Added to both lambdas — provides cookie management for auth flows.

### 4.4 Service Registry — The Most Powerful Feature

This is the feature that makes our two-Lambda architecture testable without mocks.

```python
from osbot_fast_api.services.registry.Fast_API__Service__Registry import (
    Fast_API__Service__Registry__Client__Config,
    fast_api__service__registry
)
from osbot_fast_api.services.schemas.registry.enums.Enum__Fast_API__Service__Registry__Client__Mode import (
    Enum__Fast_API__Service__Registry__Client__Mode
)
```

**Two modes:**

| Mode | Usage | Latency |
|------|-------|---------|
| `IN_MEMORY` | Tests + cache service in prod | Microseconds (same-process function call) |
| `REMOTE` | Admin Lambda from user Lambda (prod) | 50-100ms (HTTP over Lambda URL) |

**What the registry does:**
1. Register a service with a config (mode, URL, API key, or in-memory FastAPI instance)
2. Client code calls methods on a facade (`Cache__Service__Client`, `Admin__Service__Client`)
3. The facade looks up the registry at request time and dispatches to either TestClient (in-memory) or httpx (remote)
4. Application code is identical in both modes — zero code awareness of deployment topology

**Used in:**
- `Send__Cache__Setup.py` — registers cache service in IN_MEMORY mode
- `Admin__Service__Client__Setup.py` — registers admin service (REMOTE in prod, IN_MEMORY in tests)

### 4.5 Client Transport Layer

```python
from osbot_fast_api.services.registry.Fast_API__Client__Requests import Fast_API__Client__Requests
```

`Admin__Service__Client__Requests` extends this — inherits the IN_MEMORY/REMOTE dispatch logic automatically.

### 4.6 Auth Constants

```python
from osbot_fast_api.api.schemas.consts.consts__Fast_API import (
    ENV_VAR__FAST_API__AUTH__API_KEY__NAME,
    ENV_VAR__FAST_API__AUTH__API_KEY__VALUE
)
```

Used in test setup for admin API authentication.

---

## 5. osbot-fast-api-serverless: What We Use

### 5.1 Serverless Base Class

Both Lambda functions extend `Serverless__Fast_API`:

```python
from osbot_fast_api_serverless.fast_api.Serverless__Fast_API import Serverless__Fast_API
```

**What it provides:**
- `self.config` — FastAPI configuration (name, version, description, API key toggle)
- `self.app()` — Starlette/FastAPI application instance
- `self.add_routes()` — Register route classes with dependency injection
- `self.handler()` — Mangum Lambda handler for AWS Lambda Function URLs
- CORS, error handling, OpenAPI spec generation

### 5.2 Routes__Info

```python
from osbot_fast_api_serverless.fast_api.routes.Routes__Info import Routes__Info
```

Provides `/info/health` endpoint on both lambdas. Used in smoke tests to verify deployment health.

### 5.3 Deployment Base Class

```python
from osbot_fast_api_serverless.deploy.Deploy__Serverless__Fast_API import Deploy__Serverless__Fast_API
```

Both lambdas' `Deploy__Service` classes extend this:
- `super().deploy_lambda()` — context manager for Lambda deployment
- `_.add_folder()` — bundle UI assets into Lambda package
- `_.set_env_variable()` — configure Lambda environment variables

---

## 6. osbot-aws: What We Use

### 6.1 AWS Configuration

```python
from osbot_aws.AWS_Config import aws_config
```

- `aws_config.aws_configured()` — detect if running in AWS (triggers S3 backend)
- `aws_config.account_id()` — for S3 bucket naming
- `aws_config.region_name()` — for bucket creation region

### 6.2 S3 Client

```python
from osbot_aws.aws.s3.S3 import S3
```

Used exclusively in `Storage_FS__S3` — the S3 backend for Memory-FS:

| Method | Purpose |
|--------|---------|
| `bucket_exists()` | Check bucket before creation |
| `bucket_create()` | Create S3 bucket with region |
| `file_exists()` | Check transfer existence |
| `file_bytes()` | Read encrypted payload |
| `file_create_from_bytes()` | Upload encrypted payload |
| `file_delete()` | Delete transfer |
| `file_contents()` | Read metadata JSON |
| `find_files()` | List transfers by prefix |
| `files_delete()` | Batch cleanup |

**Critical rule:** No direct boto3 calls anywhere in the codebase. All S3 operations go through `osbot_aws.aws.s3.S3`.

### 6.3 Lambda Dependency Loader

```python
from osbot_aws.aws.lambda_.boto3__lambda import load_dependencies
```

Lazy-loads pinned dependencies into the Lambda environment at cold start.

---

## 7. MGraph-AI Cache Service: What We Use

### 7.1 Cache Service (In-Process)

```python
from mgraph_ai_service_cache.fast_api.Cache_Service__Fast_API import Cache_Service__Fast_API
```

The entire cache service runs in-process inside the user Lambda via `IN_MEMORY` mode. This gives us:
- Zero-latency analytics recording (microseconds, not milliseconds)
- No separate infrastructure to manage
- Same Memory-FS abstraction as the transfer service

### 7.2 Cache Client

```python
from mgraph_ai_service_cache_client.client.cache_client.Cache__Service__Client import Cache__Service__Client
```

The client facade wraps all cache service API calls. Our `Send__Cache__Client` is a thin Type_Safe wrapper that adds domain-specific methods.

### 7.3 Storage Strategies We Use

| Strategy | Namespace | Purpose |
|----------|-----------|---------|
| `temporal` | `analytics` | Raw HTTP events — auto-filed by `year/month/day/hour` |
| `key_based` | `tokens` | Token metadata — keyed by hash of token name |
| `key_based` | `costs` | AWS cost data |
| `key_based` | `transfers` | Per-transfer analytics summaries |

### 7.4 Namespaces

```python
NS_ANALYTICS  = 'analytics'   # Raw events + aggregations
NS_TOKENS     = 'tokens'      # Token metadata + usage events
NS_COSTS      = 'costs'       # AWS cost data
NS_TRANSFERS  = 'transfers'   # Per-transfer analytics summaries
```

### 7.5 Send__Cache__Client Methods

| Method | Strategy | Purpose |
|--------|----------|---------|
| `analytics__record_event(event_data)` | temporal | Record raw HTTP event |
| `analytics__list_recent_files(path_prefix)` | — | List analytics files |
| `analytics__retrieve_event(cache_id)` | — | Retrieve single event |
| `token__create(token_data)` | key_based | Create token |
| `token__lookup(token_name)` | — | Lookup token by name (via hash) |
| `token__lookup_cache_id(token_name)` | — | Get cache_id for token |
| `token__update(cache_id, token_data)` | — | Update token metadata |
| `token__use(token_name, usage_event_data)` | — | Record token usage (child data) |
| `token__revoke(token_name)` | — | Revoke token |
| `token__list_all()` | — | List all tokens |

### 7.6 Hash Generator

```python
from osbot_utils.helpers.cache.Cache__Hash__Generator import Cache__Hash__Generator
```

Used for token name → cache key resolution. `hash_generator.from_string(token_name)` produces a deterministic hash that the cache service uses for content-addressable storage lookups.

### 7.7 Analytics Middleware

`Middleware__Analytics` intercepts every HTTP request and writes a raw event via `send_cache_client.analytics__record_event()`. Wrapped in try/except — analytics failures never block user-facing transfers.

Event structure:
```python
event_data = dict(
    event_id                = secrets.token_hex(8),
    event_type              = classify_event_type(path, method),
    path                    = path,
    method                  = method,
    status_code             = response.status_code,
    duration_ms             = duration,
    ip_hash                 = hash_ip(client_ip),
    user_agent_normalised   = normalise_user_agent(user_agent),
    content_bytes           = int(response.headers.get('content-length', 0)),
    transfer_id             = '',
    token_id                = ''
)
```

---

## 8. Capabilities We're NOT Yet Using

These are features available in the osbot ecosystem that we haven't adopted:

| Package | Feature | Potential Use |
|---------|---------|---------------|
| `osbot-utils` | `Safe_Str__Iso_Timestamp` | Doesn't exist yet — ISO strings remain as `str` |
| `osbot-fast-api` | Middleware chain beyond analytics | Rate limiting, request logging |
| `mgraph-ai-service-cache` | `TEMPORAL_LATEST` strategy | Real-time dashboard pulse (overwrite semantics) |
| `mgraph-ai-service-cache` | Content-addressable deduplication | Duplicate transfer detection |
| `mgraph-ai-service-cache` | `REMOTE` mode | Extract cache to separate Lambda (future scale) |
| `osbot-fast-api` | WebSocket routes | Real-time transfer progress |

---

## 9. IFD Version Bump: v0.1.3 → v0.1.4

As part of this session, the frontend was bumped from v0.1.3 to v0.1.4 following IFD methodology:

**What changed:**
- Created `sgraph_ai_app_send__ui__user/v0/v0.1/v0.1.4/` — copy of v0.1.3 with version references updated
- Updated `user__config.py`: `APP_SEND__UI__USER__LATEST__VERSION = "v0.1.4"`
- Updated test assertion in `test__App_Send__UI__User__static_pages.py`
- v0.1.3 is now locked (no further changes)
- v0.1.0 shared assets (CSS, crypto.js, api-client.js, components) remain untouched

**Files in v0.1.4:**
- `index.html`, `download.html` — identical to v0.1.3 (reference `../v0.1.0/` for shared assets)
- `js/i18n.js` — version comment updated to v0.1.4
- `i18n/en.json`, `pt.json`, `pt-PT.json`, `tlh.json` — unchanged
- `components/send-upload/send-upload.js` — download URLs point to v0.1.4
- `components/send-download/send-download.js` — "Send your own" link points to v0.1.4

---

## 10. Summary

The osbot-* ecosystem provides the structural foundation for SGraph Send:

1. **Type_Safe** replaces Pydantic with a lighter, more predictable type system
2. **Service Registry** enables zero-mock testing of multi-Lambda architectures
3. **Serverless__Fast_API** handles all Lambda/Mangum plumbing
4. **osbot-aws S3 client** abstracts away boto3
5. **MGraph-AI Cache Service** provides temporal + key-based storage with zero custom path management

The architecture is clean: application code never touches boto3, never constructs S3 paths directly, never knows whether it's running in-memory or against a live Lambda. That's the osbot abstraction working as designed.

---

*Dev review complete. This document catalogues all osbot-* and cache service capabilities currently in use by SGraph Send as of v0.2.41.*
