# Dev Review: IFD Broken Independence — Root Cause Analysis

**Version:** v0.2.41
**Date:** 2026-02-14
**Role:** Dev
**Status:** Accepted — no code changes will be made

---

## Situation

The user UI frontend versions v0.1.1 through v0.1.4 violate IFD's core principle of surgical overrides. The decision is to **accept this as-is** and carry the lessons forward to v0.2.0 (the next major consolidation).

---

## What Went Wrong

### 1. Full Class Copies Instead of Surgical Overrides

The IFD Versioning Guide (v1.2.0) is explicit:

> The unit of change is **the change itself**, not the file.
> `❌ Bad: Copy 500-line file to change 1 method`
> `✅ Good: 15-line file that overrides just that method`

**What actually happened:**

| Version | `send-upload.js` | `send-download.js` | IFD Target |
|---------|------------------|---------------------|-----------|
| v0.1.0 | Base (full class) | Base (full class) | — |
| v0.1.1 | 409 lines (full copy) | full copy | ~15 lines |
| v0.1.2 | 501 lines (full copy) | full copy | ~20 lines |
| v0.1.3 | 484 lines (full copy) | full copy | ~15 lines |
| v0.1.4 | 483 lines (full copy) | full copy | ~15 lines |

Each version re-declares the entire `SendUpload` / `SendDownload` Web Component class with `customElements.define()`, rather than using `ClassName.prototype.methodName = function() { ... }` to override only the changed methods.

### 2. The `customElements.define()` Problem

Web Components have a constraint that the IFD guide didn't account for: **`customElements.define()` can only be called once per tag name.** This means the surgical pattern described in the guide:

```javascript
// v0.1.0 loads first:
class SendUpload extends HTMLElement { ... }
customElements.define('send-upload', SendUpload);

// v0.1.3 surgical override loads second:
SendUpload.prototype.buildDownloadUrl = function() { ... };
```

...would **work** for prototype overrides, but the current code **re-declares the class entirely** and calls `customElements.define()` again — which would throw in a browser if the base were loaded first. The versions therefore don't load the base; they replace it.

This means v0.1.1–v0.1.4 are not surgical overrides — they are **complete replacements** that happen to share base assets (CSS, crypto, API client) via relative paths to v0.1.0.

### 3. Cross-Version Asset Coupling

All versions v0.1.1–v0.1.4 reference v0.1.0 assets via relative paths:

```html
<link rel="stylesheet" href="../v0.1.0/css/common.css">
<script src="../v0.1.0/js/crypto.js"></script>
<script src="../v0.1.0/js/api-client.js"></script>
<script src="../v0.1.0/components/send-access-gate/send-access-gate.js"></script>
<script src="../v0.1.0/components/send-transparency/send-transparency.js"></script>
```

This creates a **hard runtime dependency** on v0.1.0. If v0.1.0 assets were modified, all downstream versions would silently change behaviour. If v0.1.0 were deleted, they'd all break.

The sharing pattern is correct per IFD ("link back to earlier versions for unchanged code"), but the combination of shared base assets + full class copies = neither truly surgical nor truly independent.

---

## Why It Happened

1. **Agent unfamiliarity with Web Components constraints** — `customElements.define()` is once-per-tag, so the surgical prototype override pattern requires careful handling (define in base, override prototype in patches — never re-define).

2. **No guard rails in code review** — the full-copy pattern was introduced in v0.1.1 and replicated in v0.1.2, v0.1.3, v0.1.4 without being flagged.

3. **Velocity pressure** — feature work (i18n, LaunchList removal, URL changes) was delivered quickly by copying the working class and modifying it, rather than factoring out the surgical override.

4. **The guide was written after v0.1.0** — the IFD Versioning Guide v1.2.0 was formalised after the initial frontend versions were already being created. The implementation preceded the rules.

---

## Impact Assessment

| Concern | Severity | Notes |
|---------|----------|-------|
| **Broken rollback** | Medium | Cannot independently revert v0.1.3 without also losing v0.1.4 changes, since both are full copies |
| **Silent coupling** | Medium | Editing v0.1.0 base assets cascades to all versions |
| **Disk/deploy bloat** | Low | ~2KB per duplicated component × 4 versions = ~8KB extra |
| **Functional correctness** | None | The app works correctly; this is a methodology violation, not a bug |
| **Security impact** | None | Encryption paths are correct in all versions |

---

## Decision

**Accept the current state.** The versions work, the app is going to production. We will not retrofit surgical overrides onto v0.1.1–v0.1.4.

When v0.2.0 is created (the next major consolidation), the full v0.1.x chain will be merged into a single self-contained baseline, and the surgical override pattern can be applied correctly from v0.2.1 onward.

---

## Recommendations for v0.2.0+

1. **Use prototype method overrides, not class re-declarations.** The base version defines the class with `customElements.define()`. Minor versions override only the changed methods via `ClassName.prototype.methodName = function() { ... }`.

2. **Never call `customElements.define()` in a minor version.** Only the base (v0.X.0) defines the custom element.

3. **Add an IFD pre-commit check** — a simple lint rule that flags any minor version file larger than 100 lines as a potential IFD violation.

4. **Document the Web Components constraint** — update the IFD Versioning Guide to note that `customElements.define()` is once-per-tag and show the correct pattern for Web Component surgical overrides.

---

*Dev review complete. No code changes made. Lessons captured for v0.2.0 consolidation.*
