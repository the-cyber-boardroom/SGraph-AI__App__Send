# Developer Implementation Plan: SSH Key Utility

**version** v0.5.19
**date** 22 Feb 2026
**role** Developer
**team** Explorer
**type** Implementation plan — SSH key generator utility
**input** [v0.5.10 brief](../../../../humans/dinis_cruz/briefs/02/21/part-3/v0.5.10__brief__ssh-key-utility-and-marketing-campaign.md), [Architect guidance](../../../architect/reviews/26-02-22/v0.5.19__guidance__ssh-key-utility-architecture.md)

---

## Scope

Build a single-page, zero-server-interaction SSH key generator as a Web Component. IFD methodology. No external dependencies. Web Crypto API for key generation. OpenSSH format output.

**Estimated effort:** 1-2 sessions (small). The crypto format conversion is the only non-trivial part.

---

## File Structure (v0.1.0)

```
sgraph_ai_app_send__ui__user/
  tools/
    ssh-keygen/
      v0/
        v0.1/
          v0.1.0/
            index.html                    ← page shell, loads component
            js/
              ssh-keygen-app.js           ← <ssh-keygen-app> Web Component (UI + orchestration)
              ssh-crypto.js               ← key generation + OpenSSH format conversion
            css/
              ssh-keygen.css              ← page-specific overrides (minimal — mostly design system)
```

### Why This Structure

- Follows existing IFD versioned path pattern (`v0/v0.1/v0.1.0/`)
- Sits under `tools/` namespace (per Architect guidance)
- Web Component pattern matches existing `<send-upload>`, `<send-download>` components
- Single `index.html` entry point with script tags for component + crypto lib

---

## Implementation Breakdown

### 1. `ssh-crypto.js` — Key Generation and Format Conversion

This is the core technical work. Pure functions, no DOM, no side effects.

#### API Surface

```javascript
const SSHCrypto = {

    // Feature detection
    async supportsEd25519()           → boolean
    async supportsRSA()               → boolean

    // Key generation (returns OpenSSH-formatted strings)
    async generateEd25519(comment)    → { publicKey: string, privateKey: string, fingerprint: string }
    async generateRSA4096(comment)    → { publicKey: string, privateKey: string, fingerprint: string }

    // Internal: format converters
    formatPublicKeyEd25519(rawPub, comment)   → string    // "ssh-ed25519 AAAA... comment"
    formatPrivateKeyEd25519(rawPriv, rawPub, comment) → string  // "-----BEGIN OPENSSH PRIVATE KEY-----\n..."
    formatPublicKeyRSA(n, e, comment)         → string    // "ssh-rsa AAAA... comment"
    formatPrivateKeyRSA(keyData, comment)      → string   // "-----BEGIN OPENSSH PRIVATE KEY-----\n..."

    // Internal: binary helpers
    encodeUint32(n)                   → Uint8Array(4)      // big-endian uint32
    encodeString(str)                 → Uint8Array          // uint32 length + UTF-8 bytes
    encodeMPInt(bytes)                → Uint8Array          // SSH mpint encoding
    wrapPEM(base64, label)            → string              // 70-char line wrapping
}
```

#### Ed25519 Key Generation Flow

```
1. crypto.subtle.generateKey('Ed25519', true, ['sign', 'verify'])
2. crypto.subtle.exportKey('raw', publicKey)    → 32 bytes
3. crypto.subtle.exportKey('pkcs8', privateKey) → DER-encoded PKCS8
4. Extract raw 32-byte seed from PKCS8 DER envelope
5. Build OpenSSH public key wire format:
     encodeString("ssh-ed25519") + encodeString(rawPublic)
6. Build OpenSSH private key format:
     magic + "none" cipher + "none" kdf + empty kdf opts + 1 key
     + public wire format
     + encrypted section (check bytes + type + pub + priv + comment + padding)
7. Base64 encode, wrap in PEM markers, line-wrap at 70 chars
```

#### RSA 4096 Key Generation Flow

```
1. crypto.subtle.generateKey(
     { name: 'RSASSA-PKCS1-v1_5', modulusLength: 4096, publicExponent: new Uint8Array([1,0,1]), hash: 'SHA-256' },
     true, ['sign', 'verify']
   )
2. crypto.subtle.exportKey('jwk', privateKey) → JWK with n, e, d, p, q, dp, dq, qi
3. Build OpenSSH public key: encodeString("ssh-rsa") + encodeMPInt(e) + encodeMPInt(n)
4. Build OpenSSH private key: same envelope as Ed25519 but with RSA-specific fields
     (n, e, d, iqmp, p, q, comment)
5. Base64 encode, PEM wrap
```

#### PKCS8 DER Parsing (Ed25519)

The Web Crypto API exports Ed25519 private keys in PKCS8 format. We need to extract the raw 32-byte seed:

```
PKCS8 DER for Ed25519:
  30 2e                         SEQUENCE (46 bytes)
    02 01 00                    INTEGER version=0
    30 05                       SEQUENCE (5 bytes)
      06 03 2b 65 70            OID 1.3.101.112 (Ed25519)
    04 22                       OCTET STRING (34 bytes)
      04 20                     OCTET STRING (32 bytes)
        {32 bytes of seed}      ← this is what we need
```

The seed is at a fixed offset (bytes 16-47) in the PKCS8 DER output. However, relying on fixed offsets is fragile. Better to walk the ASN.1 structure:

```javascript
function extractEd25519Seed(pkcs8Der) {
    const data = new Uint8Array(pkcs8Der)
    // Find the inner OCTET STRING containing the 32-byte seed
    // PKCS8 → SEQUENCE → version, algorithm, OCTET STRING(OCTET STRING(seed))
    // The seed OCTET STRING starts with 04 20 followed by 32 bytes
    let offset = 0
    // Skip outer SEQUENCE tag + length
    offset = skipTLV(data, offset)  // skip to content
    // Skip version INTEGER
    offset = skipTLV(data, offset)
    // Skip algorithm SEQUENCE
    offset = skipTLV(data, offset)
    // Now at the outer OCTET STRING
    // Read its tag (04) and length, then inside is another 04 20 + 32 bytes
    const outerLen = readLength(data, offset + 1)
    offset += 1 + outerLen.bytesRead
    // Inner: tag=04, length=20 (32 decimal), then 32 bytes
    return data.slice(offset + 2, offset + 2 + 32)
}
```

Alternatively, since the PKCS8 DER structure for Ed25519 is always the same fixed length (48 bytes total), a simpler approach that checks the expected structure:

```javascript
function extractEd25519Seed(pkcs8) {
    const der = new Uint8Array(pkcs8)
    // Validate structure
    if (der.length !== 48 || der[0] !== 0x30 || der[14] !== 0x04 || der[16] !== 0x04) {
        throw new Error('Unexpected PKCS8 format for Ed25519')
    }
    return der.slice(16, 48)  // 32-byte seed
}
```

**Recommendation:** Use the simple fixed-offset approach with structural validation. The Web Crypto API's Ed25519 PKCS8 output is standardised — there's no variability.

#### Fingerprint

```javascript
async function fingerprint(publicKeyWireFormat) {
    const hash = await crypto.subtle.digest('SHA-256', publicKeyWireFormat)
    return 'SHA256:' + btoa(String.fromCharCode(...new Uint8Array(hash)))
                        .replace(/=+$/, '')
}
```

Display format: `SHA256:aBcDeFgH...` — matches `ssh-keygen -l` output.

---

### 2. `ssh-keygen-app.js` — Web Component

A single custom element `<ssh-keygen-app>` that handles the entire UI.

#### State Machine

```
idle → generating → complete
                  ↗
       (error) ──┘

User clicks "Generate" → state = generating
  → SSHCrypto.generateEd25519(comment) or generateRSA4096(comment)
  → state = complete (show keys)
  → User clicks "Generate New" → state = idle (clear keys from memory)
```

#### Component Structure

```javascript
class SSHKeygenApp extends HTMLElement {
    constructor() {
        super()
        this.state = 'idle'           // idle | generating | complete
        this.algorithm = 'ed25519'    // ed25519 | rsa4096
        this.comment = ''
        this.keys = null              // { publicKey, privateKey, fingerprint }
        this.ed25519Supported = null  // null = unknown, true/false after detection
    }

    connectedCallback() {
        this.render()
        this.detectFeatures()
    }

    async detectFeatures() {
        this.ed25519Supported = await SSHCrypto.supportsEd25519()
        this.render()  // re-render to enable/disable Ed25519 option
    }

    async generate() {
        this.state = 'generating'
        this.render()
        try {
            if (this.algorithm === 'ed25519') {
                this.keys = await SSHCrypto.generateEd25519(this.comment)
            } else {
                this.keys = await SSHCrypto.generateRSA4096(this.comment)
            }
            this.state = 'complete'
        } catch (e) {
            this.state = 'idle'
            this.showError(e.message)
        }
        this.render()
    }

    reset() {
        this.keys = null              // clear keys from memory
        this.state = 'idle'
        this.render()
    }

    // Copy to clipboard
    async copyToClipboard(text, buttonEl) { ... }

    // Download as file
    downloadAsFile(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = filename
        a.click()
        URL.revokeObjectURL(url)
    }

    render() { ... }  // builds innerHTML based on state
}
customElements.define('ssh-keygen-app', SSHKeygenApp)
```

#### Event Delegation

Use event delegation on the component root (same pattern as `send-upload.js`):

```javascript
this.addEventListener('click', (e) => {
    if (e.target.matches('[data-action="generate"]'))   this.generate()
    if (e.target.matches('[data-action="reset"]'))      this.reset()
    if (e.target.matches('[data-copy]'))                this.copyToClipboard(...)
    if (e.target.matches('[data-download]'))            this.downloadAsFile(...)
})
```

---

### 3. `index.html` — Page Shell

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSH Key Generator — SG/Send</title>
    <meta name="description" content="Generate SSH key pairs securely in your browser. Ed25519 and RSA 4096. Nothing is sent to any server. Open source.">
    <link rel="canonical" href="https://send.sgraph.ai/tools/ssh-keygen">
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Design system -->
    <link rel="stylesheet" href="../../../../v0/v0.1/v0.1.0/css/common.css">
    <link rel="stylesheet" href="../../../../v0/v0.1/v0.1.6/css/sg-design-system.css">
    <link rel="stylesheet" href="css/ssh-keygen.css">
    <!-- JSON-LD structured data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "SoftwareApplication",
        "name": "SSH Key Generator",
        "description": "Generate SSH key pairs (Ed25519, RSA 4096) securely in your browser. Nothing is sent to any server.",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "Any (browser-based)",
        "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" },
        "author": {
            "@type": "Organization",
            "name": "SGraph",
            "url": "https://sgraph.ai"
        }
    }
    </script>
</head>
<body class="theme-aurora">
    <header>
        <h1><a href="/send/" style="text-decoration:none;color:inherit"><span class="brand-prefix">SG</span><span class="brand-slash">/</span><span class="brand-product">Send</span></a></h1>
        <p class="header-tagline">Developer Tools</p>
        <nav class="header-nav">
            <a href="https://github.com/the-cyber-boardroom/SGraph-AI__App__Send" target="_blank" rel="noopener" class="nav-link">GitHub</a>
        </nav>
    </header>
    <main>
        <ssh-keygen-app></ssh-keygen-app>
    </main>
    <script src="js/ssh-crypto.js"></script>
    <script src="js/ssh-keygen-app.js"></script>
</body>
</html>
```

---

### 4. Redirect Route

Add a redirect in `Fast_API__SGraph__App__Send__User.setup_static_routes()`:

```python
@route_path(path='/tools/ssh-keygen')
def redirect_to_ssh_keygen():
    return RedirectResponse(url='/send/tools/ssh-keygen/v0/v0.1/v0.1.0/index.html')
```

This gives the clean canonical URL for SEO while the actual files follow IFD versioning.

---

## Implementation Order

| Step | What | Effort | Depends On |
|------|------|--------|-----------|
| 1 | `ssh-crypto.js` — Ed25519 generation + OpenSSH format | Medium | None |
| 2 | `ssh-crypto.js` — RSA 4096 generation + OpenSSH format | Medium | Step 1 (shared helpers) |
| 3 | `ssh-keygen-app.js` — Web Component (idle + generating + complete states) | Small | Steps 1-2 |
| 4 | `index.html` + `ssh-keygen.css` — page shell + styling | Small | Step 3 |
| 5 | Redirect route in user Lambda | Trivial | Step 4 |
| 6 | Copy/symlink to admin Lambda | Trivial | Step 4 |
| 7 | Acceptance testing — generate keys, import with `ssh-keygen -y -f`, verify round-trip | Small | Steps 1-6 |

**Steps 1-2 are the critical path.** The OpenSSH format conversion is the only technically difficult part. Steps 3-6 are straightforward application of existing patterns.

---

## Testing Strategy

### Unit Tests (pytest, in-memory)

No Python unit tests needed — there's no Python code. The page is purely static.

### Browser Tests (Manual or Playwright)

| # | Test | Acceptance |
|---|------|-----------|
| 1 | Generate Ed25519 key | Public key starts with `ssh-ed25519 AAAA` |
| 2 | Generate RSA 4096 key | Public key starts with `ssh-rsa AAAA` |
| 3 | Private key format | Starts with `-----BEGIN OPENSSH PRIVATE KEY-----` |
| 4 | Copy to clipboard | Clipboard contains exact key text |
| 5 | Download public key | Downloaded file `id_ed25519.pub` matches displayed text |
| 6 | Download private key | Downloaded file `id_ed25519` matches displayed text |
| 7 | Round-trip: `ssh-keygen -y -f id_ed25519` | Output matches the public key exactly |
| 8 | Round-trip: `ssh-keygen -l -f id_ed25519.pub` | Shows fingerprint, no errors |
| 9 | No network requests | DevTools Network tab shows zero requests after page load |
| 10 | Ed25519 unsupported | Radio button disabled with tooltip (test in older browser) |
| 11 | Generate new after complete | Previous keys cleared, form reset |

### Validation Script

A simple shell script to validate generated keys:

```bash
#!/bin/bash
# Save generated private key as test_key, public as test_key.pub
ssh-keygen -y -f test_key > derived_pub.txt
diff <(cut -d' ' -f1-2 test_key.pub) <(cut -d' ' -f1-2 derived_pub.txt)
echo "Round-trip: $?"
ssh-keygen -l -f test_key.pub
echo "Fingerprint: $?"
```

---

## Risk Register

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|-----------|
| PKCS8 extraction breaks across browsers | Low | High | Structural validation before extraction. Test Chrome, Firefox, Safari. |
| RSA key generation slow (4096-bit) | Medium | Low | Show progress spinner. RSA 4096 takes 0.5-3 seconds. |
| OpenSSH format subtly wrong | Medium | High | Round-trip test with `ssh-keygen` is mandatory before release. |
| Ed25519 unsupported in target browsers | Low | Medium | Feature detection + RSA fallback. All modern browsers support it. |

---

## What I Need From Other Roles

| From | What |
|------|------|
| **Designer** | Wireframe/mockup for the page layout. Key display area sizing. Mobile layout. |
| **Architect** | Confirmed: `connect-src 'none'` CSP — how is this applied? Lambda response header? HTML meta tag? |
| **Ambassador** | Final copy for the "How to Use" section (GitHub, GitLab, server instructions). |
| **AppSec** | Review of the crypto implementation before release. Confirm RNG quality assessment. |
| **DevOps** | Static file deployment to both Lambda mount points. |

---

*Explorer Developer — SSH Key Utility Implementation Plan — 22 Feb 2026*
