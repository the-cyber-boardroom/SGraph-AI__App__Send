# Dev + Architect Review: PKI-Keyed Personal Data Vault — Revised to Use Cache Service Data API

**Version:** v0.5.19  
**Date:** 22 Feb 2026  
**Roles:** Dev (lead), Architect  
**Reviews:** `team/humans/dinis_cruz/briefs/02/22/v0.5.15__dev-brief__pki-keyed-personal-data-vault.md`  
**Context:** `library/sgraph-send/dev_packs/v0.5.0__pki-key-discovery/v0.5.13__debrief__pki-key-discovery-implementation.md`  

---

## Executive Summary

The original vault brief proposes creating **many independent cache entries** — one per folder, one per file, one for the index — treating the Cache Service as a flat key-value store. This review identifies that the Cache Service already provides a **hierarchical data API** designed for exactly this use case. The correct pattern is: **one cache entry per vault**, with all folders, files, and the index stored as **child data** inside that single cache entry.

This pattern already exists in the codebase — `token__use()` stores usage events as child data under a token's cache entry.

---

## The Correction

### Original Brief (incorrect usage)

```
S3 (what the server sees):
├── {vaultCacheId}           ← independent cache entry (vault root)
├── {indexCacheId}           ← independent cache entry (index)
├── {guid_1}                 ← independent cache entry (folder)
├── {guid_2}                 ← independent cache entry (folder)
├── {guid_3}                 ← independent cache entry (file)
├── {guid_4}                 ← independent cache entry (file)
└── {guid_5}                 ← independent cache entry (file)
```

Each folder and file is a separate top-level cache entry. The cache service doesn't know they're related. No built-in way to list vault contents, delete a vault, or scope queries.

### Revised (Cache Service native)

```
vault/data/key-based/{vault_cache_key}/
  {vault_cache_key}.json                    ← ONE cache entry: vault manifest
  data/
    folders/
      b4e2d903.json                         ← child data: folder (GUID children list)
      c5f3e014.json                         ← child data: subfolder
    files/
      d6g4f125.bin                          ← child data: encrypted file blob
      e7h5g236.bin                          ← child data: encrypted file blob
    index/
      vault-index.bin                       ← child data: encrypted vault index
```

One cache entry owns everything. Folders, files, and the index are child data stored under it. The Cache Service manages the relationship natively.

---

## Cache Service Data API — What Exists

The `Cache__Service__Client` provides a full hierarchical data API under every cache entry:

### Store child data: `data_store()`

```python
# Store JSON child data (folders)
cache_client.data_store().data__store_json__with__id_and_key(
    cache_id     = vault_cache_id,     # parent cache entry
    namespace    = NS_VAULT,           # 'vault'
    data_key     = 'folders',          # organising key
    data_file_id = folder_guid,        # unique file id
    body         = folder_json         # the data
)

# Store binary child data (encrypted files)
cache_client.data_store().data__store_binary__with__id_and_key(
    cache_id     = vault_cache_id,
    namespace    = NS_VAULT,
    data_key     = 'files',
    data_file_id = file_guid,
    body         = encrypted_bytes
)
```

### Retrieve child data: `data().retrieve()`

```python
# Retrieve folder JSON
cache_client.data().retrieve().data__json__with__id_and_key(
    cache_id, NS_VAULT, 'folders', folder_guid)

# Retrieve encrypted file blob
cache_client.data().retrieve().data__binary__with__id_and_key(
    cache_id, NS_VAULT, 'files', file_guid)
```

### Update child data: `data().update()`

```python
# Update folder children list
cache_client.data().update().data__update_json__with__id_and_key(
    cache_id, NS_VAULT, 'folders', folder_guid, updated_folder_json)

# Update encrypted index
cache_client.data().update().data__update_binary__with__id_and_key(
    cache_id, NS_VAULT, 'index', 'vault-index', encrypted_index_bytes)
```

### List child data: `data().list()`

```python
# List everything in the vault
cache_client.data().list().data__list(cache_id, NS_VAULT)

# List only folders
cache_client.data().list().data__list__with__key(cache_id, NS_VAULT, 'folders')

# List only files
cache_client.data().list().data__list__with__key(cache_id, NS_VAULT, 'files')
```

### Delete child data: `data().delete()`

```python
# Delete a single file
cache_client.data().delete().delete__data__file__with__id_and_key(
    cache_id, NS_VAULT, Enum__Cache__Data_Type.binary, 'files', file_guid)

# Delete all files under a data_key
cache_client.data().delete().delete__all__data__files__with__key(
    cache_id, NS_VAULT, 'files')

# Delete ALL vault contents
cache_client.data().delete().delete__all__data__files(cache_id, NS_VAULT)
```

### Check existence: `data().exists()`

```python
cache_client.data().exists().data__exists__with__id_and_key(
    cache_id, NS_VAULT, Enum__Cache__Data_Type.binary, 'files', file_guid)
```

---

## Existing Precedent: Token Usage Events

The token system already uses this pattern. Tokens are cache entries. Usage events are child data:

```python
# From Send__Cache__Client.py — token__use()
def token__use(self, token_name, usage_event_data):
    cache_id = self.token__lookup_cache_id(token_name)
    event_id = usage_event_data.get('event_id', '')
    return self.cache_client.data_store().data__store_json__with__id_and_key(
        cache_id     = cache_id,
        namespace    = NS_TOKENS,
        data_key     = 'usage_events',
        data_file_id = event_id,
        body         = usage_event_data)
```

On disk:
```
tokens/data/key-based/my-token/
  my-token.json                     ← parent cache entry
  data/
    usage_events/
      event-001.json                ← child data
      event-002.json                ← child data
```

The vault follows the identical pattern — just with `'folders'`, `'files'`, and `'index'` as data_keys instead of `'usage_events'`.

---

## Revised Vault Architecture

### Step 1: Create the vault (one cache entry)

```python
NS_VAULT = 'vault'

# cache_key derived from public key hash + namespace string
vault_cache_key = sha256(public_key_hash + "/filesystem")

result = cache_client.store().store__json__cache_key(
    namespace       = NS_VAULT,
    strategy        = 'key_based',
    cache_key       = vault_cache_key,
    file_id         = vault_cache_key,
    body            = {
        "type"           : "vault_root",
        "created"        : "2026-02-22T10:00:00Z",
        "key_fingerprint": "sha256:3a7f...c891",
        "root_folder"    : "b4e2d903"
    },
    json_field_path = 'type'
)
vault_cache_id = result.cache_id  # This is the ONLY cache_id the client needs
```

### Step 2: Check if vault exists (lookup by cache_key hash)

```python
cache_hash = hash_generator.from_string(vault_cache_key)
response   = cache_client.retrieve().retrieve__hash__cache_hash__cache_id(
    cache_hash = str(cache_hash),
    namespace  = NS_VAULT
)
# response.cache_id → the vault's cache_id (or None if vault doesn't exist)
```

### Step 3: All vault operations use child data API

| Vault Operation | data_key | data_file_id | Data Type | API Method |
|---|---|---|---|---|
| **Create folder** | `'folders'` | `{folder_guid}` | JSON | `data_store().data__store_json__with__id_and_key()` |
| **Upload file** | `'files'` | `{file_guid}` | Binary | `data_store().data__store_binary__with__id_and_key()` |
| **Save/update index** | `'index'` | `'vault-index'` | Binary | `data_store().data__store_binary__with__id_and_key()` |
| **Read folder** | `'folders'` | `{folder_guid}` | JSON | `data().retrieve().data__json__with__id_and_key()` |
| **Download file** | `'files'` | `{file_guid}` | Binary | `data().retrieve().data__binary__with__id_and_key()` |
| **Read index** | `'index'` | `'vault-index'` | Binary | `data().retrieve().data__binary__with__id_and_key()` |
| **Update folder** | `'folders'` | `{folder_guid}` | JSON | `data().update().data__update_json__with__id_and_key()` |
| **Update index** | `'index'` | `'vault-index'` | Binary | `data().update().data__update_binary__with__id_and_key()` |
| **Delete file** | `'files'` | `{file_guid}` | Binary | `data().delete().delete__data__file__with__id_and_key()` |
| **Delete folder** | `'folders'` | `{folder_guid}` | JSON | `data().delete().delete__data__file__with__id_and_key()` |
| **List all folders** | `'folders'` | — | — | `data().list().data__list__with__key()` |
| **List all files** | `'files'` | — | — | `data().list().data__list__with__key()` |
| **List all vault items** | — | — | — | `data().list().data__list()` |
| **Check file exists** | `'files'` | `{file_guid}` | Binary | `data().exists().data__exists__with__id_and_key()` |
| **Delete entire vault** | — | — | — | `data().delete().delete__all__data__files()` |

---

## Revised Client-Side Flows

### First Visit (Creating the Vault)

```
1. User has PKI key pair in browser
2. Client derives vault_cache_key = sha256(public_key_hash + "/filesystem")
3. Backend: look up cache_id for vault_cache_key
   ├── Not found: vault doesn't exist
   │   ├── Create vault cache entry (store__json__cache_key)
   │   │   Returns: vault_cache_id
   │   ├── Store root folder as child data:
   │   │   data_store().data__store_json__with__id_and_key(
   │   │       vault_cache_id, NS_VAULT, 'folders', root_folder_guid,
   │   │       { "type": "folder", "id": root_folder_guid, "children": [] })
   │   ├── Store empty index as child data:
   │   │   data_store().data__store_binary__with__id_and_key(
   │   │       vault_cache_id, NS_VAULT, 'index', 'vault-index',
   │   │       encrypt({ "type": "vault_index", "entries": {} }))
   │   └── Vault created. Show empty file manager.
   │
   └── Found: vault exists → vault_cache_id
       ├── Fetch and decrypt index:
       │   data().retrieve().data__binary__with__id_and_key(
       │       vault_cache_id, NS_VAULT, 'index', 'vault-index')
       ├── Cache index in IndexedDB
       └── Show file manager
```

### Uploading a File

```
1. User selects file
2. Client generates file_guid
3. Client encrypts file with vault key
4. Store encrypted blob:
   data_store().data__store_binary__with__id_and_key(
       vault_cache_id, NS_VAULT, 'files', file_guid, encrypted_bytes)
5. Update parent folder (add child):
   data().update().data__update_json__with__id_and_key(
       vault_cache_id, NS_VAULT, 'folders', parent_guid, updated_folder_json)
6. Update index (add name/metadata):
   data().update().data__update_binary__with__id_and_key(
       vault_cache_id, NS_VAULT, 'index', 'vault-index', re_encrypted_index)
7. File appears in UI
```

### Creating a Folder

```
1. User creates folder "Investor Materials"
2. Client generates folder_guid
3. Store empty folder:
   data_store().data__store_json__with__id_and_key(
       vault_cache_id, NS_VAULT, 'folders', folder_guid,
       { "type": "folder", "id": folder_guid, "children": [] })
4. Update parent folder (add child):
   data().update().data__update_json__with__id_and_key(
       vault_cache_id, NS_VAULT, 'folders', parent_guid, updated_folder_json)
5. Update index (add name):
   data().update().data__update_binary__with__id_and_key(
       vault_cache_id, NS_VAULT, 'index', 'vault-index', re_encrypted_index)
6. Folder appears in UI
```

---

## Backend Implementation: Send__Cache__Client Extension

Add vault methods to `Send__Cache__Client` following the `token__use()` pattern:

```python
NS_VAULT = 'vault'

class Send__Cache__Client(Type_Safe):
    # ... existing code ...

    # ═══════════════════════════════════════════════════════════════════
    # Vault Operations
    # ═══════════════════════════════════════════════════════════════════

    def vault__create(self, vault_cache_key, manifest_data):
        return self.cache_client.store().store__json__cache_key(
            namespace       = NS_VAULT,
            strategy        = 'key_based',
            cache_key       = vault_cache_key,
            file_id         = vault_cache_key,
            body            = manifest_data,
            json_field_path = 'type')

    def vault__lookup(self, vault_cache_key):
        cache_hash = self.hash_generator.from_string(vault_cache_key)
        response   = self.cache_client.retrieve().retrieve__hash__cache_hash__cache_id(
            cache_hash = str(cache_hash),
            namespace  = NS_VAULT)
        if response and response.get('cache_id'):
            cache_id = response.get('cache_id')
            return self.cache_client.retrieve().retrieve__cache_id__json(
                cache_id = cache_id, namespace = NS_VAULT)
        return None

    def vault__lookup_cache_id(self, vault_cache_key):
        cache_hash = self.hash_generator.from_string(vault_cache_key)
        response   = self.cache_client.retrieve().retrieve__hash__cache_hash__cache_id(
            cache_hash = str(cache_hash),
            namespace  = NS_VAULT)
        if response:
            return response.get('cache_id')
        return None

    def vault__store_folder(self, cache_id, folder_guid, folder_data):
        return self.cache_client.data_store().data__store_json__with__id_and_key(
            cache_id     = cache_id,
            namespace    = NS_VAULT,
            data_key     = 'folders',
            data_file_id = folder_guid,
            body         = folder_data)

    def vault__store_file(self, cache_id, file_guid, encrypted_bytes):
        return self.cache_client.data_store().data__store_binary__with__id_and_key(
            cache_id     = cache_id,
            namespace    = NS_VAULT,
            data_key     = 'files',
            data_file_id = file_guid,
            body         = encrypted_bytes)

    def vault__store_index(self, cache_id, encrypted_index_bytes):
        return self.cache_client.data_store().data__store_binary__with__id_and_key(
            cache_id     = cache_id,
            namespace    = NS_VAULT,
            data_key     = 'index',
            data_file_id = 'vault-index',
            body         = encrypted_index_bytes)

    def vault__get_folder(self, cache_id, folder_guid):
        return self.cache_client.data().retrieve().data__json__with__id_and_key(
            cache_id, NS_VAULT, 'folders', folder_guid)

    def vault__get_file(self, cache_id, file_guid):
        return self.cache_client.data().retrieve().data__binary__with__id_and_key(
            cache_id, NS_VAULT, 'files', file_guid)

    def vault__get_index(self, cache_id):
        return self.cache_client.data().retrieve().data__binary__with__id_and_key(
            cache_id, NS_VAULT, 'index', 'vault-index')

    def vault__update_folder(self, cache_id, folder_guid, folder_data):
        return self.cache_client.data().update().data__update_json__with__id_and_key(
            cache_id, NS_VAULT, 'folders', folder_guid, folder_data)

    def vault__update_index(self, cache_id, encrypted_index_bytes):
        return self.cache_client.data().update().data__update_binary__with__id_and_key(
            cache_id, NS_VAULT, 'index', 'vault-index', encrypted_index_bytes)

    def vault__list_folders(self, cache_id):
        return self.cache_client.data().list().data__list__with__key(
            cache_id, NS_VAULT, 'folders')

    def vault__list_files(self, cache_id):
        return self.cache_client.data().list().data__list__with__key(
            cache_id, NS_VAULT, 'files')

    def vault__list_all(self, cache_id):
        return self.cache_client.data().list().data__list(
            cache_id, NS_VAULT)

    def vault__delete_file(self, cache_id, file_guid):
        return self.cache_client.data().delete().delete__data__file__with__id_and_key(
            cache_id, NS_VAULT,
            Enum__Cache__Data_Type.binary, 'files', file_guid)

    def vault__delete_all(self, cache_id):
        return self.cache_client.data().delete().delete__all__data__files(
            cache_id, NS_VAULT)
```

---

## Admin Lambda Routes: Service__Vault

A thin service layer between the routes and `Send__Cache__Client`:

```python
class Service__Vault(Type_Safe):
    send_cache_client : Send__Cache__Client

    def create(self, vault_cache_key, manifest_data):
        existing = self.send_cache_client.vault__lookup_cache_id(vault_cache_key)
        if existing:
            return None  # vault already exists (409 Conflict)
        return self.send_cache_client.vault__create(vault_cache_key, manifest_data)

    def lookup(self, vault_cache_key):
        return self.send_cache_client.vault__lookup(vault_cache_key)

    def store_folder(self, vault_cache_key, folder_guid, folder_data):
        cache_id = self.send_cache_client.vault__lookup_cache_id(vault_cache_key)
        if cache_id is None:
            return None
        return self.send_cache_client.vault__store_folder(cache_id, folder_guid, folder_data)

    def store_file(self, vault_cache_key, file_guid, encrypted_bytes):
        cache_id = self.send_cache_client.vault__lookup_cache_id(vault_cache_key)
        if cache_id is None:
            return None
        return self.send_cache_client.vault__store_file(cache_id, file_guid, encrypted_bytes)

    # ... similar wrappers for get, update, delete, list
```

### Routes__Vault (Admin Lambda)

```python
TAG__ROUTES_VAULT = 'vault'

class Routes__Vault(Fast_API__Routes):
    tag            : str = TAG__ROUTES_VAULT
    service_vault  : Service__Vault

    def create(self, body: Schema__Vault__Create__Request) -> dict:
        result = self.service_vault.create(body.vault_cache_key, body.manifest)
        if result is None:
            raise HTTPException(status_code=409, detail='Vault already exists')
        return result

    def lookup__vault_cache_key(self, vault_cache_key: Safe_Str__Id) -> dict:
        result = self.service_vault.lookup(vault_cache_key)
        if result is None:
            raise HTTPException(status_code=404, detail='Vault not found')
        return result

    def store_folder(self, body: Schema__Vault__Folder__Request) -> dict:
        # ...

    def store_file(self, body: Schema__Vault__File__Request) -> dict:
        # ...

    # etc.

    def setup_routes(self):
        self.add_route_post(self.create)
        self.add_route_get (self.lookup__vault_cache_key)
        self.add_route_post(self.store_folder)
        self.add_route_post(self.store_file)
        # ...
        return self
```

---

## What's Preserved from the Original Brief

Everything that isn't about storage mechanics is preserved unchanged:

| Original Brief Element | Status |
|---|---|
| PKI key hash derives storage root | **Preserved** — becomes the cache_key |
| No registration, key IS identity | **Preserved** |
| Folders as GUID-addressed JSON (no names) | **Preserved** — stored as child data under `'folders'` |
| Files as encrypted blobs | **Preserved** — stored as child data under `'files'` |
| Encrypted index with names | **Preserved** — stored as child data under `'index'` |
| Server never sees plaintext | **Preserved** |
| No new API routes needed | **Revised** — vault-specific routes on admin lambda (proxy to cache service) |
| Data room compatibility | **Preserved** — a data room is the same pattern with a different cache_key derivation |
| Future namespaces (inbox, contacts, settings) | **Preserved** — each becomes a different cache entry with child data |
| Encryption key model | **Preserved** — wrapped symmetric key recommendation unchanged |
| UI file manager | **Preserved** |
| All 10 acceptance criteria | **Preserved** (criterion 9 revised to "uses Cache Service data API") |

---

## What Changed

| Original | Revised | Why |
|---|---|---|
| Many independent cache entries | **One cache entry per vault** | Correct use of Cache Service hierarchy |
| `POST /api/cache/{guid}` per item | **`data_store()` child data API** | Native cache service pattern |
| Client tracks many cache_ids | **Client tracks one vault_cache_id** | Simpler client, cleaner model |
| No relationship between items | **All items physically grouped** under one parent | Built-in list, delete, scope |
| Delete vault = find N entries | **`delete__all__data__files()`** — one call | Cache service provides this |
| Index stored at separate cache_id | **Index stored as child data** under `'index'` key | Part of the vault hierarchy |
| Flat storage, no data_keys | **Three data_keys**: `'folders'`, `'files'`, `'index'` | Natural organiser for vault contents |
| Only JSON storage mentioned | **JSON for folders, binary for files/index** | Encrypted data is binary, not JSON |

---

## Key Architectural Decisions

### AD-30: Vault uses Cache Service child data API

The vault stores all content (folders, files, index) as **child data** under a single cache entry, using the `data_store()` / `data()` API. This follows the existing `token__use()` precedent.

**Rationale:** The Cache Service already provides hierarchical storage. Creating independent cache entries bypasses this capability and loses built-in list, delete, and scoping features.

### AD-31: Three data_keys organise vault contents

| data_key | Content | Data Type |
|---|---|---|
| `'folders'` | Folder manifests (GUID children lists) | JSON |
| `'files'` | Encrypted file blobs | Binary |
| `'index'` | Encrypted vault index (names, metadata) | Binary |

**Rationale:** The `data_key` parameter naturally partitions vault contents. `data().list().data__list__with__key()` gives us filtered listing for free.

### AD-32: Vault routes on admin lambda

The vault UI communicates through admin lambda routes (`/vault/*`), not direct cache service calls. The admin lambda proxies to `Send__Cache__Client` which calls the cache service.

**Rationale:** Keeps auth consistent (cookie auth on admin lambda). No need to expose cache service URL to the browser.

### AD-33: Encrypted data stored as binary, not JSON

Encrypted file blobs and the encrypted index are stored using `data__store_binary__with__id_and_key()`, not JSON methods. Ciphertext is binary data.

**Rationale:** Attempting to store binary ciphertext as JSON would require base64 encoding, adding ~33% overhead and an unnecessary encode/decode step.

---

## Implementation Phases

| Phase | What | Backend | Frontend |
|---|---|---|---|
| **1** | Vault service + cache client extension | `Send__Cache__Client` vault methods, `Service__Vault`, `Routes__Vault` | — |
| **2** | Vault creation + lookup | Tests for create, lookup, exists | `vault-service.js` — derivation, init |
| **3** | Folder + file CRUD | Tests for store/get/update/delete folders and files | Folder + file operations in vault-service |
| **4** | Index management | Tests for encrypted index store/retrieve/update | Index CRUD in vault-service |
| **5** | File manager UI | — | `<vault-manager>` Web Component in admin shell |

---

*Review complete. The vault brief's intent is sound. The implementation needs to use the Cache Service's hierarchical data API (one cache entry + child data) instead of many independent cache entries. All other aspects of the brief are preserved.*
