# v0.5.0 -- Implementation Plan: Key Discovery UI and Public Registry

**version** v0.5.0
**date** 21 Feb 2026
**role** Developer
**team** Explorer
**status** Implementation plan -- ready for review
**brief** `team/humans/dinis_cruz/briefs/02/21/v0.4.27__dev-brief__key-discovery-and-public-registry.md`
**architecture ref** `team/humans/dinis_cruz/briefs/02/21/v0.4.27__architecture__chain-of-trust-and-key-graphs.md`

---

## 1. Summary

This plan covers the implementation of key discovery and a public key registry for the SG/Send admin panel. The dev brief specifies two new pages (`key-lookup.html`, `key-registry.html`), a publish button on the existing `pki.html`, four API endpoints, shared utility extraction (`pki-common.js`), and a certificate transparency log. The work is broken into five phases, each independently testable and deployable.

### Scope at a glance

| Deliverable | Type | Phase |
|---|---|---|
| `pki-common.js` -- shared utilities extracted from `pki-manager.js` | Frontend refactor | 1 |
| `POST /api/keys`, `GET /api/keys/{code}`, `DELETE /api/keys/{code}`, `GET /api/keys` | Backend API | 2 |
| Publish button on `pki.html` | Frontend feature | 3 |
| `key-lookup.html` + `key-lookup.js` | New page | 3 |
| `key-registry.html` + `key-registry.js` | New page | 4 |
| Certificate transparency log (data model + UI) | Backend + Frontend | 5 |

---

## 2. Non-negotiable constraints

1. **No plaintext on server** -- only Obj_Ids, public key PEM strings, timestamps, and lookup codes. No labels, no friendly names, no metadata strings.
2. **All schemas use Type_Safe** -- never Pydantic.
3. **All storage goes through Memory-FS** (`Send__Cache__Client`) -- never direct filesystem or S3.
4. **All FastAPI routes use `Fast_API__Routes`** conventions from `osbot-fast-api`.
5. **All tests use real implementations** -- no mocks, no patches, in-memory Memory-FS.
6. **Frontend uses IFD methodology** -- Web Components with Shadow DOM, zero framework dependencies, vanilla JS.
7. **Lookup codes are opaque short tokens** (6-8 alphanumeric chars, hybrid approach like `DC-7X4F`) -- not human-readable names.
8. **Friendly names exist only client-side** in IndexedDB.

---

## 3. Extraction plan: pki-common.js

The existing `pki-manager.js` (1831 lines) contains reusable utilities that the two new pages need. Before building anything new, extract these into a shared module.

### 3.1 Functions to extract

| Function | Current location (line) | Reason for extraction |
|---|---|---|
| `_exportPublicKeyPEM(publicKey)` | L229-233 | Key lookup page needs to display PEM |
| `_importPublicKeyPEM(pem)` | L235-245 | Key lookup page needs to import retrieved keys |
| `_importSigningKeyPEM(pem)` | L247-251 | Key lookup page needs to import signing keys from bundles |
| `_computeFingerprint(publicKey)` | L257-262 | Both new pages display fingerprints |
| `_escapeHtml(str)` | L715-719 | All pages need HTML escaping |
| `_escapeAttr(str)` | L721-723 | All pages need attribute escaping |
| `_formatDate(isoStr)` | L725-733 | Both new pages display dates |
| `_arrayBufToB64(buf)` | L532-534 | Bundle serialisation |
| `_b64ToArrayBuf(b64)` | L536-541 | Bundle deserialisation |
| IndexedDB helpers: `_initDB`, `_dbGetAll`, `_dbAdd`, `_dbDelete` | L96-163 | Key lookup page writes to contacts store |

### 3.2 Module design

```javascript
// pki-common.js -- shared PKI utilities for SG/Send admin pages
// Exports an object: window.PKICommon (or ES module if we move to import maps)

const PKICommon = {
    // Web Crypto
    async exportPublicKeyPEM(publicKey) { ... },
    async importPublicKeyPEM(pem) { ... },
    async importSigningKeyPEM(pem) { ... },
    async computeFingerprint(publicKey) { ... },

    // Encoding
    arrayBufToB64(buf) { ... },
    b64ToArrayBuf(b64) { ... },

    // UI helpers
    escapeHtml(str) { ... },
    escapeAttr(str) { ... },
    formatDate(isoStr) { ... },

    // IndexedDB
    async openDB() { ... },          // returns IDBDatabase
    async dbGetAll(db, storeName) { ... },
    async dbAdd(db, storeName, data) { ... },
    async dbDelete(db, storeName, id) { ... },

    // Public key bundle
    buildPublicKeyBundle(record) { ... },
    parsePublicKeyBundle(rawText) { ... },
};

window.PKICommon = PKICommon;
```

### 3.3 Backward compatibility

`pki-manager.js` continues to work as before. The extracted functions in `pki-manager.js` delegate to `PKICommon` internally:

```javascript
// In pki-manager.js, after extraction:
async _exportPublicKeyPEM(publicKey) {
    return PKICommon.exportPublicKeyPEM(publicKey);
}
```

This means `pki.html` loads `pki-common.js` before `pki-manager.js`. The component works identically. No regression risk.

### 3.4 Files modified

| File | Action |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/shared/pki-common.js` | **CREATE** -- shared utilities |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/pki-manager/pki-manager.js` | **MODIFY** -- delegate to `PKICommon` |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/pki.html` | **MODIFY** -- add `<script src="shared/pki-common.js">` before pki-manager.js |

---

## 4. API contract design

### 4.1 Endpoint: POST /api/keys

Publish a public key to the registry. Returns a lookup code.

**Request:**
```json
{
    "public_key_pem": "-----BEGIN PUBLIC KEY-----\nMIIB...\n-----END PUBLIC KEY-----",
    "signing_key_pem": "-----BEGIN PUBLIC KEY-----\nMFkw...\n-----END PUBLIC KEY-----"
}
```

- `public_key_pem` (required) -- the RSA-OAEP or ECDH public key in PEM format
- `signing_key_pem` (optional) -- the ECDSA P-256 signing public key in PEM format

**Response (201):**
```json
{
    "code": "DC-7X4F",
    "obj_id": "a3f7c891",
    "fingerprint": "sha256:3a7f1b2c9d4e5f60",
    "created": "2026-02-21T10:00:00Z"
}
```

**Error responses:**

| Status | Condition |
|---|---|
| 400 | Missing or invalid `public_key_pem` |
| 409 | This exact public key (by fingerprint) is already published |

**Key decision -- code generation algorithm:**

```
1. Generate 4 random bytes (32 bits of entropy)
2. Encode as uppercase base-36 (0-9, A-Z), yielding 6-7 characters
3. Insert a dash after the first 2 characters: "DC-7X4F"
4. Check for collisions in storage; regenerate if collision found
5. Total format: 2 chars + dash + 4 chars = 7 characters
```

This gives ~1.6 billion possible codes. Sufficient for any single deployment. The dash makes it easy to read aloud.

### 4.2 Endpoint: GET /api/keys/{code}

Look up a public key by its short code.

**Response (200):**
```json
{
    "code": "DC-7X4F",
    "obj_id": "a3f7c891",
    "public_key_pem": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
    "signing_key_pem": "-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----",
    "fingerprint": "sha256:3a7f1b2c9d4e5f60",
    "algorithm": "RSA-OAEP",
    "key_size": 4096,
    "created": "2026-02-21T10:00:00Z"
}
```

**Error responses:**

| Status | Condition |
|---|---|
| 404 | No active key found for this code |

### 4.3 Endpoint: DELETE /api/keys/{code}

Unpublish a key. The key entry transitions to `active: false`. The transparency log records the deletion.

**Response (200):**
```json
{
    "code": "DC-7X4F",
    "status": "unpublished",
    "log_entry_hash": "sha256:9f3a...2d71"
}
```

**Error responses:**

| Status | Condition |
|---|---|
| 404 | No active key found for this code |

**Key decision -- authentication for DELETE:** In the current architecture, the admin Lambda already gates access via API key (header/cookie auth from `osbot-fast-api`). Any authenticated admin can unpublish any key. This is appropriate for the current single-tenant deployment model. For future multi-tenant, the delete will need to verify the requester owns the key (via challenge-response, as described in the architecture brief). Noted as a future enhancement, not blocking.

### 4.4 Endpoint: GET /api/keys

List all published (active) keys. Returns the registry.

**Response (200):**
```json
{
    "keys": [
        {
            "code": "DC-7X4F",
            "obj_id": "a3f7c891",
            "fingerprint": "sha256:3a7f1b2c9d4e5f60",
            "algorithm": "RSA-OAEP",
            "key_size": 4096,
            "created": "2026-02-21T10:00:00Z"
        },
        {
            "code": "AB-3M9K",
            "obj_id": "b4e2d903",
            "fingerprint": "sha256:8b2ef443a1c97d3e",
            "algorithm": "RSA-OAEP",
            "key_size": 4096,
            "created": "2026-02-21T11:30:00Z"
        }
    ],
    "count": 2,
    "log_head_hash": "sha256:9f3a...2d71"
}
```

Note: the full `public_key_pem` is omitted from the listing for payload size. Clients use `GET /api/keys/{code}` to retrieve the full key.

---

## 5. Server-side data model

### 5.1 Storage namespace

Add a new namespace `NS_KEYS = 'keys'` to `Send__Cache__Client`, following the same pattern as `NS_TOKENS`.

### 5.2 Key registry entry (stored per key)

```python
# Stored at: keys/data/key-based/{code}/data.json
{
    "code"             : "DC-7X4F",           # lookup code (7 chars)
    "obj_id"           : "a3f7c891",          # 8-hex Obj_Id
    "public_key_pem"   : "-----BEGIN...",     # full PEM (public data)
    "signing_key_pem"  : "-----BEGIN...",     # optional signing PEM
    "fingerprint"      : "sha256:3a7f...",    # SHA-256 of SPKI bytes (first 16 hex chars)
    "algorithm"        : "RSA-OAEP",          # or "ECDH"
    "key_size"         : 4096,                # or 256 for ECDH
    "created"          : "2026-02-21T10:00:00Z",
    "active"           : true                 # false after DELETE
}
```

**What is NOT stored:** No labels. No user names. No friendly names. No metadata strings. The `code` itself is an opaque token, not a meaningful name. This satisfies the "no plaintext names on server" constraint.

### 5.3 Fingerprint-to-code index

To detect duplicate key publication (same key published twice), maintain a secondary index:

```
keys/index/fingerprint/{fingerprint_hex} -> { "code": "DC-7X4F" }
```

This allows the `POST /api/keys` endpoint to check if a key is already published in O(1) without scanning all entries.

### 5.4 Schema classes

```python
# sgraph_ai_app_send/lambda__admin/schemas/Schema__Key__Publish__Request.py
class Schema__Key__Publish__Request(Type_Safe):
    public_key_pem  : str            # PEM-encoded public key
    signing_key_pem : str = ''       # Optional PEM-encoded signing key

# sgraph_ai_app_send/lambda__admin/schemas/Schema__Key__Registry__Entry.py
class Schema__Key__Registry__Entry(Type_Safe):
    code            : str            # Lookup code (e.g., "DC-7X4F")
    obj_id          : str            # 8-hex Obj_Id
    public_key_pem  : str            # PEM-encoded public key
    signing_key_pem : str = ''       # Optional signing key
    fingerprint     : str            # "sha256:xxxx..."
    algorithm       : str            # "RSA-OAEP" or "ECDH"
    key_size        : int = 0        # 4096, 256, etc.
    created         : str            # ISO 8601 timestamp
    active          : bool = True    # False after unpublish
```

---

## 6. Transparency log data model

### 6.1 Design

An append-only, hash-chained log of all key operations. Each entry contains:

```python
{
    "seq"             : 0,                           # Monotonic sequence number
    "action"          : "KEY_PUBLISHED",             # or "KEY_UNPUBLISHED"
    "code"            : "DC-7X4F",                   # The lookup code affected
    "fingerprint"     : "sha256:3a7f1b2c9d4e5f60",  # Key fingerprint
    "timestamp"       : "2026-02-21T10:00:00Z",     # ISO 8601
    "previous_hash"   : "sha256:0000000000000000",   # Hash of previous entry (genesis: all zeros)
    "entry_hash"      : "sha256:a1b2c3d4e5f67890"   # SHA-256(action + code + fingerprint + timestamp + previous_hash)
}
```

### 6.2 Hash computation

```python
import hashlib

def compute_entry_hash(action, code, fingerprint, timestamp, previous_hash):
    payload = f"{action}|{code}|{fingerprint}|{timestamp}|{previous_hash}"
    return "sha256:" + hashlib.sha256(payload.encode()).hexdigest()[:16]
```

Using a truncated hash (16 hex chars = 64 bits) for display and storage. The full hash can be computed for verification, but 64 bits is sufficient for tamper detection in a per-deployment context. The chain guarantees that modifying any historical entry invalidates all subsequent hashes.

### 6.3 Storage layout

```
keys/log/entries/{seq:08d}.json     # Individual log entries (padded sequence number)
keys/log/head.json                   # Current head: { "seq": N, "entry_hash": "sha256:..." }
```

The `head.json` file is updated atomically after each log entry is written. Clients fetch `head.json` to get the current log integrity hash. The full log is fetched by listing `keys/log/entries/`.

### 6.4 Log operations (added to Send__Cache__Client)

```python
def keys__log__append(self, log_entry):     # Write a new log entry
def keys__log__head(self):                  # Read the current head
def keys__log__list(self):                  # List all log entries
def keys__log__entry(self, seq):            # Read a specific entry by seq
```

### 6.5 Log actions

| Action | When | Data captured |
|---|---|---|
| `KEY_PUBLISHED` | `POST /api/keys` succeeds | code, fingerprint |
| `KEY_UNPUBLISHED` | `DELETE /api/keys/{code}` succeeds | code, fingerprint |

Future actions (from architecture brief, not in this build): `KEY_ROTATED`, `TRUST_GROUP_CREATED`, `MEMBER_ADDED`, `MEMBER_REVOKED`.

---

## 7. Service layer

### 7.1 Service__Keys

New service class following the `Service__Tokens` pattern:

```python
# sgraph_ai_app_send/lambda__admin/service/Service__Keys.py
class Service__Keys(Type_Safe):
    send_cache_client : Send__Cache__Client

    def publish(self, public_key_pem, signing_key_pem=''):
        # 1. Validate PEM format (basic check: starts with -----BEGIN PUBLIC KEY-----)
        # 2. Compute fingerprint server-side (parse PEM, hash the DER bytes)
        # 3. Check fingerprint index for duplicates -> 409 if exists
        # 4. Generate lookup code (2 chars + dash + 4 chars, base-36)
        # 5. Detect algorithm and key_size from PEM parsing
        # 6. Create registry entry via send_cache_client
        # 7. Create fingerprint index entry
        # 8. Append KEY_PUBLISHED to transparency log
        # 9. Return { code, obj_id, fingerprint, created }

    def lookup(self, code):
        # 1. Fetch registry entry by code
        # 2. Return None if not found or not active
        # 3. Return full entry (including PEM)

    def unpublish(self, code):
        # 1. Fetch registry entry by code
        # 2. Return None if not found or already inactive
        # 3. Set active=false
        # 4. Append KEY_UNPUBLISHED to transparency log
        # 5. Return { code, status, log_entry_hash }

    def list_active(self):
        # 1. List all key entries
        # 2. Filter to active=true
        # 3. Return list (without full PEM, for payload size)

    def log_head(self):
        # Return current transparency log head

    def log_entries(self):
        # Return all transparency log entries
```

### 7.2 Fingerprint computation (server-side)

The server needs to compute fingerprints from PEM to enable the duplicate check and to populate the registry entry. This uses Python's `cryptography` library (already available via `osbot-aws` dependencies) or the standard library's `hashlib` on the raw DER bytes:

```python
import base64
import hashlib

def compute_fingerprint_from_pem(pem):
    # Strip PEM headers/footers, decode base64 to get DER bytes
    lines = pem.strip().split('\n')
    b64_data = ''.join(line for line in lines if not line.startswith('-----'))
    der_bytes = base64.b64decode(b64_data)
    digest = hashlib.sha256(der_bytes).hexdigest()
    return f"sha256:{digest[:16]}"
```

This matches the client-side `_computeFingerprint()` method, which exports the key as SPKI (DER) and hashes it.

### 7.3 Code generation

```python
import secrets
import string

def generate_lookup_code():
    """Generate a 7-character lookup code: XX-XXXX (base-36 uppercase)."""
    charset = string.ascii_uppercase + string.digits   # A-Z, 0-9
    prefix  = ''.join(secrets.choice(charset) for _ in range(2))
    suffix  = ''.join(secrets.choice(charset) for _ in range(4))
    return f"{prefix}-{suffix}"
```

Collision check: after generating, query storage for the code. If it exists, regenerate (max 5 attempts, then fail with 500). At 36^6 = ~2.2 billion possible codes, collisions are astronomically unlikely for any realistic deployment.

---

## 8. Routes layer

### 8.1 Routes__Keys

```python
# sgraph_ai_app_send/lambda__admin/fast_api/routes/Routes__Keys.py
class Routes__Keys(Fast_API__Routes):
    tag            : str = 'keys'
    service_keys   : Service__Keys

    def publish(self, body: Schema__Key__Publish__Request) -> dict:     # POST /keys/publish
    def lookup__code(self, code: str) -> dict:                          # GET /keys/lookup/{code}
    def unpublish__code(self, code: str) -> dict:                       # DELETE /keys/unpublish/{code}
    def list(self) -> dict:                                             # GET /keys/list
    def log(self) -> dict:                                              # GET /keys/log

    def setup_routes(self):
        self.add_route_post  (self.publish         )
        self.add_route_get   (self.lookup__code     )
        self.add_route_delete(self.unpublish__code  )
        self.add_route_get   (self.list             )
        self.add_route_get   (self.log              )
```

**Note on URL mapping:** The dev brief specifies `/api/keys`, `/api/keys/{code}`, etc. The `Fast_API__Routes` tag system will produce paths like `/keys/publish`, `/keys/lookup/{code}`. The `/api/` prefix can be added at the FastAPI app level if needed, or the brief's paths can be treated as logical names. The actual URL paths will follow the existing convention used by `Routes__Tokens` (e.g., `/tokens/create`, `/tokens/lookup/{token_name}`).

### 8.2 Registration in Fast_API__SGraph__App__Send__Admin

```python
# In setup_routes():
self.add_routes(Routes__Keys,
                service_keys = self.service_keys)
```

The `service_keys` is instantiated in `setup()` alongside `service_tokens`, injected with the same `send_cache_client`.

---

## 9. Phased implementation plan

### Phase 1: Shared utilities extraction (pki-common.js)

**Goal:** Extract reusable code from `pki-manager.js` into `pki-common.js`. No new features. `pki.html` works identically after the change.

**Files to create:**

| File | Description |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/shared/pki-common.js` | Shared utilities module |

**Files to modify:**

| File | Change |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/pki-manager/pki-manager.js` | Delegate extracted methods to `PKICommon` |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/pki.html` | Add `<script src="shared/pki-common.js">` before pki-manager.js |

**Key decisions:**
- Use `window.PKICommon` global (not ES modules) to match existing `<script>` loading pattern
- Keep all method signatures identical -- just move implementation
- `pki-manager.js` retains its methods but they call through to `PKICommon`

**Acceptance criteria covered:** None directly (infrastructure work).

**Complexity:** Low. Pure refactoring, no logic changes.

**Verification:** Load `pki.html`, generate key, copy public key, import contact, encrypt/decrypt. All existing functionality must work identically.

---

### Phase 2: Backend API + storage

**Goal:** Implement the four API endpoints, the service layer, storage operations, and transparency log. All testable via `pytest` with in-memory Memory-FS.

**Files to create:**

| File | Description |
|---|---|
| `sgraph_ai_app_send/lambda__admin/schemas/Schema__Key__Publish__Request.py` | Type_Safe request schema |
| `sgraph_ai_app_send/lambda__admin/schemas/Schema__Key__Registry__Entry.py` | Type_Safe registry entry schema |
| `sgraph_ai_app_send/lambda__admin/service/Service__Keys.py` | Key lifecycle service |
| `sgraph_ai_app_send/lambda__admin/fast_api/routes/Routes__Keys.py` | API route handlers |
| `tests/unit/lambda__admin/service/test_Service__Keys.py` | Service unit tests |
| `tests/unit/lambda__admin/fast_api/routes/test_Routes__Keys.py` | Route integration tests |

**Files to modify:**

| File | Change |
|---|---|
| `sgraph_ai_app_send/lambda__admin/service/Send__Cache__Client.py` | Add `NS_KEYS`, key CRUD methods, log methods |
| `sgraph_ai_app_send/lambda__admin/fast_api/Fast_API__SGraph__App__Send__Admin.py` | Register `Routes__Keys`, instantiate `Service__Keys` |

**Key decisions:**
- Lookup code format: `XX-XXXX` (2 + dash + 4, all uppercase alphanumeric)
- Fingerprint computed server-side from PEM (matches client-side computation)
- Transparency log uses SHA-256 truncated to 16 hex chars
- No authentication for POST (publish) beyond the admin Lambda's existing API key gate
- DELETE requires admin auth (already provided by Lambda-level auth)

**Acceptance criteria covered:**
- AC6: Lookup code is 6-8 alphanumeric characters
- AC7: No plaintext names stored on server
- AC8: Transparency log records all key operations
- AC9: Unpublishing a key works (DELETE returns 404 after)

**Test plan:**

```
test__publish_key                  -- POST returns code, obj_id, fingerprint
test__publish_key__duplicate       -- same PEM twice -> 409
test__publish_key__invalid_pem     -- malformed PEM -> 400
test__publish_key__with_signing    -- PEM + signing key -> both stored
test__lookup_key                   -- GET by code -> full entry returned
test__lookup_key__not_found        -- unknown code -> 404
test__unpublish_key                -- DELETE -> status unpublished
test__unpublish_key__not_found     -- unknown code -> 404
test__unpublish_key__already_gone  -- unpublish twice -> 404 on second
test__list_keys                    -- returns all active keys
test__list_keys__excludes_deleted  -- unpublished keys not in list
test__log_entries                  -- after publish+unpublish, log has 2 entries
test__log_integrity                -- each entry's previous_hash matches prior entry_hash
test__log_head                     -- head hash matches last entry
```

**Complexity:** Medium. Follows established patterns (`Service__Tokens`, `Routes__Tokens`) closely.

---

### Phase 3: Publish button + key lookup page

**Goal:** Add the "Publish to Registry" button on `pki.html` and build the `key-lookup.html` page. This is the primary user-facing workflow: publish your key, share your code, recipient looks it up.

**Files to create:**

| File | Description |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/key-lookup.html` | Key lookup page |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/key-lookup/key-lookup.js` | Key lookup Web Component |

**Files to modify:**

| File | Change |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/pki-manager/pki-manager.js` | Add "Publish to Registry" button per key card, publish modal, publish API call |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/index.html` | Add navigation link to key-lookup.html |

**Key lookup page UI flow:**

1. User enters a lookup code (text input)
2. Client sends `GET /api/keys/{code}` (via `admin-api.js` fetch helper)
3. On success: display key details (code, fingerprint, algorithm, published date)
4. Display fingerprint verification warning
5. User optionally enters a local label (stored in IndexedDB only, never sent to server)
6. User clicks "Import to My Contacts"
7. Public key + optional signing key imported to IndexedDB contacts store (same mechanism as `pki-manager.js` import)

**Publish button UI flow (on pki.html):**

1. User clicks "Publish to Registry" on a key card
2. Modal appears confirming: "This will publish your public key. Your private key stays in this browser."
3. Client sends `POST /api/keys` with the public key PEM (and signing key PEM if present)
4. On success: display the assigned lookup code with "Copy Code" button
5. Store the code locally in IndexedDB alongside the key record (so the user can see "Published as DC-7X4F" on the key card)

**Key lookup component design:**

```javascript
class KeyLookup extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this._db = null;
        this._result = null;
    }

    // Uses PKICommon for: importPublicKeyPEM, computeFingerprint,
    //                     escapeHtml, formatDate, dbAdd, openDB
}
customElements.define('key-lookup', KeyLookup);
```

**Acceptance criteria covered:**
- AC1: Can publish a public key from pki.html (click Publish -> get code)
- AC2: Can look up a key by code (enter code -> key displayed)
- AC3: Can import a looked-up key to contacts (Import -> appears in pki.html contacts)
- AC6: Lookup code format verified on publish response

**Complexity:** Medium-high. Two UI components to build/modify, API integration, IndexedDB interaction.

---

### Phase 4: Key registry page

**Goal:** Build the `key-registry.html` page showing all published keys with import capability.

**Files to create:**

| File | Description |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/key-registry.html` | Registry page |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/key-registry/key-registry.js` | Registry Web Component |

**Files to modify:**

| File | Change |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/index.html` | Add navigation link to key-registry.html |

**Registry page UI flow:**

1. On load: fetch `GET /api/keys` to get all published keys
2. Display as a list of cards: code, fingerprint, algorithm, published date
3. Each card has "Import" and "View Key" buttons
4. "Import" fetches full key via `GET /api/keys/{code}`, then imports to IndexedDB contacts (reusing PKICommon)
5. "View Key" shows the full PEM in a modal or expandable section
6. Footer shows certificate transparency link: "View Log" (opens transparency log section)
7. Transparency log section: displays the append-only log entries with hash chain integrity indicator

**Key decision -- transparency log display:**

The log is fetched via `GET /keys/log`. The client can verify the hash chain by recomputing each entry's hash from its fields and checking it matches the stored `entry_hash`, and that each `previous_hash` matches the prior entry's `entry_hash`. A green "Chain integrity verified" badge is shown if all hashes check out.

**Acceptance criteria covered:**
- AC4: Registry page shows all published keys
- AC5: Can import a key from registry (click Import -> key in contacts)
- AC8: Transparency log visible ("View Log" section)

**Complexity:** Medium. Follows the same Web Component + Shadow DOM pattern. Transparency log display is the novel part.

---

### Phase 5: QR code and polish

**Goal:** Add QR code generation for lookup codes, navigation polish, and final acceptance testing.

**Files to create:**

| File | Description |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/shared/qr-code.js` | Lightweight QR code generator (inline, no external dependency) |

**Files to modify:**

| File | Change |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/pki-manager/pki-manager.js` | Add QR button to publish success modal |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/key-registry/key-registry.js` | Add QR button per entry |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/admin-shell/admin-shell.js` | Add nav links for Key Lookup and Key Registry |

**QR code approach:**

Use a minimal inline QR encoder (no npm dependencies, no CDN). A QR code for a 7-character string is trivially small (Version 1 QR, 21x21 modules). The encoded data is the lookup code itself (e.g., `DC-7X4F`), or optionally the full lookup URL: `https://send.sgraph.ai/admin/key-lookup.html?code=DC-7X4F`.

**Acceptance criteria covered:**
- AC10: QR code for lookup code works (click QR -> scannable code shown)

**Complexity:** Low. QR generation for short strings is a solved problem with minimal code.

---

## 10. File inventory (complete)

### New files (13)

| File | Phase |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/shared/pki-common.js` | 1 |
| `sgraph_ai_app_send/lambda__admin/schemas/Schema__Key__Publish__Request.py` | 2 |
| `sgraph_ai_app_send/lambda__admin/schemas/Schema__Key__Registry__Entry.py` | 2 |
| `sgraph_ai_app_send/lambda__admin/service/Service__Keys.py` | 2 |
| `sgraph_ai_app_send/lambda__admin/fast_api/routes/Routes__Keys.py` | 2 |
| `tests/unit/lambda__admin/service/test_Service__Keys.py` | 2 |
| `tests/unit/lambda__admin/fast_api/routes/test_Routes__Keys.py` | 2 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/key-lookup.html` | 3 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/key-lookup/key-lookup.js` | 3 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/key-registry.html` | 4 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/key-registry/key-registry.js` | 4 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/shared/qr-code.js` | 5 |

### Modified files (7)

| File | Phase |
|---|---|
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/pki-manager/pki-manager.js` | 1, 3, 5 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/pki.html` | 1 |
| `sgraph_ai_app_send/lambda__admin/service/Send__Cache__Client.py` | 2 |
| `sgraph_ai_app_send/lambda__admin/fast_api/Fast_API__SGraph__App__Send__Admin.py` | 2 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/index.html` | 3, 4 |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/admin-shell/admin-shell.js` | 5 |

---

## 11. Acceptance criteria mapping

| AC# | Criterion | Phase | How verified |
|---|---|---|---|
| 1 | Can publish a public key from pki.html | 3 | Click Publish -> get a lookup code, code displayed in modal |
| 2 | Can look up a key by code | 3 | Enter code on key-lookup.html -> key details displayed |
| 3 | Can import a looked-up key to contacts | 3 | Click Import -> key appears in pki.html contacts list |
| 4 | Registry page shows all published keys | 4 | Visit key-registry.html -> all published keys listed |
| 5 | Can import a key from registry | 4 | Click Import on registry -> key in contacts |
| 6 | Lookup code is 6-8 alphanumeric characters | 2, 3 | Verify format on API response and UI display |
| 7 | No plaintext names stored on server | 2 | Inspect storage -- only Obj_Ids, PEM keys, timestamps, codes |
| 8 | Transparency log records all key operations | 2, 4 | Publish + unpublish -> entries in log; log visible on registry |
| 9 | Unpublishing a key works | 2, 3 | DELETE -> lookup returns 404, log shows KEY_UNPUBLISHED |
| 10 | QR code for lookup code works | 5 | Click QR -> scannable code shown |

---

## 12. Risks and open questions

### Risks

| Risk | Severity | Mitigation |
|---|---|---|
| **pki-manager.js refactor breaks existing PKI** | High | Phase 1 is pure refactoring with manual smoke test before proceeding. No logic changes. |
| **Server-side fingerprint differs from client-side** | Medium | Both compute SHA-256 of the raw SPKI DER bytes. The PEM parsing is identical (strip headers, base64-decode). Add a cross-verification test: client publishes, server computes fingerprint, client verifies match. |
| **QR library adds external dependency** | Low | Use a self-contained QR encoder (~200 lines JS for Version 1-2 QR codes). No CDN, no npm. |
| **Code collision on publish** | Very low | 36^6 = 2.2B possible codes. Retry up to 5 times. Log a warning if retry count > 1. |
| **Transparency log performance at scale** | Low (for now) | Listing all entries is fine for hundreds of keys. For thousands, add pagination to `GET /keys/log`. Not blocking for v0.5.0. |

### Open questions for Architect / Human

1. **Should the lookup code be case-insensitive?** The brief shows `DC-7X4F` (uppercase). If a user types `dc-7x4f`, should it match? Recommendation: yes -- normalise to uppercase on the server before lookup. This makes verbal communication easier.

2. **Should the registry page be accessible without admin auth?** The brief says "for private deployments, only authorised users can access it." The current admin Lambda requires API key auth for all routes. For a public registry, we would need to either (a) put the registry endpoints on the user Lambda, or (b) create an unauthenticated sub-path. Recommendation: keep it on admin Lambda with auth for now. Public access is a Villager-track enhancement.

3. **Should publishing require a challenge-response to prove key ownership?** Currently, anyone with admin access can publish any public key. This is fine for single-user deployments. For multi-user, we would want the publisher to prove they hold the corresponding private key (sign a server-provided nonce with the private key). Recommendation: defer to a future phase. The architecture brief covers this as part of layered identity. Not blocking for v0.5.0.

4. **Admin-shell navigation:** The existing `admin-shell.js` component manages tab navigation for the admin index page. The new pages (`key-lookup.html`, `key-registry.html`) are standalone HTML pages (same pattern as `pki.html`). Should they become panels within the admin shell instead? Recommendation: keep as standalone pages for now -- matches `pki.html` pattern and avoids coupling.

5. **Versioned path for new pages:** The new HTML pages go into `v0.1.2/` alongside `pki.html`. Should they instead go into a new version folder (`v0.1.3/`)? Recommendation: use `v0.1.2/` -- the IFD methodology versions components independently, and these new pages share the same CSS baseline. Bump to `v0.1.3` only if existing files get breaking changes.

---

## 13. Complexity estimates

| Phase | Description | Relative complexity | Estimated effort |
|---|---|---|---|
| 1 | Shared utilities extraction | Low | 0.5 day |
| 2 | Backend API + storage + transparency log | Medium | 1.5 days |
| 3 | Publish button + key lookup page | Medium-high | 1.5 days |
| 4 | Key registry page + log display | Medium | 1.0 day |
| 5 | QR code + navigation polish | Low | 0.5 day |
| **Total** | | | **5.0 days** |

---

## 14. Dependencies

| Dependency | Status | Notes |
|---|---|---|
| `osbot-fast-api` (Fast_API__Routes) | Available | Used by Routes__Tokens already |
| `osbot-utils` (Type_Safe) | Available | Used throughout |
| Memory-FS / Cache Service Client | Available | Used by Send__Cache__Client |
| Web Crypto API | Available | Browser-native, already used by pki-manager.js |
| IndexedDB | Available | Browser-native, already used by pki-manager.js |
| Python `hashlib` | Available | Standard library, for server-side fingerprint + log hashing |
| Python `base64` | Available | Standard library, for PEM parsing |
| Python `secrets` | Available | Standard library, for code generation |

No new external dependencies required.

---

## 15. Cross-references

| Document | Relevance |
|---|---|
| `team/humans/dinis_cruz/briefs/02/21/v0.4.27__dev-brief__key-discovery-and-public-registry.md` | Primary brief -- all requirements sourced from here |
| `team/humans/dinis_cruz/briefs/02/21/v0.4.27__architecture__chain-of-trust-and-key-graphs.md` | Future direction -- hash chaining, trust graphs, layered identity |
| `team/humans/dinis_cruz/briefs/02/20/v0.4.20__dev-brief__admin-pki-key-management-page.md` | Previous brief -- the PKI page this builds on |
| `sgraph_ai_app_send__ui__admin/v0/v0.1/v0.1.2/components/pki-manager/pki-manager.js` | Source for extraction (Phase 1) |
| `sgraph_ai_app_send/lambda__admin/service/Service__Tokens.py` | Pattern to follow for Service__Keys |
| `sgraph_ai_app_send/lambda__admin/fast_api/routes/Routes__Tokens.py` | Pattern to follow for Routes__Keys |
| `sgraph_ai_app_send/lambda__admin/service/Send__Cache__Client.py` | Storage layer to extend with `NS_KEYS` |
| `library/guides/development/ifd/v1.2.1__ifd__intro-and-how-to-use.md` | IFD methodology for frontend work |

---

*End of implementation plan.*
