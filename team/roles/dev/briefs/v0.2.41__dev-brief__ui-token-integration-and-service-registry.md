# Dev Brief: UI Token Integration & Admin Service Registry

**Version:** v0.2.41
**Date:** 2026-02-13
**From:** Architect / Conductor
**To:** Dev (UI session)
**Priority:** High — this is the next major implementation milestone

---

## Context

The token infrastructure on the admin Lambda is now working (create, use, revoke, list). The schemas and routes use proper Type_Safe primitives. Default `usage_limit` is 50.

This brief defines the work needed to:
1. Wire the **user Lambda** to call the **admin Lambda** for token operations
2. Update the **UI** to use tokens in URL paths
3. Use the **OSBot-Fast-API Service Registry** pattern for clean inter-service communication

---

## 1. Admin Service Client (Service Registry Pattern)

**Reference:** `library/dependencies/osbot-fast-api/v0.34.0__debrief__unified-service-client-architecture.md`

### What to create

Create the following files under `sgraph_ai_app_send/lambda__user/service/`:

#### `Admin__Service__Client.py` (stateless facade)
```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Admin__Service__Client(Type_Safe):
    def requests(self):
        requests              = Admin__Service__Client__Requests()
        requests.service_type = Admin__Service__Client
        return requests

    # Convenience methods wrapping requests()
    def token_use(self, token_name, ip_hash='', action='page_opened', transfer_id=''):
        return self.requests().post(f'/tokens/use/{token_name}',
                                     json=dict(ip_hash=ip_hash, action=action, transfer_id=transfer_id))

    def token_lookup(self, token_name):
        return self.requests().get(f'/tokens/lookup/{token_name}')
```

#### `Admin__Service__Client__Requests.py` (transport)
```python
from osbot_fast_api.services.registry.Fast_API__Client__Requests import Fast_API__Client__Requests

class Admin__Service__Client__Requests(Fast_API__Client__Requests):
    pass
```

#### `register_admin_service.py` (registration helpers)
```python
from osbot_fast_api.services.registry.Fast_API__Service__Registry              import fast_api__service__registry
from osbot_fast_api.services.registry.schemas.Fast_API__Service__Registry__Client__Config import Fast_API__Service__Registry__Client__Config
from osbot_fast_api.services.registry.schemas.Enum__Fast_API__Service__Registry__Client__Mode import Enum__Fast_API__Service__Registry__Client__Mode

def register_admin_service__in_memory(registry=None, return_client=False):
    """Register admin service using in-memory FastAPI app (for unit tests)"""
    if registry is None:
        registry = fast_api__service__registry

    from sgraph_ai_app_send.lambda__admin.fast_api.Fast_API__SGraph__App__Send__Admin import Fast_API__SGraph__App__Send__Admin
    from sgraph_ai_app_send.lambda__user.service.Admin__Service__Client import Admin__Service__Client

    fast_api = Fast_API__SGraph__App__Send__Admin().setup()

    config = Fast_API__Service__Registry__Client__Config(
        mode         = Enum__Fast_API__Service__Registry__Client__Mode.IN_MEMORY,
        fast_api_app = fast_api.app(),
        fast_api     = fast_api
    )

    registry.register(Admin__Service__Client, config)

    if return_client:
        return Admin__Service__Client()


def register_admin_service__remote(registry=None, base_url=None, api_key_name=None, api_key_value=None):
    """Register admin service pointing to live admin Lambda (for production)"""
    if registry is None:
        registry = fast_api__service__registry

    from osbot_utils.utils.Env import get_env
    from sgraph_ai_app_send.lambda__user.service.Admin__Service__Client import Admin__Service__Client

    config = Fast_API__Service__Registry__Client__Config(
        mode          = Enum__Fast_API__Service__Registry__Client__Mode.REMOTE,
        base_url      = base_url      or get_env('SGRAPH_SEND__ADMIN__BASE_URL', 'https://admin.send.sgraph.ai'),
        api_key_name  = api_key_name  or get_env('SGRAPH_SEND__ADMIN__API_KEY_NAME', ''),
        api_key_value = api_key_value or get_env('SGRAPH_SEND__ADMIN__API_KEY_VALUE', ''),
    )

    registry.register(Admin__Service__Client, config)
```

### Env vars for production

| Env Var | Purpose | Set on |
|---------|---------|--------|
| `SGRAPH_SEND__ADMIN__BASE_URL` | Admin Lambda URL | User Lambda |
| `SGRAPH_SEND__ADMIN__API_KEY_NAME` | Admin API key header name | User Lambda |
| `SGRAPH_SEND__ADMIN__API_KEY_VALUE` | Admin API key header value | User Lambda |

---

## 2. Token in URL Paths

### Current flow
```
send.sgraph.ai/d/{transfer_id}#key
```

### New flow with tokens
```
send.sgraph.ai/t/{token_name}/{transfer_id}#key
```

The token is embedded in the share URL so:
1. User Lambda validates the token before serving the download page
2. Each page load / download consumes one token use
3. When token is exhausted, the link stops working
4. This creates an audit trail (the sherpa's tracking requirement)

### Route changes needed

In `Routes__Transfers.py` (or new routes file):
- `GET /t/{token_name}/{transfer_id}` — serves download page (validates token, records `page_opened`)
- The download page JS then calls `GET /transfers/download/{transfer_id}` with the token in a header or query param

### Token validation flow
```
1. Browser hits /t/{token_name}/{transfer_id}
2. User Lambda calls Admin__Service__Client().token_use(token_name, action='page_opened')
3. If success=True → serve download page
4. If success=False → serve error page (expired, exhausted, revoked)
5. Download page JS fetches /transfers/download/{transfer_id}
```

---

## 3. UI Changes

### Upload page (`send.sgraph.ai/send`)
- After upload completes, the share URL must include the token: `/t/{token_name}/{transfer_id}#key`
- The upload flow needs to:
  1. Call admin service to create a token (or the backend does this automatically on transfer create)
  2. Include token_name in the share URL

### Download page (`send.sgraph.ai/d/...` → `send.sgraph.ai/t/...`)
- New URL pattern: `/t/{token_name}/{transfer_id}#key`
- Page must handle token validation errors (show appropriate messages)
- Decryption key still in fragment (never sent to server)

### Admin console
- Token list view should already work with existing `/tokens/list` endpoint
- Consider adding token usage stats display

---

## 4. Test Strategy

### Unit tests — use in-memory admin service
```python
@classmethod
def setUpClass(cls):
    fast_api__service__registry.configs__save(clear_configs=True)
    register_admin_service__in_memory()
    # ... setup user service with admin client available via registry

@classmethod
def tearDownClass(cls):
    fast_api__service__registry.configs__restore()
```

### Tests to write
1. Token validation on download page route (valid, exhausted, revoked, not_found)
2. Token creation during upload flow
3. Share URL generation with token
4. Full flow: upload → create token → share URL → download with token validation
5. Admin service client: in-memory requests work correctly

---

## 5. Key Architecture Decisions (Confirmed by Dinis)

1. **Service Registry pattern** for user→admin communication (not direct HTTP calls)
2. **Env vars** `SGRAPH_SEND__ADMIN__API_KEY_NAME` / `SGRAPH_SEND__ADMIN__API_KEY_VALUE` on user Lambda
3. **Token in URL path**: `send.sgraph.ai/t/{token_name}/{transfer_id}#key`
4. **In-memory admin for tests** — register_admin_service__in_memory() creates full admin FastAPI app in-memory, user service routes call it via registry
5. **Code has no idea if it talks to live Lambda or in-memory** — this is the power of the Service Registry architecture

---

## 6. Files to Reference

| Document | Path |
|----------|------|
| Service Registry architecture | `library/dependencies/osbot-fast-api/v0.34.0__debrief__unified-service-client-architecture.md` |
| Safe primitives reference | `library/dependencies/osbot-utils/type_safe/v3.28.0__for_llms__osbot-utils-safe-primitives.md` |
| Current token routes | `sgraph_ai_app_send/lambda__admin/fast_api/routes/Routes__Tokens.py` |
| Token service | `sgraph_ai_app_send/lambda__admin/service/Service__Tokens.py` |
| Token schemas | `sgraph_ai_app_send/lambda__admin/schemas/Schema__Token__*.py` |
| Transfer routes | `sgraph_ai_app_send/lambda__user/fast_api/routes/Routes__Transfers.py` |
| User UI assets | `sgraph_ai_app_send__ui__user/` |
| Admin UI assets | `sgraph_ai_app_send__ui__admin/` |

---

## 7. Implementation Order

1. Create `Admin__Service__Client`, `Admin__Service__Client__Requests`, `register_admin_service.py`
2. Write tests for in-memory admin service registration
3. Add token-aware download route (`/t/{token_name}/{transfer_id}`)
4. Update upload flow to create tokens and generate share URLs with tokens
5. Update download page UI to handle token validation
6. Update upload page UI to display new share URL format
7. Full integration test: upload → share → download with token validation
