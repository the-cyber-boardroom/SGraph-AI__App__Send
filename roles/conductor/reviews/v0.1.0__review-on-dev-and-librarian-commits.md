# Review on Dev and Librarian commits

**version** v0.1.0
**date** 8 Feb 2026

## General Observations

- every markdown file that is created for this repo should have the current version as the prefix (just like I did in this file which is called "v0.1.0__review-on-dev-and-librarian-commits.md"). The version number is at sgraph_ai_app_send/version
- one very important assumption is that ALL data that we see on the backend is classified as non-sensitive and non-confidential. this means that we will need a mode to anonymise some data (like IPAddress), so that we can use them on stats
- I moved all files from the architecture folder in to the roles/architect/v0.1.1 folder (and prefixed all those files with the current version of this repo: v0.1.1)
- keeping with the idea of having no sensitive data in our platform, let's move the entire 'Register Interest' to another platform (this actually means that we won't need to implement it, and have it on the site sooner). Add a task to do research for a good platform to use  

## Architecture

- we are going to use Memory-FS for simulating (and have support) for a generic data store (see doc I'm going to provide). this means that we could have a data store that works: in memory, in a zip file, in a mysql file, and in S3. We are going to use Memory-Fs in single file mode (see docs in library/dependencies/memory-fs) 
- for integration tests that actually need access to S3 we are going to use LocalStack since it nicely supports S3 and per-signed urls
- design change: so that we support the wider set of deployment modes (provided by Memory-FS) we will need to both support the file save direct to S3 (or what ever storage was used, since we will also need to support other cloud storage like Azure, GCP, Minio, etc..) . this means that we will have to have endpoints to save and retrieve files (which are encrypted binary bytes) from the server's configured storage (which could be in memory to disk, or other). This will also apply to all other files the system needs to save (for example the IPAddress and file usage data). Yes this will have a number of limitations depending on the deployment (for example the MBs limits of AWS Lambdas)
- there are some questions about file sizes, so for the MVP, let's keep it at a lower (max 100Mb)
- We will be using OSBot-Fast-API-Serverless package (which I will wire up to the project already support a header/cookie based auth (each server can define an key-name and key-value that are check on all requests (apart from the /docs one))
- with the changes described above we will be able to create and simulate the full workflow purely on the rest API (and do it al in Memory which is super fast)
- the fact that we can run (and start in about 100ms) the entire stack in memory, means that for tests (apart from specific integration tests that will target LocalStack or S3) we will NOT use any mocks or patches in the tests (I will provide some code samples on how I do this in other projects)
- CORS is already supported nicely by osbot-fast-api
- The Type_Safe class sits at the heart of every code pattern (since it provides run-time type safety and many more powerful development benefits). See the guidance in ./library/dependencies/osbot-utils/type-safe
- the Osbot-utils already provides quite a lot of helper methods that dramatically simplify lots of code patterns (for example file, json or temp resources), see ./library/dependencies/osbot-utils/features 
- All code and tests must follow the guidance provided in the docs in ./library/guides/development
- I will do all of Feature-8 with the first implementation of the Fast_API class and .github actions, which will implement a CI pipeline that will: test the code, tag the version, deploy to aws dev lambda (or qa depending on the branch it was pushed to), assuming privs are defined on Lambda (to be fine-tuned later), any S3 bucket needed will be created on start
- on Memory-FS S3 support, I will provide the class that we can use
- All AWS class and actions MUST be done using the osbot-aws class (see guidance at library/dependencies/osbot-aws) , and NEVER using boto3 directly (I am the maintainer of the osbot-aws pypi package, so if we need to make changes to it we can)

### notes on docs/architecture/fastapi-service-plan.md
- to start with we are going to be using Lambda Url Functions (so we don't need the API Gateway)
- as mentioned above "Lambda never touches file bytes" will depend on the deployment mode, since we will need to support this (note that the service code has no idea what storage is being used, since that is an abstraction layer provided by Memory-FS)
- "S3 as database" should be "File System as Database" (which memory abstracts, so the files could be captured in memory, in local disk, in a zip/mysql file or in cloud storage like S3)
- "Mangum adapter", yes and this is already all nicely provided by osbot-fast-api
- we are not going to do use a Base path like "api/v1/" , at a later stage (please add to roadmap) we will be creating a python API that will provide the abstraction layer between the REST API and the actually methods a consumer of that API will want to use, which means that we don't need to have 'protective' paths patterns like /v1 (see ./library/guides/patterns/v1.1.4___v0.16.1__cache_service__testing_guidance.md for how I use this pattern in another project)
- Error format: all methods should have a specific Type_Safe schema, and Http method errors will be raised (404 for not found, 500 for internal errors, etc..) for cases where we can't provide a good response (I will provide examples from existing projects with the pattern to use in action)
- Timestamps: all timestamps to use an ints, and provided by the class : from osbot_utils.type_safe.primitives.domains.identifiers.safe_int.Timestamp_Now            import Timestamp_Now
- transfer_id, token_id and admin_key are all Obj_Id (from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id) and should be setup just like Node_Id (from OSBot_Utils)
- on Authentication, we need to split these into two separate lambda functions (which will simplify our design and security model): a lambda function with only the public endpoints (which should be design to need at least a unique value to return any data, for example one of the ids, which are all random), and the admin endpoints (which are protected by the built-in osbot-fast-api auth capabilities)
- we will need to update the  /api/v1/transfers to have the other capabilities (making the actions very explict  for example have a method to 'create/presign-url')
- NOTE: let's create a logging mode where all actions and request called about a particular item are also logged (this will also be available to the UI/caller, where we can then create a UX that shows the 'main' actions, and 'all the actions' (i.e. all rest calls related to that particular id/asset, for example the call to 'create/presign-url')). This will be massive help to developers/qa, but will also be quite educational on how things are working and help with the transparency of the entire system
- on the "Create transfers/{transfer_id}/meta.json in data bucket", we will need to define much better the file structure to use here, since we will want to store a lot more data and entries in the "transfers/{transfer_id}". For example all actions, all requests, all entries. Basically this folder should have EVERYTHING have happened and is related to transfer_id (note that the cost of saving an extra file (for example per request) is minimal since most access/actions will be one-off actions, triggered by user actions). also all this data should be in an encrypted state and there should be no assets in there )
- same as above for "api/v1/transfers/{id}/download" we will need more methods here. this will actually help us to be able to simplify the data returned (and have more flexibility in adding new methods), for example the methods that provide more details about this download (taking into account that we will have quite a number of different types of files in the 'transfer-id' folder)
- please have another go at mapping out the data model of the S3 Data Bucket Layout (can you put all file storage content in a separate file ('i.e. not on the fast-api-service-plan.md' file))
- re events.json, we should have an 'events' folder, with each event being its own file (with a unique event-id)
- the "Lambda Handler Design" needs a re-design to take into account the OSBot-Fast-Api patterns, where every route is a class . Also note that everything else are classes too (for example the services, which should all follow the format or Service__App__Send__*)
- for all schemas create (one schema per file) also use the pattern Schema__App__Send__*
- the Entry Point is provided by Fast_API 
- On Observabilitiy, yes we will use those AWS features, but a VERY important of our design, is that we should be also using our file storage as our Observability storage were we should have every data about everything that happens in this platform (I will share later ways for use to scale the use of this data, using graphs and other techniques) 

# on v0.1.1__frontend-ui-plan.md
- for the UI development we are going to be using the IFD methodology (see library/guides/development/ifd for details), which already provides quite a prescriptive way on how to only use Web Components (and other techniques)
- to start with, the entire ui will be wired as static Fast_API route (I will also wire that part up)
- since we now have two lambda functions (as described above) we will also have two websites (the admin and the user). This simplifies the auth and authorization 
- on the URL Routing we should be doing this SPA with routes controlled by the client (we will send the index.html page for all traffic that hits a particular url). this will make the UI much more responsive (while allowing deep linking)
- this means that we are not going to use hash routing (/#/d/{id})
- on Component Structure see the IFD
- for the UIs, I would like us to start adding support from the start to the idea of having multiple themes and ui layouts (so that we can do A-B testing and get feedback from users from the day one). 
- this means that we should also be supporting from the start content in multiple languages and multiple Accessibility modes
- for the encryption and decryption we will need a UI to explore it and show it in practice (which actually might be nice user tools)
- in terms of the UIs to create we need at least 3 
    1) the main user workflow , super simple, and focused on the main use case (upload, share and retrieve files) - these pages should be super simple, have as least amount of code as possible, and be super fast to load
    2) the user 'tools' site, which is where we can share with the user all sorts of details, data and utils - for now let's use the 'admin panel' mode that I will describe below for this site (which will give us quite a lot of easy ways to add new features). Once this matures we can refactor it. for now assume that any user that is using these pages is an 'power user'
    3) the admin site - which uses the 'admin panel' mode
- for the email share add support for the feature that gmail has to create emails via an URL
- we need a UI to show the user all data that is currently stored in this site's cookies and localstorage
- we need a UI to allow direct requests (aka API explorer) for the key backend API and other services like the S3 storage (useful in development and for power users)
- for the Page Designs (Detailed) we will need a folder per page, where in each page will have all sorts of artifacts/files related to that page (mockups, data models, html/css/js references, architecture diagrams (if relevant), events, faq, etc..). this doesn't need to be the full code, but should be detailed enough so that when the dev implements it, there should be no ambiguity or questions  
- for these Page's folders thing in modules and reusable components (which should be cross-referenced between them). it very important that we don't have tons of repeated content in these folders
- data like "CloudFront Configuration" should be in a devops doc

## on roles/architect/v0.1.1/v0.1.1__issues-fs-improvements.md

1. "Missing: "Phase" as a First-Class Node Type" so just add it to the node-types.json file (which was missing, so I just added a default on to this project). The whole idea of the Isses-Fs fractal nature of the issues types is that each project or even issue, can define its own issue-types and issue-links
1 to 7 all these can be resolved by adding new issue types and link types (for example you can create an Issue type 'Status' with 4 issues inside it "draft → review → merged → superseded" which you then link to the respective issue)
8. "CLI Missing: No CLI Installed" , just install it  https://pypi.org/project/issues-fs-cli/ (in fact "issues-fs-cli" is in pyproject.toml)

## on roles/architect/v0.1.1/v0.1.1__system-landscape-map.md

- I had a look and a lot of this data needs to be changed based on the comments and decisions I made above