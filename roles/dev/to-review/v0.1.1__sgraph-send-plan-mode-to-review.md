# SGraph Send â€” Plan Mode Implementation Plan (To Review)

**Project:** `SGraph-AI__App__Send`  
**Product:** `send.sgraph.ai`  
**Status:** To Review  
**Date:** February 8, 2026  
**Roles covered:** Developer, Security Reviewer, QA

---

## 1. Scope and Intent

This document consolidates the implementation plans for:

1. FastAPI backend service (P0)
2. Frontend UI + browser crypto flow (P0)
3. Security review execution plan (P1)
4. QA and E2E validation plan (P1)

It is intended for review/merge by the Conductor and Architect before implementation starts.

---

## 2. FastAPI Service Plan (Developer, P0)

### 2.1 Implementation Approach and Critical Path

1. Build API skeleton, shared config, and response contracts.
2. Implement auth dependencies for sender and admin routes.
3. Implement S3 repository layer (`meta`, `event`, `token`, `presign`).
4. Implement upload path first:
   - `POST /transfers`
   - `POST /transfers/{id}/complete`
5. Implement read/download path:
   - `GET /transfers/{id}`
   - `GET /transfers/{id}/download`
6. Implement admin token endpoints:
   - `POST /tokens`
   - `GET /tokens`
   - `DELETE /tokens/{id}`
7. Add Lambda adapter (`Mangum`).
8. Complete unit/integration tests and hardening pass.

### 2.2 Proposed Backend Structure

```text
sgraph_ai_app_send/
  api/
    app.py
    lambda_handler.py
    routes/
      transfers.py
      tokens.py
      health.py
    deps/
      auth.py
      request_context.py
    models/
      transfers.py
      tokens.py
      errors.py
  core/
    settings.py
    ids.py
    time.py
  storage/
    s3_client.py
    repository.py
    schemas.py
  services/
    transfers_service.py
    tokens_service.py
    events_service.py
  security/
    redaction.py
tests/
  unit/
    api/
      test_auth.py
    services/
      test_transfers_service.py
    storage/
      test_repository.py
  integration/
    test_transfers_api.py
    test_tokens_api.py
```

### 2.3 Key Code Patterns

#### A) Pre-signed URL generation

- Use `boto3.client("s3").generate_presigned_url`.
- Upload URL:
  - Operation: `put_object`
  - Key: `transfers/{transfer_id}/payload.enc`
  - Content-Type: `application/octet-stream`
  - SSE: `AES256`
- Download URL:
  - Operation: `get_object`
  - Same object key
- Recommended expiry: **900 seconds (15 minutes)** (configurable).

#### B) Authentication

- Sender routes require: `Authorization: Bearer tok_*`
- Admin routes require: `Authorization: Bearer adm_*`
- Download/status routes remain public by design.
- Token state validation: malformed, revoked, expired.

#### C) Request/Response models (Pydantic)

- Strict typed request/response models.
- Canonical transfer statuses:
  - `pending`
  - `completed`
  - `expired`
  - `deleted`
- Do not store or return file names from server metadata.

#### D) Error handling

- Single error envelope for all errors:
  - `code`
  - `message`
  - `request_id`
- No stack traces or infrastructure leakage in responses.

#### E) Event logging

- Recommended write model for concurrency:
  - Store immutable events at `transfers/{id}/events/{event_id}.json`
- Maintain `download_count` in `meta.json`.
- Build timeline by listing event objects.

Note: if strict single `events.json` is mandatory, treat it as a derived artifact (not the write-hot source of truth).

#### F) Lambda adapter

- `app = FastAPI(...)` in `api/app.py`
- `handler = Mangum(app)` in `api/lambda_handler.py`

### 2.4 Backend Testing Strategy

1. Unit tests with `moto` for S3 behavior.
2. Integration tests with FastAPI `TestClient` + mocked S3.
3. Security regression tests:
   - Server never returns decryption key fields.
   - `meta.json` has no file-name/content storage.
   - Presigned URLs are object-scoped.
4. Negative-path tests:
   - Invalid auth headers
   - Unknown transfer IDs
   - Missing payload
   - Malformed request bodies

### 2.5 Concerns / Questions / Pushback

1. Single `events.json` is vulnerable to race conditions under concurrent downloads.
2. Spec has mixed presigned expiry guidance (1 hour vs short-lived security guidance).
3. Browser MVP with whole-file AES-GCM is not ideal for 500MB; large-file strategy needs a decision.
4. Need explicit CORS allowlist per environment.
5. Need explicit policy for exposing receiver metadata on sender status pages.

### 2.6 Effort Estimate (Backend)

| Component | Estimate |
|---|---:|
| API scaffold, config, models, error contract | 0.5 day |
| S3 repository + presigned URLs + metadata I/O | 1.0 day |
| Auth dependencies (sender/admin) | 0.5 day |
| Transfer endpoints | 1.0 day |
| Token endpoints | 0.5 day |
| Event logging + status | 0.5 day |
| Unit + integration tests | 1.0 day |
| Hardening + docs | 0.5 day |
| **Total** | **5.5 days** |

---

## 3. Frontend UI + Crypto Plan (Developer, P0)

### 3.1 Page Breakdown

1. `/` upload page
   - Token input
   - Drag/drop or file picker
   - Encrypt/upload controls and progress
2. `/d/{transfer_id}` download page
   - Key input
   - Download + decrypt flow
3. `/s/{transfer_id}` status/result page
   - Link + key display
   - Transparency panel
   - Download count/timeline/expiry

### 3.2 Proposed Frontend Structure

```text
frontend/
  index.html
  d/index.html
  s/index.html
  assets/
    css/
      tokens.css
      base.css
      upload.css
      download.css
      status.css
    js/
      config.js
      api.js
      crypto.js
      encoding.js
      upload-flow.js
      download-flow.js
      status-flow.js
      ui.js
      errors.js
      storage.js
```

### 3.3 Client-side Encryption Implementation

#### A) Key generation

- Generate AES-GCM 256-bit key in browser:
  - `crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"])`
- Export raw key and encode as base64url for sender display.

#### B) Encryption format

- IV: 12 random bytes (`crypto.getRandomValues`).
- Cipher operation: AES-256-GCM.
- Payload format:
  - `[12-byte IV][ciphertext+auth-tag]`

#### C) Upload flow

1. Request `POST /transfers` to obtain pre-signed PUT URL.
2. Encrypt file in browser.
3. Upload encrypted bytes directly to S3 using pre-signed PUT URL.
4. Call `POST /transfers/{id}/complete`.
5. Show result panel with link + key and transparency data.

#### D) Download flow

1. Request `GET /transfers/{id}/download` to obtain pre-signed GET URL.
2. Download encrypted bytes from S3 in browser.
3. Parse IV and ciphertext.
4. Import key from user-entered base64url.
5. Decrypt in browser and save file locally.

### 3.4 UI/UX Flow Details

#### Upload page

- States: `idle -> encrypting -> uploading -> complete`
- Progress indicators for encryption and upload.
- Disable action controls while operation is in-flight.

#### Result/status page

- Show:
  - Download link (copy button)
  - Decryption key (copy button)
  - Guidance to share link and key via different channels
  - Transparency panel with stored vs not-stored metadata

#### Download page

- Key input validation before decrypt.
- Distinct progress for download and decrypt phases.
- Clear error on wrong key.

### 3.5 Error Handling UX

1. Wrong key: explicit decryption failure message.
2. Expired transfer: dedicated expired state.
3. Incomplete transfer (no `payload.enc`): explicit sender-incomplete message.
4. Network/API failures: retry option + request reference.
5. Oversized file: fail client-side before encryption starts.

### 3.6 Mobile Responsiveness

1. Mobile-first layout and touch-friendly controls.
2. No hover-only affordances.
3. Avoid viewport-height traps on iOS Safari.
4. Validate on Android Chrome and iOS Safari.

### 3.7 Frontend Testing Strategy

1. Crypto unit tests:
   - encrypt -> decrypt roundtrip
   - wrong-key decryption fails cleanly
2. Browser E2E tests (Playwright):
   - full upload/download/decrypt flow
   - result/status rendering and copy controls
3. Mobile profile tests:
   - Android Chrome (Playwright profile)
   - iOS Safari manual pass

### 3.8 Concerns / Questions / Pushback

1. 500MB target may not be practical with whole-file in-memory AES-GCM in MVP.
2. CloudFront route rewrite behavior for `/d/{id}` and `/s/{id}` must be confirmed.
3. Filename handling policy must be explicit since server intentionally does not store filename.
4. Clarify whether text mode is in initial MVP scope or near-term follow-up.

### 3.9 Effort Estimate (Frontend)

| Component | Estimate |
|---|---:|
| Page scaffold + shared UI modules | 1.0 day |
| Crypto + encoding modules | 1.0 day |
| Upload flow with progress | 1.0 day |
| Download/decrypt flow | 1.0 day |
| Status page + polling | 0.5 day |
| Error states + mobile polish | 0.5 day |
| E2E + browser tests | 1.0 day |
| **Total** | **6.0 days** |

---

## 4. Security Review Execution Plan (Security Reviewer, P1)

### 4.1 Review Checklist

- [ ] AES-256-GCM parameters are correct (256-bit key, 96-bit IV, auth tag handling)
- [ ] IV is random and unique per encryption operation
- [ ] Key generation uses Web Crypto randomness
- [ ] Decryption key is never sent to API or persisted server-side
- [ ] Pre-signed URLs are short-lived and object-scoped
- [ ] Sender token validation rejects malformed/revoked/expired tokens
- [ ] Admin endpoints enforce admin key
- [ ] Error messages do not leak internals
- [ ] S3 data contains ciphertext payload only (`payload.enc`)
- [ ] `meta.json` excludes file names and plaintext content
- [ ] `events` logging does not leak sensitive payload data
- [ ] CORS is restricted to intended frontend origins
- [ ] API/browser content type handling prevents sniffing issues
- [ ] S3 buckets enforce no public access

### 4.2 Security Deliverable

Security review report with findings categorized by severity:

- Critical
- High
- Medium
- Low

Release gate: no unresolved Critical/High findings.

---

## 5. QA Plan and E2E Coverage (QA, P1)

### 5.1 Core Transfer Flow Tests

1. Sender token auth -> create transfer -> encrypted upload -> complete.
2. Receiver open link -> provide key -> download -> decrypt.
3. Integrity check: downloaded/decrypted file equals original.
4. Verify S3 stores ciphertext only.
5. Verify status page download counts/events update.

### 5.2 Edge Case Coverage

- Expired token -> rejected
- Revoked token -> rejected
- Non-existent transfer ID -> 404
- Missing `payload.enc` -> clear error
- Very small file (1 byte) -> success
- Large file near allowed limit -> success/fail with correct handling
- Empty request body -> 422/validation error
- Concurrent downloads -> succeed and count accurately

### 5.3 Mobile Coverage

- iOS Safari: upload flow and download/decrypt flow
- Android Chrome: upload flow and download/decrypt flow

### 5.4 QA Deliverable

Automated E2E suite + manual mobile verification report with pass/fail per scenario.

---

## 6. Consolidated Estimates and Timeline

| Stream | Estimate |
|---|---:|
| Backend implementation + tests | 5.5 days |
| Frontend implementation + tests | 6.0 days |
| Security review + remediation loop (initial pass) | 1.0 day |
| QA E2E + mobile verification | 1.0 day |
| **Total initial delivery window** | **~13.5 days** |

---

## 7. Decisions Needed Before Build Starts

1. Presigned URL expiry default (`10-15 min` recommended vs `60 min` examples).
2. Event storage strategy:
   - strict single `events.json`
   - immutable per-event files (recommended).
3. MVP max file size (`100MB` recommended unless chunked encryption is approved).
4. Exact CORS allowlist per environment.
5. Sender visibility level for receiver metadata on status pages.
6. Text mode inclusion in immediate MVP scope.
7. CloudFront routing/rewrite behavior for deep links.

---

## 8. Proposed Defaults (If No Decision Is Provided)

1. Presigned URL expiry: **900 seconds**
2. Event storage: **immutable per-event objects**
3. Max file size MVP: **100MB**
4. CORS: **explicit allowlist for dev/qa/prod frontend hosts only**
5. Text mode: **defer until file flow is stable**
6. Deep-link routing: **CloudFront rewrite to app entry pages**

---

## 9. Review Outcome Template

Use this section during review:

- Accepted as-is:
- Accepted with changes:
- Rejected:
- Open decisions:
- Final merged brief owner:
- Implementation start date:

