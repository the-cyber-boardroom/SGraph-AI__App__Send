# IFD — Services Layer & API Integration

**Purpose**: How to build services that wrap API calls, manage state, and emit events
**Companion to**: `v1.2.1__ifd__intro-and-how-to-use.md` (parent IFD guide)

---

## Service Architecture

Services are **singleton JavaScript classes** attached to `window.issuesApp.*`. They sit between components and the backend API, providing:

- API call abstraction (components never call `fetch()` directly)
- Client-side caching
- Event emission on state changes
- Error handling and propagation

```
┌────────────────┐     events      ┌────────────────┐
│   Component A  │◄──────────────►│                  │
└────────────────┘                 │   EventBus       │
┌────────────────┐     events      │                  │
│   Component B  │◄──────────────►│                  │
└────────────────┘                 └────────┬─────────┘
                                            │ events
                                   ┌────────▼─────────┐
                                   │   GraphService    │
                                   │   (API client)    │
                                   └────────┬─────────┘
                                            │ fetch()
                                   ┌────────▼─────────┐
                                   │   Backend API     │
                                   └──────────────────┘
```

---

## The Service Pattern

### Template

```javascript
(function() {
    'use strict';

    class MyService {
        constructor() {
            this._cache = new Map();           // optional client-side cache
        }

        // Public API method
        async doSomething(param) {
            try {
                const response = await this._fetch('/api/endpoint', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ param })
                });

                if (response.success) {
                    this._cache.set(param, response.data);
                    this._emit('something-done', { param, data: response.data });
                }

                return response;
            } catch (error) {
                this._emit('api-error', {
                    operation: 'doSomething',
                    error: error.message
                });
                throw error;
            }
        }

        // Clear cache
        clearCache() {
            this._cache.clear();
            this._emit('cache-cleared', {});
        }

        // Refresh (clear cache + notify)
        refresh() {
            this.clearCache();
            this._emit('refresh', {});
        }

        // Internal: fetch wrapper
        async _fetch(url, options = {}) {
            const response = await fetch(url, {
                ...options,
                credentials: 'include'
            });

            if (!response.ok) {
                const error = await response.json().catch(() => ({ message: response.statusText }));
                throw new Error(error.detail || error.message || `HTTP ${response.status}`);
            }

            return response.json();
        }

        // Internal: emit event
        _emit(event, data) {
            if (window.issuesApp && window.issuesApp.events) {
                window.issuesApp.events.emit(event, data);
            }
        }
    }

    // Expose as singleton
    window.issuesApp = window.issuesApp || {};
    window.issuesApp.myService = new MyService();
})();
```

### Key Decisions

1. **IIFE** — prevents polluting global scope
2. **`_fetch()` wrapper** — centralized error handling, credentials, JSON parsing
3. **`_emit()` wrapper** — safely checks if EventBus exists (loading order tolerance)
4. **`api-error` event** — standardized error reporting, auto-consumed by MessagesService
5. **Cache is optional** — use `Map` for simple key-value, clear on mutations

---

## The GraphService (Concrete Example)

The main API client for the issue tracker:

```javascript
class GraphService {
    constructor() {
        this._nodeCache = new Map();
    }

    // CRUD operations
    async listNodes()                    { ... }    // GET  /nodes/api/nodes
    async listNodesByType(nodeType)      { ... }    // GET  /nodes/api/nodes/type/{type}
    async getNode(label)                 { ... }    // GET  /nodes/api/nodes/{label}
    async createNode(data)               { ... }    // POST /nodes/api/nodes
    async updateNode(label, data)        { ... }    // PATCH /nodes/api/nodes/{label}
    async deleteNode(label)              { ... }    // DELETE /nodes/api/nodes/{label}

    // Link operations
    async listLinks(label)              { ... }     // GET  /links/api/nodes/{label}/links
    async createLink(src, verb, target) { ... }     // POST /links/api/nodes/{src}/links
    async deleteLink(src, target)       { ... }     // DELETE /links/api/nodes/{src}/links/{target}

    // Type metadata (static, from config)
    getNodeType(typeName)               { ... }     // returns { color, icon, statuses }
    getNodeTypes()                      { ... }     // returns all type configs
    getLinkType(verb)                   { ... }     // returns { inverse, description }
    getStatusesForType(nodeType)        { ... }     // returns ['backlog', 'todo', ...]

    // Cache management
    clearCache()                        { ... }
    refresh()                           { ... }
}

window.issuesApp.graph = new GraphService();
```

### Cache Invalidation Strategy

```javascript
async createNode(data) {
    const response = await this._fetch('/nodes/api/nodes', { method: 'POST', ... });
    if (response.success && response.node) {
        this._nodeCache.set(response.node.label, response.node);   // cache the new node
        this._emit('node-created', { node: response.node });
    }
    return response;
}

async deleteNode(label) {
    const response = await this._fetch(`/nodes/api/nodes/${label}`, { method: 'DELETE' });
    if (response.success) {
        this._nodeCache.delete(label);                              // evict from cache
        this._emit('node-deleted', { label });
    }
    return response;
}

async createLink(sourceLabel, verb, targetLabel) {
    const response = await this._fetch(`/links/api/nodes/${sourceLabel}/links`, { method: 'POST', ... });
    if (response.success) {
        this._nodeCache.delete(sourceLabel);                        // invalidate both nodes
        this._nodeCache.delete(targetLabel);                        // (links changed)
        this._emit('link-created', { sourceLabel, verb, targetLabel });
    }
    return response;
}
```

---

## ConfigManager

Manages persistent settings via localStorage:

```javascript
const config = window.issuesApp.config;

config.get('api.endpoints.nodes')          // → '/nodes/api/nodes'
config.get('ui.theme')                     // → 'dark'
config.set('ui.sidebarCollapsed', true)    // saves to localStorage immediately
config.getEndpoint('nodes')               // → '/nodes/api/nodes' (baseUrl + endpoint)
config.addRecent('nodes', 'Bug-27')        // MRU list (max 20 items)
config.reset()                             // restore defaults
```

### Events Emitted

```
config-loaded     — { config }        — after loading from localStorage
config-changed    — { path, value }   — when set() is called
config-reset      — {}                — when reset() is called
```

### Default Config Structure

```javascript
const DEFAULT_CONFIG = {
    version: 1,
    api: {
        baseUrl: '',                           // empty = relative to current host
        endpoints: {
            issues    : '/issues/api/issues',
            nodes     : '/nodes/api/nodes',
            types     : '/types/api/types',
            linkTypes : '/types/api/link-types',
            server    : '/server/status'
        }
    },
    ui: {
        theme           : 'dark',
        sidebarCollapsed: false,
        leftNavWidth    : 240
    },
    recent: {
        nodes    : [],                         // recently viewed nodes
        searches : []                          // recent search terms
    }
};
```

---

## Surgical Service Overrides

Because services are on `window.issuesApp.*`, later versions can surgically override individual methods:

```javascript
// v0.1.4/js/graph-service-override.js
// Adds getNodeGraph() method to GraphService

(function() {
    'use strict';

    const GraphServiceClass = window.issuesApp.graph.constructor;

    // Add new method (doesn't exist in v0.1.0)
    GraphServiceClass.prototype.getNodeGraph = async function(label, depth) {
        const response = await this._fetch(`/nodes/api/nodes/${label}/graph?depth=${depth}`);
        this._emit('node-graph-loaded', { label, depth, graph: response });
        return response;
    };

    console.log('[v0.1.4] GraphService patched: getNodeGraph()');
})();
```

```javascript
// v0.1.5/js/messages-service-override.js
// Adds confirm() method to MessagesService

(function() {
    'use strict';

    const MessagesServiceClass = window.issuesApp.messages.constructor;

    // Add confirm dialog method
    MessagesServiceClass.prototype.confirm = function(text, onConfirm, onCancel) {
        const msg = this.add('warning', text, { autoDismiss: false });
        msg._onConfirm = onConfirm;
        msg._onCancel  = onCancel;
        msg.isConfirm  = true;
        return msg;
    };
})();
```

This is the IFD surgical override pattern applied to services — add or replace one method at a time, loaded after the base service.

---

## Auto-Wiring: API Errors → Messages

The MessagesService auto-listens for `api-error` events and creates user-facing messages:

```javascript
// In messages-service.js initialization:
if (window.issuesApp.events) {
    window.issuesApp.events.on('api-error', (data) => {
        const operation = data.operation || 'API call';
        const error     = data.error || 'Unknown error';
        window.issuesApp.messages.add('error', `${operation} failed: ${error}`);
    });
}
```

This means **any service** that emits `api-error` automatically gets a user-facing error message. The service doesn't need to know about the MessagesService or the MessagesPanel. It just emits the event.

---

## Service Loading Order

```html
<!-- Order matters: EventBus must be first -->
<script src="js/event-bus.js"></script>           <!-- 1. EventBus singleton -->
<script src="js/config-manager.js"></script>      <!-- 2. Config (uses EventBus) -->
<script src="js/graph-service.js"></script>       <!-- 3. API client (uses EventBus) -->
<script src="js/messages-service.js"></script>    <!-- 4. Messages (listens for api-error) -->

<!-- Surgical overrides load after the base -->
<script src="v0.1.4/js/graph-service-override.js"></script>
<script src="v0.1.5/js/messages-service-override.js"></script>
```

---

## Creating a New Service: Checklist

1. **Wrap in IIFE** — `(function() { 'use strict'; ... })();`
2. **Attach to namespace** — `window.issuesApp.myService = new MyService();`
3. **Add `_fetch()` wrapper** — centralized error handling
4. **Add `_emit()` wrapper** — safe event emission
5. **Emit events** for every state change — callers never poll
6. **Emit `api-error`** on failures — auto-consumed by MessagesService
7. **Optional: add cache** — `Map` with invalidation on mutations
8. **Optional: add subscribe()** — for components that need change notifications beyond events

---

*Services are the nervous system. They talk to the API, emit events, and never know who's listening.*
