# IFD — Event-Driven Architecture Guide

**Purpose**: How to build a fully event-driven UI with zero coupling between components
**Companion to**: `v1.2.1__ifd__intro-and-how-to-use.md` (parent IFD guide)

---

## Core Principle

Components NEVER call each other directly. All communication flows through a centralized **EventBus** singleton. This gives you:

- **Zero coupling** — components can be added, removed, or replaced without touching other code
- **Full observability** — every interaction is a recorded event that can be inspected, filtered, and replayed
- **Testability** — components can be tested in isolation by emitting/listening to events
- **Debuggability** — the Events Viewer shows every event in real-time

---

## The EventBus

### Implementation

The EventBus is a plain JavaScript class — no framework, no library:

```javascript
(function() {
    'use strict';

    const MAX_HISTORY = 1000;

    class EventBus {
        constructor() {
            this._listeners = {};    // eventName -> [callback, ...]
            this._history   = [];    // ordered list of all emitted events
            this._nextId    = 1;     // monotonic event ID
        }

        emit(eventName, detail = {}) {
            const event = {
                id        : this._nextId++,
                name      : eventName,
                detail    : { ...detail },     // clone to prevent mutation
                timestamp : Date.now()
            };

            this._history.push(event);
            if (this._history.length > MAX_HISTORY) {
                this._history.shift();
            }

            const listeners = this._listeners[eventName] || [];
            listeners.forEach(callback => {
                try {
                    callback(event.detail);
                } catch (error) {
                    console.error(`Event handler error for '${eventName}':`, error);
                }
            });

            return event.id;
        }

        on(eventName, callback) {
            if (!this._listeners[eventName]) {
                this._listeners[eventName] = [];
            }
            this._listeners[eventName].push(callback);
        }

        off(eventName, callback) {
            if (!this._listeners[eventName]) return;
            const index = this._listeners[eventName].indexOf(callback);
            if (index !== -1) {
                this._listeners[eventName].splice(index, 1);
            }
        }

        get history() {
            return [...this._history];       // return copy
        }

        replay(eventId) {
            const event = this._history.find(e => e.id === eventId);
            if (!event) return false;

            const listeners = this._listeners[event.name] || [];
            listeners.forEach(cb => {
                try { cb(event.detail); } catch (e) {}
            });
            return true;
        }

        clearHistory()          { this._history = []; }
        listenerCount(name)     { return name ? (this._listeners[name] || []).length : Object.fromEntries(Object.entries(this._listeners).map(([k, v]) => [k, v.length])); }
        getEventNames()         { return Object.keys(this._listeners).filter(n => this._listeners[n].length > 0); }
    }

    window.issuesApp = window.issuesApp || {};
    window.issuesApp.events = new EventBus();
    window.issuesApp.events.emit('event-bus-ready', { version: '0.1.0' });
})();
```

### Key Design Decisions

1. **IIFE pattern** — keeps internal state private, exposes only the singleton
2. **Global namespace** — `window.issuesApp.events` — no imports, no modules, works anywhere
3. **Clone on emit** — `{ ...detail }` prevents consumers from mutating shared state
4. **Error isolation** — one failing listener doesn't break others
5. **Event history** — every event is recorded (up to `MAX_HISTORY`), enabling replay and debugging
6. **Monotonic IDs** — each event gets a unique, incrementing ID

---

## Event Naming Conventions

### Pattern: `noun-verb` (past tense for things that happened)

```
node-created       — a node was just created
node-updated       — a node was just updated
node-deleted       — a node was just deleted
nodes-loaded       — a batch of nodes finished loading
link-created       — a link between nodes was created
navigated          — navigation to a new view completed
```

### Pattern: `noun-verb` (imperative for requests)

```
navigate           — request to navigate to an app   { appId: 'kanban-board' }
navigate-to-node   — request to show a specific node { label: 'Bug-27' }
refresh            — request to reload data
show-graph-viewer  — request to open graph view      { rootLabel: 'Bug-1' }
```

### Pattern: `service-event` (for service lifecycle)

```
event-bus-ready    — event bus initialized
config-loaded      — config loaded from localStorage
config-changed     — a config value was changed
cache-cleared      — service cache was cleared
api-call           — an API call was made (from interceptor)
api-error          — an API call failed
message-added      — a user-facing message was created
```

---

## How Components Use Events

### Emitting Events (Producer Side)

A service or component emits events when something happens:

```javascript
class GraphService {
    async createNode(data) {
        const response = await this._fetch('/nodes/api/nodes', {
            method: 'POST',
            body: JSON.stringify(data)
        });

        if (response.success) {
            this._emit('node-created', { node: response.node });     // tell the world
        }
        return response;
    }

    _emit(event, data) {
        window.issuesApp.events.emit(event, data);
    }
}
```

### Listening to Events (Consumer Side)

A component subscribes to events it cares about:

```javascript
class KanbanBoard extends HTMLElement {
    connectedCallback() {
        this.render();
        this.setupEventListeners();
    }

    setupEventListeners() {
        this._boundHandlers = {
            onNodeCreated : (d) => this.addCardToBoard(d.node),
            onNodeUpdated : (d) => this.updateCard(d.label, d.node),
            onNodeDeleted : (d) => this.removeCard(d.label)
        };

        this.events.on('node-created', this._boundHandlers.onNodeCreated);
        this.events.on('node-updated', this._boundHandlers.onNodeUpdated);
        this.events.on('node-deleted', this._boundHandlers.onNodeDeleted);
    }

    disconnectedCallback() {
        // CRITICAL: always unsubscribe to prevent memory leaks
        this.events.off('node-created', this._boundHandlers.onNodeCreated);
        this.events.off('node-updated', this._boundHandlers.onNodeUpdated);
        this.events.off('node-deleted', this._boundHandlers.onNodeDeleted);
    }

    get events() { return window.issuesApp.events; }
}
```

### Critical Rule: Always Clean Up

Every `on()` must have a matching `off()` in `disconnectedCallback()`. Store bound handlers so you can reference them for removal:

```javascript
// GOOD: stored reference, can be removed
this._boundHandler = this.handleEvent.bind(this);
this.events.on('node-created', this._boundHandler);
// later: this.events.off('node-created', this._boundHandler);

// BAD: anonymous function, cannot be removed (memory leak)
this.events.on('node-created', (d) => this.handleEvent(d));
```

---

## Event Flow Examples

### Example 1: User Creates a Node

```
User clicks "New Issue" button
    → CreateNodeModal dispatches form data
        → GraphService.createNode() calls API
            → API returns success
                → GraphService emits 'node-created' { node }
                    → KanbanBoard.addCardToBoard()     (adds card)
                    → NodeList.refreshList()            (re-fetches list)
                    → EventsViewer shows event          (debug)
                    → MessagesService shows "Node created" (feedback)
```

No component knows about any other component. They all independently react to the same event.

### Example 2: Navigation

```
User clicks "Kanban" in left nav
    → Shell calls navigate('kanban-board')
        → Shell hides current app, shows kanban-board
        → Shell emits 'navigated' { appId: 'kanban-board', previousAppId: 'node-list' }
            → Shell updates URL hash to #/kanban
            → KanbanBoard.onActivate() → loads data
            → Footer updates "Active: Kanban Board"
```

### Example 3: API Error Propagation

```
GraphService._fetch() throws
    → GraphService emits 'api-error' { operation, error }
        → MessagesService auto-creates error message
            → MessagesService emits 'message-added' { autoOpen: true }
                → MessagesPanel auto-opens in sidebar
                → Shell updates error badge count
        → ApiLogger records the failed call (via fetch interceptor)
        → EventsViewer shows 'api-error' event
```

---

## Services as Event Sources

Services are singletons on `window.issuesApp.*` that wrap API calls and emit events:

| Service | Namespace | Purpose |
|---------|-----------|---------|
| `EventBus` | `window.issuesApp.events` | Central event routing |
| `ConfigManager` | `window.issuesApp.config` | Persistent settings (localStorage) |
| `GraphService` | `window.issuesApp.graph` | API client for nodes, links, types |
| `MessagesService` | `window.issuesApp.messages` | User-facing notifications |
| `Router` | `window.issuesApp.router` | App navigation and registration |

Every service follows the same pattern:
1. IIFE wraps the class
2. Instance attached to `window.issuesApp.*`
3. Methods emit events via `window.issuesApp.events.emit()`
4. Other components/services subscribe via `.on()`

---

## How to Add a New Event

1. **Name it** — follow the `noun-verb` convention
2. **Document the payload** — what fields does `detail` contain?
3. **Emit it** — from the service/component where the action happens
4. **Subscribe** — from any component that needs to react
5. **Clean up** — add `off()` in `disconnectedCallback()`

No registration, no schema, no imports. Just `emit()` and `on()`.

---

## Anti-Patterns

### DO NOT call component methods directly

```javascript
// BAD: tight coupling
document.querySelector('kanban-board').refreshBoard();

// GOOD: loose coupling via events
window.issuesApp.events.emit('refresh', {});
```

### DO NOT pass component references in events

```javascript
// BAD: leaks component reference
events.emit('data-ready', { component: this });

// GOOD: pass data, not references
events.emit('data-ready', { nodes: this.nodes, count: this.nodes.length });
```

### DO NOT rely on event ordering between listeners

```javascript
// BAD: assumes listener A runs before listener B
// Each listener should be independent and self-contained
```

---

## Testing Events

Because everything is event-driven, testing is simple:

```javascript
// Setup
const events = new EventBus();

// Test: emit and verify listener was called
let received = null;
events.on('test-event', (detail) => { received = detail; });
events.emit('test-event', { value: 42 });
assert.deepEqual(received, { value: 42 });

// Test: verify event history
const history = events.history;
assert.equal(history[history.length - 1].name, 'test-event');
```

---

*This is the foundation. Every component in the UI talks through events. No exceptions.*
