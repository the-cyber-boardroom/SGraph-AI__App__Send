# IFD â€” Web Components, Shell Architecture & App Registration

**Purpose**: How to structure a Web Components UI with a shell, router, and independent mini-apps
**Companion to**: `v1.2.1__ifd__intro-and-how-to-use.md` (parent IFD guide)

---

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ <issues-shell>  (the application shell â€” custom element)            â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Left Nav â”‚  â”‚       Main Area             â”‚  â”‚  Right Sidebar  â”‚ â”‚
â”‚  â”‚          â”‚  â”‚                              â”‚  â”‚  (Debug Panel)  â”‚ â”‚
â”‚  â”‚ node-listâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚                 â”‚ â”‚
â”‚  â”‚ kanban   â”‚  â”‚  â”‚  <node-list>           â”‚ â”‚  â”‚  Messages  tab  â”‚ â”‚
â”‚  â”‚ detail   â”‚  â”‚  â”‚  <kanban-board>        â”‚ â”‚  â”‚  Events    tab  â”‚ â”‚
â”‚  â”‚ graph    â”‚  â”‚  â”‚  <node-detail>         â”‚ â”‚  â”‚  API Log   tab  â”‚ â”‚
â”‚  â”‚          â”‚  â”‚  â”‚  <graph-viewer>        â”‚ â”‚  â”‚  Automation tab â”‚ â”‚
â”‚  â”‚          â”‚  â”‚  â”‚  (only one visible)    â”‚ â”‚  â”‚                 â”‚ â”‚
â”‚  â”‚          â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Status â”‚ Active: Kanban Board â”‚ Apps: 8 â”‚ [Debug Panel]     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The entire UI is **one custom element** (`<issues-shell>`) that manages:
- **Left nav**: shows main apps, click to navigate
- **Main area**: shows one main app at a time (node-list, kanban, detail, graph)
- **Right sidebar**: shows debug/monitoring apps in tabs (messages, events, API log, automation)
- **Footer**: status bar with debug panel toggle

---

## The Shell: `<issues-shell>`

The shell is the only element placed in `index.html`:

```html
<body>
    <!-- Scripts load services + components first -->
    <script src="js/event-bus.js"></script>
    <script src="js/config-manager.js"></script>
    <script src="js/graph-service.js"></script>
    <script src="components/shell/issues-shell.js"></script>
    <script src="components/node-list/node-list.js"></script>
    <!-- ... more components ... -->

    <!-- Shell element added AFTER all scripts are loaded -->
    <issues-shell></issues-shell>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            requestAnimationFrame(() => {
                // Register apps with the router
                window.issuesApp.router.register(NodeList);
                window.issuesApp.router.register(KanbanBoard);
                window.issuesApp.router.register(NodeDetail);
                // Register sidebar apps
                window.issuesApp.router.register(EventsViewer);
                window.issuesApp.router.register(ApiLogger);
                window.issuesApp.router.register(MessagesPanel);
            });
        });
    </script>
</body>
```

### Shell Responsibilities

1. **Renders the layout** â€” header, left nav, main area, sidebar, footer
2. **Owns the Router** â€” `window.issuesApp.router`
3. **Manages app lifecycle** â€” creates instances, shows/hides, calls `onActivate()`/`onDeactivate()`
4. **Handles navigation** â€” left nav clicks, hash routing, event-driven navigation
5. **Manages the sidebar** â€” open/close, tab switching, resize
6. **Persists preferences** â€” nav width, collapsed state (localStorage)

---

## Component (Mini-App) Contract

Every component that registers with the shell must follow this contract:

```javascript
class MyComponent extends HTMLElement {
    // REQUIRED: Static properties for registration
    static get appId()    { return 'my-component'; }    // must match custom element tag name
    static get navLabel() { return 'My App'; }          // display name in nav
    static get navIcon()  { return 'ğŸ“±'; }              // emoji for nav

    constructor() {
        super();
        this._boundHandlers = {};              // store event handler references
    }

    // REQUIRED: Web Component lifecycle
    connectedCallback() {
        this.render();                         // create DOM
        this.setupEventListeners();            // subscribe to events
    }

    disconnectedCallback() {
        this.cleanup();                        // unsubscribe from events
    }

    // OPTIONAL: Shell lifecycle hooks
    onActivate() {
        // Called when this app becomes visible
        // Good place to refresh data
    }

    onDeactivate() {
        // Called when this app is hidden
        // Good place to pause expensive operations
    }

    // REQUIRED: Render the component's DOM
    render() {
        this.innerHTML = `
            <style>${this.getStyles()}</style>
            <div class="my-component">
                <!-- component HTML -->
            </div>
        `;
    }

    // REQUIRED: Subscribe to events
    setupEventListeners() {
        this._boundHandlers.onRefresh = () => this.loadData();
        this.events.on('refresh', this._boundHandlers.onRefresh);
    }

    // REQUIRED: Unsubscribe from events
    cleanup() {
        this.events.off('refresh', this._boundHandlers.onRefresh);
    }

    // Convention: CSS as a method (self-contained)
    getStyles() {
        return `.my-component { /* styles */ }`;
    }

    // Convention: Access event bus via getter
    get events() { return window.issuesApp.events; }
}

customElements.define('my-component', MyComponent);
```

### Key Points

- **`appId` must match the custom element tag name** â€” the shell uses `document.createElement(appId)` to create instances
- **Self-contained CSS** â€” each component includes its own styles via `<style>` in `render()`
- **No Shadow DOM** â€” we use light DOM so styles can cascade and components remain overridable
- **Bound handlers pattern** â€” store `this.bindMethod.bind(this)` in `_boundHandlers` so you can `off()` them later

---

## The Router

The shell creates the router during `initializeRouter()`. It's exposed as `window.issuesApp.router`:

```javascript
window.issuesApp.router = {
    register(MiniAppClass) { ... },     // register a component class
    navigate(appId) { ... },            // navigate to an app
    openSidebar(tabId) { ... },         // open a sidebar tab
    closeSidebar() { ... },             // close the sidebar
    toggleSidebar() { ... },            // toggle sidebar open/close
    goBack() { ... },                   // go to previous app

    get current() { ... },              // currently active app ID
    get previousApp() { ... },          // previously active app ID
    get apps() { ... }                  // list of all registered apps
};
```

### Registration Flow

When `router.register(MyComponent)` is called:

1. Shell extracts `appId`, `navLabel`, `navIcon` from static properties
2. Checks if it's a sidebar app (listed in `SIDEBAR_APPS` array)
3. Creates an instance: `document.createElement(appId)`
4. Hides it: `instance.style.display = 'none'`
5. Appends to main container (or sidebar container if it's a sidebar app)
6. Stores in `_appInstances` Map
7. Rebuilds left nav
8. Emits `'app-registered'` event
9. If it's the first main app, auto-navigates to it

### Navigation Flow

When `navigate(targetAppId)` is called:

1. Find the target app in `_apps`
2. If it's a sidebar app, call `openSidebarTab()` instead
3. Hide current main app (`style.display = 'none'`, call `onDeactivate()`)
4. Show target app (`style.display = 'block'`, call `onActivate()`)
5. Update `_currentAppId`
6. Update left nav active state
7. Emit `'navigated'` event
8. Update URL hash

### Main Apps vs Sidebar Apps

```javascript
// These go in the main area (one visible at a time)
const NAV_SECTIONS = [
    { id: 'issues', label: 'Issues', icon: 'ğŸ“‹',
      apps: ['node-list', 'kanban-board', 'node-detail', 'graph-viewer'] }
];

// These go in the right sidebar (tabbed)
const SIDEBAR_APPS = ['events-viewer', 'api-logger', 'automation-runner', 'messages-panel'];
```

---

## Hash Routing

The shell supports URL hash routing for deep-linking:

```
#/issues         â†’ navigate to node-list
#/kanban         â†’ navigate to kanban-board
#/issue/Bug-27   â†’ navigate to node-detail, select Bug-27
#/graph/Bug-1    â†’ open graph-viewer for Bug-1
```

This is implemented via `hashchange` event listener + `history.replaceState()`.

---

## The Right Sidebar (Debug Panel)

The sidebar is a **resizable, tabbed panel** on the right side. It contains monitoring/debugging apps:

### Tab Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Msgs] [Events] [API] [Auto]  [Ã—]  â”‚  â† tabs + close button
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚  (one sidebar app visible at a time)â”‚
â”‚                                     â”‚
â”‚  Messages Panel â€” user notificationsâ”‚
â”‚  Events Viewer  â€” all EventBus eventsâ”‚
â”‚  API Logger     â€” all fetch() calls â”‚
â”‚  Automation     â€” test scenarios    â”‚
â”‚                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Opening the Sidebar

Three ways to open:
1. Click "Debug Panel" button in footer
2. Programmatically: `window.issuesApp.router.openSidebar('events-viewer')`
3. Auto-open on errors: MessagesService emits `'message-added'` with `autoOpen: true`

### Sidebar Resize

The sidebar has a drag handle on its left edge. Users can resize from 280px to 800px. Width is persisted to localStorage.

---

## Self-Contained CSS Pattern

Each component bundles its own CSS inside `render()`:

```javascript
render() {
    this.innerHTML = `
        <style>
            .my-component { display: flex; ... }
            .my-component .header { ... }
            .my-component .list { ... }
        </style>
        <div class="my-component">
            <div class="header">...</div>
            <div class="list">...</div>
        </div>
    `;
}
```

### Why Not Shadow DOM?

- Shadow DOM prevents surgical overrides (IFD's core feature)
- Shadow DOM prevents parent CSS cascade (theme colors, global fonts)
- Light DOM lets later versions override styles via CSS specificity
- Components use class-name prefixes to avoid collisions (e.g., `.ev-`, `.al-`, `.mp-`)

### CSS Prefix Convention

Each component uses a short prefix for all its CSS classes:

| Component | Prefix | Example |
|-----------|--------|---------|
| Events Viewer | `ev-` | `.ev-toolbar`, `.ev-list`, `.ev-event` |
| API Logger | `al-` | `.al-toolbar`, `.al-call`, `.al-status-success` |
| Messages Panel | `mp-` | `.mp-container`, `.mp-message`, `.mp-badge` |

---

## Adding a New App: Step-by-Step

### 1. Create the Component File

```javascript
// v0.1.X/components/my-app/my-app.js

class MyApp extends HTMLElement {
    static get appId()    { return 'my-app'; }
    static get navLabel() { return 'My App'; }
    static get navIcon()  { return 'ğŸ¯'; }

    constructor() { super(); this._boundHandlers = {}; }

    connectedCallback() {
        this.render();
        this.setupEventListeners();
    }

    disconnectedCallback() { this.cleanup(); }
    onActivate()           { this.loadData(); }
    onDeactivate()         { }

    render() {
        this.innerHTML = `<div class="my-app"><h2>My App</h2></div>`;
    }

    setupEventListeners() { /* subscribe to events */ }
    cleanup()             { /* unsubscribe from events */ }

    get events() { return window.issuesApp.events; }
}

customElements.define('my-app', MyApp);
```

### 2. Add to `index.html`

```html
<script src="components/my-app/my-app.js"></script>
```

### 3. Register with the Router

```javascript
window.issuesApp.router.register(MyApp);
```

### 4. (If sidebar app) Add to `SIDEBAR_APPS`

```javascript
const SIDEBAR_APPS = ['events-viewer', 'api-logger', 'messages-panel', 'my-app'];
```

### 5. (If main app) Add to `NAV_SECTIONS`

```javascript
const NAV_SECTIONS = [
    { id: 'issues', label: 'Issues', icon: 'ğŸ“‹',
      apps: ['node-list', 'kanban-board', 'node-detail', 'graph-viewer', 'my-app'] }
];
```

That's it. The shell handles everything else â€” creating the instance, showing/hiding, nav integration, lifecycle hooks.

---

## Loading Order

Loading order matters because:
1. EventBus must exist before anything emits events
2. Services must exist before components that use them
3. Shell must exist before components register with the router
4. Components must be defined before the `<issues-shell>` element is added to the DOM

```html
<!-- 1. Core services (order matters) -->
<script src="js/event-bus.js"></script>
<script src="js/config-manager.js"></script>
<script src="js/graph-service.js"></script>
<script src="js/messages-service.js"></script>

<!-- 2. Shell component -->
<script src="components/shell/issues-shell.js"></script>

<!-- 3. App components (order doesn't matter) -->
<script src="components/node-list/node-list.js"></script>
<script src="components/kanban-board/kanban-board.js"></script>
<script src="components/events-viewer/events-viewer.js"></script>
<script src="components/api-logger/api-logger.js"></script>
<script src="components/messages-panel/messages-panel.js"></script>

<!-- 4. Shell element (AFTER all scripts) -->
<issues-shell></issues-shell>

<!-- 5. Registration (AFTER shell exists in DOM) -->
<script>
    document.addEventListener('DOMContentLoaded', () => {
        requestAnimationFrame(() => {
            window.issuesApp.router.register(NodeList);
            window.issuesApp.router.register(KanbanBoard);
            window.issuesApp.router.register(EventsViewer);
            window.issuesApp.router.register(ApiLogger);
            window.issuesApp.router.register(MessagesPanel);
        });
    });
</script>
```

---

*This is how the shell works. One element, many apps, all connected through events.*
