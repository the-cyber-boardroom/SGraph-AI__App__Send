# IFD â€” Debug Panel & Observability (RHS Panel)

**Purpose**: How to build the right-hand-side debug panel with Messages, API Log, and Events Viewer
**Companion to**: `v1.2.1__ifd__intro-and-how-to-use.md` (parent IFD guide)

---

## What the Debug Panel Provides

The right-hand side (RHS) panel gives developers **complete real-time visibility** into the application without opening browser DevTools. It has four tabs:

| Tab | Component | What it Shows |
|-----|-----------|---------------|
| **Messages** | `<messages-panel>` | User-facing notifications (errors, warnings, success, info) |
| **Events** | `<events-viewer>` | Every event flowing through the EventBus |
| **API** | `<api-logger>` | Every HTTP request with request/response bodies |
| **Auto** | `<automation-runner>` | Predefined test scenarios to exercise the UI |

Each tab is a full Web Component that runs in the sidebar. They are registered as sidebar apps and follow the same component contract as main apps.

---

## 1. Messages Panel & Messages Service

### The Problem It Solves

Instead of `alert()` or `console.log()` for user-facing feedback, messages are routed through a proper service with:
- Color-coded severity levels
- Auto-open on errors
- Auto-dismiss for transient messages
- Persistent error display
- Badge count in the footer

### Messages Service (`window.issuesApp.messages`)

```javascript
// Usage anywhere in the application:
window.issuesApp.messages.add('error',   'Failed to save node');        // red, auto-opens panel, persists
window.issuesApp.messages.add('warning', 'Node has no description');    // yellow, auto-opens, auto-dismiss 10s
window.issuesApp.messages.add('success', 'Node created successfully'); // green, no auto-open, auto-dismiss 5s
window.issuesApp.messages.add('info',    'Loading nodes...');          // blue, no auto-open, auto-dismiss 5s
```

### Message Type Configuration

```javascript
const MESSAGE_TYPES = {
    error:   { icon: 'ðŸ”´', color: '#ef4444', autoOpen: true,  autoDismiss: false, dismissDelay: 0     },
    warning: { icon: 'ðŸŸ¡', color: '#f59e0b', autoOpen: true,  autoDismiss: true,  dismissDelay: 10000 },
    success: { icon: 'ðŸŸ¢', color: '#22c55e', autoOpen: false, autoDismiss: true,  dismissDelay: 5000  },
    info:    { icon: 'ðŸ”µ', color: '#3b82f6', autoOpen: false, autoDismiss: true,  dismissDelay: 5000  }
};
```

### How Auto-Open Works

```
User action fails â†’ API returns error
    â†’ GraphService emits 'api-error'
        â†’ MessagesService listens for 'api-error' (auto-wired in init)
            â†’ MessagesService.add('error', 'createNode failed: HTTP 500')
                â†’ MessagesService emits 'message-added' { autoOpen: true }
                    â†’ Shell.updateMessageBadge() â€” badge shows error count
                    â†’ MessagesPanel._boundHandlers.onMessageAdded()
                        â†’ if autoOpen && panel not active
                            â†’ router.openSidebar('messages-panel')
```

The user sees the sidebar slide open with the error message without any component calling another directly.

### MessagesService API

```javascript
const svc = window.issuesApp.messages;

svc.add(type, text, options)    // create a message, returns message object
svc.dismiss(id)                 // mark a message as dismissed
svc.clear()                     // remove all messages
svc.getMessages(filter)         // get messages, optionally filtered { type, dismissed }
svc.getActiveMessages()         // get non-dismissed messages
svc.getActiveCount()            // { error: 2, warning: 0, success: 1, info: 0, total: 3 }
svc.subscribe(callback)         // subscribe to changes, returns unsubscribe function
```

### MessagesPanel Component

The `<messages-panel>` is a sidebar app that renders the messages list:

- Color-coded left border per message type
- Timestamp (relative: "just now", "3m ago", "2h ago")
- Dismiss button per message (Ã—)
- "Clear All" button in header
- Error count badge in header
- Footer with total/active counts
- Empty state: "No messages â€” Errors and notifications will appear here"

---

## 2. Events Viewer

### The Problem It Solves

Since all component communication goes through the EventBus, the Events Viewer gives you a **live stream of every event** in the application. This is the equivalent of a message broker's monitoring dashboard.

### How It Works (Interceptor Pattern)

The Events Viewer uses a clever technique â€” it **wraps** the EventBus's `emit()` method to intercept all events before they're dispatched:

```javascript
setupEventListeners() {
    // Save original emit
    this._originalEmit = this.events.emit.bind(this.events);

    const self = this;

    // Replace emit with interceptor
    this.events.emit = function(name, detail) {
        self.onEventEmitted(name, detail);           // record the event
        return self._originalEmit(name, detail);     // then dispatch normally
    };
}

cleanup() {
    // Restore original emit when component is destroyed
    if (this._originalEmit) {
        this.events.emit = this._originalEmit;
    }
}
```

This means the Events Viewer sees **every event**, including events that have zero listeners. It's a non-invasive observer.

### UI Features

- **Live stream** â€” events appear in real-time, newest first
- **Event ID** â€” monotonic `#1`, `#2`, `#3` for ordering
- **Event name** â€” highlighted in accent color
- **Timestamp** â€” HH:MM:SS format
- **Expandable detail** â€” click to see the full JSON payload
- **Text filter** â€” search across event names and payloads
- **Type filter dropdown** â€” filter by specific event type (auto-populated from seen events)
- **Pause/Resume** â€” freeze the display while keeping events flowing
- **Clear** â€” reset the display
- **Status bar** â€” "42 events" + "Live" / "Paused" indicator

### Why It's Powerful

When debugging, you can:
1. Open Events tab
2. Perform an action in the UI
3. See exactly which events fired, in what order, with what data
4. Filter to a specific event type
5. Expand to see full payloads
6. Pause to freeze a particular state

---

## 3. API Logger

### The Problem It Solves

The API Logger gives you a **network inspector inside the app** â€” every `fetch()` call is captured with full request/response details, timing, and status.

### How It Works (Fetch Interceptor)

Similar to the Events Viewer, the API Logger wraps `window.fetch`:

```javascript
setupFetchInterceptor() {
    this._originalFetch = window.fetch.bind(window);
    const self = this;

    window.fetch = async function(url, options = {}) {
        const callId    = ++self._callId;
        const startTime = Date.now();
        const method    = options.method || 'GET';

        // Create call record (initially pending)
        const call = {
            id: callId, url: url.toString(), method,
            requestBody: options.body,
            status: 'pending', statusCode: null,
            responseBody: null, duration: null
        };

        self.state.calls.unshift(call);
        self.renderCallList();

        try {
            const response = await self._originalFetch(url, options);

            // Clone and read response body
            const cloned = response.clone();
            let body = await cloned.text();
            try { body = JSON.parse(body); } catch(e) {}

            // Update call record
            call.status       = response.ok ? 'success' : 'error';
            call.statusCode   = response.status;
            call.responseBody = body;
            call.duration     = Date.now() - startTime;

            self.renderCallList();

            // Also emit event for cross-component awareness
            window.issuesApp.events.emit('api-call', {
                id: callId, method, url: url.toString(),
                status: response.status, duration: call.duration
            });

            return response;                  // return original response
        } catch (error) {
            call.status   = 'error';
            call.error    = error.message;
            call.duration = Date.now() - startTime;
            self.renderCallList();
            throw error;                     // re-throw so callers still see the error
        }
    };
}

cleanup() {
    // Restore original fetch when component is destroyed
    if (this._originalFetch) {
        window.fetch = this._originalFetch;
    }
}
```

### UI Features

- **Color-coded status** â€” green left border (success), red (error), yellow (pending)
- **HTTP method badge** â€” GET (green), POST (blue), PATCH (purple), DELETE (red)
- **URL path** â€” truncated with ellipsis, full URL in tooltip
- **Status code** â€” `200`, `404`, `500`
- **Duration** â€” `45ms`, `120ms`
- **Expandable detail** â€” click to see:
  - Full URL
  - Request body (pretty-printed JSON)
  - Response body (pretty-printed JSON)
  - Response headers
  - Error message (if failed)
- **Filters** â€” by URL text, HTTP method, status (success/error/pending)
- **Pause/Resume + Clear**

### Why Both API Logger and Events Viewer?

They serve different purposes:

| API Logger | Events Viewer |
|------------|---------------|
| Shows raw HTTP traffic | Shows application-level events |
| Request + response bodies | Event name + detail payload |
| Timing and status codes | Event ordering and flow |
| Debug API integration | Debug component communication |

Together they give you the complete picture: "What did the app ask the server?" + "What did the app do with the response?"

---

## 4. Automation Runner

### The Problem It Solves

Predefined test scenarios that exercise the UI â€” useful for demos, smoke testing, and reproducing workflows.

### How It Works

Scenarios are defined as JSON arrays of steps:

```javascript
const SCENARIOS = [
    {
        id: 'browse-all-issues',
        name: 'Browse All Issues',
        description: 'Open the node list and view all issues',
        steps: [
            { type: 'navigate', target: 'node-list' },
            { type: 'delay', ms: 500 },
            { type: 'event', name: 'issues-list-refresh' }
        ]
    },
    {
        id: 'create-bug-issue',
        name: 'Create Bug Issue',
        steps: [
            { type: 'event', name: 'open-create-modal', detail: { nodeType: 'bug' } },
            { type: 'delay', ms: 300 },
            { type: 'fill', target: '#issue-title', value: 'Test Bug' },
            { type: 'event', name: 'submit-create-form' }
        ]
    }
];
```

Step types: `navigate`, `delay`, `event` (emit), `fill` (form input), `click`.

---

## Implementation Pattern: The Interceptor

The Events Viewer and API Logger both use the **interceptor pattern** â€” they wrap a global function to observe traffic without changing behavior:

```
Original:   caller â†’ function â†’ result
Intercepted: caller â†’ wrapper â†’ [record] â†’ original function â†’ result
```

### Rules for Interceptors

1. **Always save the original** â€” `this._original = originalFn.bind(context)`
2. **Always restore on cleanup** â€” in `disconnectedCallback()`, put the original back
3. **Always return/throw the original result** â€” the interceptor is transparent
4. **Clone data** â€” don't hold references to mutable objects
5. **Handle errors in the interceptor** â€” don't let logging break the app

---

## Putting It All Together

### The Shell's Sidebar Header

```html
<aside class="shell-sidebar" id="shell-sidebar">
    <div class="sidebar-resize-handle" id="sidebar-resize"></div>
    <div class="sidebar-header">
        <button class="sidebar-tab" data-tab="messages-panel">Msgs</button>
        <button class="sidebar-tab" data-tab="events-viewer">Events</button>
        <button class="sidebar-tab" data-tab="api-logger">API</button>
        <button class="sidebar-tab" data-tab="automation-runner">Auto</button>
        <button class="sidebar-close" id="sidebar-close">&times;</button>
    </div>
    <div class="sidebar-content" id="sidebar-content"></div>
</aside>
```

The tabs are just buttons with `data-tab` attributes. Clicking a tab calls `openSidebarTab(tabId)` which:
1. Hides the current sidebar app
2. Shows the selected one
3. Calls `onActivate()` / `onDeactivate()`

### Footer Badge

The footer button shows an error badge:

```html
<button class="sidebar-toggle" id="sidebar-toggle">
    Debug Panel
    <span class="msg-badge hidden" id="msg-badge">0</span>
</button>
```

The badge is updated by `Shell.updateMessageBadge()` which listens to `message-added`, `message-dismissed`, and `messages-cleared` events.

---

## How to Add a New Debug Tab

1. **Create the component** (sidebar app):

```javascript
class MyDebugTool extends HTMLElement {
    static get appId()    { return 'my-debug-tool'; }
    static get navLabel() { return 'Debug'; }
    static get navIcon()  { return 'ðŸ”§'; }

    // ... standard component contract ...
}
customElements.define('my-debug-tool', MyDebugTool);
```

2. **Add to SIDEBAR_APPS**:

```javascript
const SIDEBAR_APPS = ['events-viewer', 'api-logger', 'messages-panel', 'my-debug-tool'];
```

3. **Add tab button to shell render()**:

```html
<button class="sidebar-tab" data-tab="my-debug-tool">Debug</button>
```

4. **Register**:

```javascript
window.issuesApp.router.register(MyDebugTool);
```

---

## Why This Architecture Is Powerful

1. **No DevTools needed** for common debugging â€” messages, events, and API calls are all visible in-app
2. **Non-invasive** â€” interceptors don't change application behavior
3. **Real-time** â€” everything updates live as the user interacts
4. **Filterable** â€” find specific events or API calls instantly
5. **Self-documenting** â€” new developers can open the Events tab and understand the data flow
6. **Portable** â€” these components work in any IFD-based project, not just Issues-FS
7. **Production-safe** â€” sidebar is hidden by default; toggle it when needed

---

*The debug panel is the developer's X-ray vision. Build it early, use it always.*
