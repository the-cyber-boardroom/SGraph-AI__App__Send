# Iterative Flow Development (IFD) - LLM Brief

**Version**: 1.0  
**Purpose**: Quick reference guide for LLMs assisting with IFD-based development

---

## What is IFD?

Iterative Flow Development (IFD) is a methodology for rapid software development using AI assistance while maintaining engineering rigor. It centers on **preserving developer flow state** while leveraging LLMs for code generation.

## Core Principles

### 1. **Flow State Preservation**
- Minimize context switching
- Developer focuses on UX and architecture
- LLM handles boilerplate and repetitive coding
- Work in focused 2-3 hour sessions

### 2. **Dual-Mode Flexibility**

**Vibe Coding Mode** (Rapid Prototyping):
- Non-technical users describe desired functionality
- AI directly creates and modifies code
- Focus purely on "does it work?"
- Perfect for exploration and initial versions

**Air-Gapped Mode** (Professional Development):
- Developer manually reviews all AI suggestions
- Deliberate separation between AI and codebase
- Maintains code ownership and security
- Required for production systems

### 3. **Version Independence (and dependence)**
- The dependencies between versions depend on the type of version it is (Major or Minor)
- Minor versions (v1.3.1, v1.3.2, v1.3.5, i.e. v1.3.x) share as much code as possible (i.e. DON'T copy forward, link back, and overwrite when needed)
- Major versions (v1.1.0, v1.2.0, v2.5.0, v3.0.0, i.e. v1.x.0 or vx.0.0) don't shared code between versions (copy when consolidating/merging)
- Minor Versions in same major version are co-dependent: `v0.2.4` can depend on  `v0.2.2` but not on `v0.1.5` or `v0.3.5` 
- Minor Versions are isolated with previous major and next minor: `v0.2.4` can NOT depend on  `v0.1.2` and NOT depend on `v0.2.5` (but `v0.2.5` can depend on `v0.2.4`)
- Major versions (v1.1.0, v1.2.0, v2.5.0, v3.0.0) consolidate proven previous minor versions
- Release versions (v1.0.0, v4.0.0, i.e. vx.0.0) are exactly like the previous Major version, with no code changes (only version changes and some respective documentation/comments) 

### 4. **UX-First Development**
- Define user experience before writing code
- Describe intended UX to the LLM
- Iterate based on user interaction, not technical perfection

### 5. **Real Data From Day One**
- NO mocked data or stubbed services
- Backend API must exist from v0.1.0
- Test with actual API calls immediately
- Catches integration issues early

### 6. **Progressive Enhancement**
```
v0.1.0 → Core MVP only (minimal functionality)
v0.1.1 → First UI MVP
v0.1.2 → UI Polish
v0.1.3 → Data enhancements
v0.1.4 → Monitoring/logging
v0.1.5+ → Advanced features
v0.2.0  → Consolidation (proven features only)
```

### 7. **Zero External Dependencies**
- Use native web platform (ES6+ JavaScript)
- Web Components (custom elements)
- No frameworks (React/Vue/Angular)
- Browser APIs only (Fetch, DOM, etc.)
- Ensures longevity and simplicity

---

## Development Workflow

### Version Progression

**Minor Versions** (Incremental Development):
- v0.1.1, v0.1.2, v0.1.3... evolve within shared codebase
- Each adds focused features
- Potentially shippable at any point

**Major Versions** (Standalone Releases):
- v1.1.0: Consolidation of last minor version (e.g., v1.0.19)
- NO functional changes during consolidation
- Pure extraction and cleanup
- What stakeholders test (1.4.11) is what gets deployed (v1.5.0)

### When Creating New Features

1. **Start with UX Description**
   ```
   "Create a chat interface with:
   - Resizable textarea
   - Live character count
   - Send on Enter (Shift+Enter for newline)
   - Disabled send button when empty"
   ```

2. **LLM Generates Initial Code**
   - Component structure
   - HTML template
   - Event handlers
   - CSS styling

3. **Human Refines**
   - Review and integrate (air-gapped) OR approve changes (vibe mode)
   - Test with real backend
   - Iterate on UX details
   - Add edge case handling

4. **Progressive Improvement**
   - v0.2.1: Basic functionality
   - v0.2.2: Add input validation
   - v0.2.3: Add error handling
   - v0.2.4: Optimize performance

---

## Technical Architecture

### Web Components Structure

```javascript
class MyComponent extends HTMLElement {
    constructor() {
        super();
        // Initialize state
        this.state = { /* component state */ };
    }
    
    connectedCallback() {
        this.render();
        this.setupEventListeners();
    }
    
    disconnectedCallback() {
        this.cleanup();  // Remove event listeners
    }
    
    render() {
        this.innerHTML = `
            <!-- Component HTML -->
        `;
    }
    
    setupEventListeners() {
        // Attach event handlers
    }
    
    cleanup() {
        // Remove listeners to prevent memory leaks
    }
}

customElements.define('my-component', MyComponent);
```

### Component Communication

**Use Events, Not Direct Calls:**
```javascript
// Component A dispatches
this.dispatchEvent(new CustomEvent('data-changed', {
    detail: { value: newData },
    bubbles: true
}));

// Component B listens
document.addEventListener('data-changed', (e) => {
    console.log('Received:', e.detail.value);
});
```

### File Organization (Per Version)

```
/versions/v0.1.1/
├── index.html              # Entry point
├── components/
│   ├── chat-panel/
│   │   ├── chat-panel.js
│   │   └── chat-panel.css
│   └── user-list/
│       ├── user-list.js
│       └── user-list.css
├── services/
│   └── api-client.js       # API communication
├── utils/
│   └── helpers.js          # Utility functions
└── styles/
    └── main.css            # Global styles
```

---

## Critical Anti-Patterns to AVOID

❌ **Don't** create shared code between Major versions (share between minor)
❌ **Don't** use external JavaScript frameworks/libraries  
❌ **Don't** mock data or stub APIs
❌ **Don't** over-engineer in v0.1.0 (keep it minimal!)
❌ **Don't** add features without proving them first
❌ **Don't** break the air gap in air-gapped mode
❌ **Don't** add business logic to schema files

---

## Production Readiness Checklist

Before v1.0 consolidation, ensure:

**Code Quality:**
- ✅ Consistent error handling throughout
- ✅ Memory management (cleanup in `disconnectedCallback`)
- ✅ No console errors or warnings

**Architecture:**
- ✅ Clear separation of concerns
- ✅ Event-driven component communication  
- ✅ Components are self-contained

**Performance:**
- ✅ Lazy loading for heavy components
- ✅ Debouncing for rapid actions
- ✅ Caching for expensive operations

**Maintainability:**
- ✅ Intuitive file organization
- ✅ Documented component APIs
- ✅ Consistent naming conventions


---

## Key Success Factors

1. **Start Minimal**: v0.1.0 should be embarrassingly simple
2. **Prove Before Consolidate**: Features must work in minor versions before v0.2.0
3. **Test Continuously**: Use real APIs, click through UI constantly
4. **Iterate Quickly**: 15-30 minute cycles, not day-long features
5. **Stay in Flow**: If you're stuck on syntax, ask the LLM
6. **Copy, Don't Share**: Reuse by copying files forward, not importing across versions

---

## Typical Development Session

```
9:00 AM  - Start v0.3.4, define UX goals
9:15 AM  - Prompt LLM for new component
9:30 AM  - Integrate and test component
10:00 AM - Iterate on UI details
10:30 AM - Add API integration
11:00 AM - Test end-to-end with real data
11:30 AM - Commit v0.3.4, plan v0.3.5
```

**Result**: Working, potentially shippable version in 2-3 hours


---

## Remember

**IFD is about maintaining your flow state.** The methodology exists to keep you focused on solving user problems, not fighting with tools or technical debt. Let the AI handle the boilerplate, you handle the creativity and decision-making.

**Version independence means freedom.** Experiment without fear. If v0.4.5 is a dead end, abandon it and build v0.4.6 from v0.4.4. No technical debt accumulates.

**Real data from day one means confidence.** When v1.0 ships, you know it works because you've been testing with real data since v0.1.0.

---

## Quick Reference

| Aspect | IFD Approach                         |
|--------|--------------------------------------|
| **Dependencies** | None (native web only)               |
| **Components** | Web Components (custom elements)     |
| **Communication** | CustomEvents (event-driven)          |
| **State** | Component-local + event coordination |
| **Versions** | Independent, no shared code          |
| **API** | Real from v0.1.0, no mocks           |
| **Testing** | Manual + real data continuously      |
| **AI Role** | Code generation + refinement         |
| **Human Role** | Architecture + UX + decisions        |

---

## Example: Complete Minimal Component

```javascript
// /versions/v0.1.2/components/simple-counter/simple-counter.js

class SimpleCounter extends HTMLElement {
    constructor() {
        super();
        this.count = 0;
    }
    
    connectedCallback() {
        this.render();
        this.querySelector('button').addEventListener('click', () => this.increment());
    }
    
    render() {
        this.innerHTML = `
            <div class="counter">
                <p>Count: <span class="count">${this.count}</span></p>
                <button>Increment</button>
            </div>
            <style>
                .counter { padding: 1rem; border: 1px solid #ccc; }
                button { padding: 0.5rem 1rem; }
            </style>
        `;
    }
    
    increment() {
        this.count++;
        this.querySelector('.count').textContent = this.count;
        
        // Notify others of state change
        this.dispatchEvent(new CustomEvent('count-changed', {
            detail: { count: this.count },
            bubbles: true
        }));
    }
}

customElements.define('simple-counter', SimpleCounter);
```

Usage:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Counter App v0.1.2</title>
    <script src="components/simple-counter/simple-counter.js"></script>
</head>
<body>
    <simple-counter></simple-counter>
</body>
</html>
```

---

**This is IFD.** Simple, fast, maintainable, and built for flow.