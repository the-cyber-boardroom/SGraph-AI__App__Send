# Python Formatting & Coding Style Guide for LLMs

- **version**: v3.63.4
- **updated**: January 2026
- **related**: Type_Safe Capabilities Guide (v3_64_2__for_llms__type_safe__capabilities_guide.md)

---

## Overview

This guide defines a specialized Python formatting style that prioritizes visual pattern recognition and information density over PEP-8 conventions. It uses vertical alignment to create visual lanes that make code structure immediately apparent, groups related information to maintain context, and optimizes for real-world debugging and code review scenarios.

**Core principles:**
- Code is read far more often than written
- Human pattern recognition works best with consistent structure
- Visual alignment reveals relationships and bugs
- Information density reduces cognitive load

---

## File Structure

### File Header Comment

Every file should have a descriptive header comment **before imports**, using the `═══` style:

```python
# ═══════════════════════════════════════════════════════════════════════════════
# MGraph HTML Graph - Common Graph Schemas for Native Export Formats
# Shared data structures for vis.js, D3, Cytoscape, and Mermaid exports
# ═══════════════════════════════════════════════════════════════════════════════

from typing                                      import Dict, List
from osbot_utils.type_safe.Type_Safe            import Type_Safe
# ... more imports
```

**Rules:**
- Use exactly 80 `═` characters for the border
- Title on first line after border
- Optional subtitle/description on second line
- Closing border
- Blank line before imports

### Section Dividers

Use section dividers to organize logical groups of methods or classes:

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Graph Building Methods
# ═══════════════════════════════════════════════════════════════════════════════

def build_node(self, data: dict) -> Schema__Node:
    pass

def build_edge(self, source: Node_Id, target: Node_Id) -> Schema__Edge:
    pass

# ═══════════════════════════════════════════════════════════════════════════════
# Export Methods - Format-Specific Serialization
# ═══════════════════════════════════════════════════════════════════════════════

def export_to_json(self) -> str:
    pass

def export_to_cytoscape(self) -> dict:
    pass
```

**Format:** `# {Title}` or `# {Title} - {Subtitle}`

---

## Import Formatting

### Aligned Imports

Align imports with the longest import path (no matter how long each import is):

```python
from unittest                                                               import TestCase
from mgraph_ai.schemas.Schema__MGraph__Node                                 import Schema__MGraph__Node
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id           import Safe_Id
from osbot_utils.type_safe.Type_Safe                                        import Type_Safe
```

**Rules:**
- One import per line
- Align `import` keyword at consistent column (typically 80-85)
- Group by: standard library, third-party, local modules
- No blank lines within groups, one blank line between groups

---

## Documentation Style

### NEVER Use Docstrings

**CRITICAL**: In Type_Safe code, NEVER use Python docstrings. All documentation must be inline comments aligned at the end of lines.

```python
# ✗ WRONG - Docstrings break visual patterns
class Persona__Service(Type_Safe):
    """Core service for persona-based translation and impersonation"""
    
    prompt_builder : Persona__Prompt_Builder
    persona_manager: Persona__Manager
    
    def setup(self) -> 'Persona__Service':
        """Initialize the service with configuration"""
        pass

# ✓ CORRECT - Inline comments with alignment
class Persona__Service(Type_Safe):                              # Core service for persona translation
    prompt_builder  : Persona__Prompt_Builder                   # Builds prompts for LLM interactions
    persona_manager : Persona__Manager                          # Manages available personas
    
    def setup(self) -> 'Persona__Service':                      # Initialize the service
        self.prompt_builder  = Persona__Prompt_Builder()
        self.persona_manager = Persona__Manager()
        return self
```

### Inline Comment Alignment

Align comments at a consistent column (typically 70-80):

```python
class Schema__Config(Type_Safe):
    host        : Safe_Str__Host                                # Server hostname
    port        : Safe_UInt__Port                               # Server port number
    ssl_enabled : bool = True                                   # Enable SSL/TLS
    timeout     : Safe_UInt = 30                                # Connection timeout in seconds
    max_retries : Safe_UInt = 3                                 # Maximum retry attempts
```

---

## Method Signatures

### Multi-Parameter Methods

When methods have multiple parameters with types, use vertical alignment:

```python
def method_name(self                        ,                                       # Method purpose comment
                first_param  : Type1        ,                                       # With params descriptions
                second_param : Type2        ,                                       # Comments aligned at column 85
                third_param  : Type3 = None                                         # Default values align
           ) -> ReturnType:                                                         # Return on new line (with return type aligned with last variable name)
```

**Critical alignment rules:**
1. Parameters stack vertically with opening parenthesis
2. **First letter of return type aligns with first letter of parameter names**
3. Vertical alignment on `:`, `,`, and `#`
4. Return type format: `) -> ReturnType:` positioned to achieve alignment
5. self: is used to descibe the method's objective/purpose

### Alignment Example

```python
def process_data(self                                          ,                    # Process and validate data            
                 input_data   : Dict[Node_Id, Safe_Str__Text]  ,                    # Raw input data
                 validator    : Schema__Validator              ,                    # Validation schema
                 timeout      : Safe_Int__Positive = 30                             # Timeout in seconds
            ) -> Schema__Result:                                                    # Processed result
#                ^-- 'S' in Schema__Result aligns with 'i' in input_data
```

### Single Parameter Methods

Skip complex formatting for simple signatures:

```python
def get_name(self) -> Safe_Str__Username:
    return self.name

def set_value(self, value: Save_UInt) -> None:
    self.value = value
```

### No Line Break Before First Parameter

**CRITICAL**: Never put a line break before the first parameter in method calls or definitions:

```python
# ✗ WRONG - Line break before first parameter
relationship = Schema__Ontology__Relationship(
    inverse = Safe_Str__Ontology__Verb(rel_data.get('inverse', '')),
    targets = targets,
)

# ✓ CORRECT - First parameter on same line, subsequent aligned
relationship = Schema__Ontology__Relationship(inverse = verb_value,
                                              targets = targets   )
```

---

## Variable Assignment & Assertions

### Aligned Equals Signs

Align equals signs for related assignments:

```python
self.node_id    = Random_Guid()
self.value_type = str
self.created_at = Timestamp_Now()

config.host     = "localhost"
config.port     = 8080
config.timeout  = 30
```

### Aligned Comparison Operators

Align operators in assertion blocks:

```python
assert type(self.node)       is Schema__MGraph__Node
assert self.node.value       == "test_value"
assert len(self.attributes)  == 1
assert self.node.parent      is None
```

### Aligned Boolean Checks

```python
if file_exists(path) is False:
    return None
if data            is None:
    return None
if len(items)      == 0:
    return None
```

---

## Constructor Calls

### Multi-Parameter Constructors

Align parameters with the first parameter:

```python
node_config = Schema__MGraph__Node__Config(node_id    = Random_Guid(),
                                           value_type = str          ,
                                           label      = "test_node"  )

ontology = Schema__Ontology(ontology_id = Ontology_Id("core-types"),
                            version     = "1.0.0"                  ,
                            description = "Core type definitions"  )
```

**Rules:**
- First parameter on same line as constructor
- Subsequent parameters aligned with first
- Closing parenthesis on last parameter line (or aligned below)
- Align `=` signs within the call

### Nested Constructor Calls

```python
container = Schema__Container(config = Schema__Config(host = "localhost",
                                                      port = 8080       ),
                              data   = Schema__Data(items = []          ))
```

---

## Method Naming

### No Underscores for Private Methods

**CRITICAL**: Do not use leading underscores for helper/private methods:

```python
# ✗ WRONG - Underscore prefix
class Parser(Type_Safe):
    def parse(self, data: dict) -> Schema__Result:
        return self._parse_nodes(data)
    
    def _parse_nodes(self, data: dict) -> List[Schema__Node]:
        pass

# ✓ CORRECT - No underscore prefix
class Parser(Type_Safe):
    def parse(self, data: dict) -> Schema__Result:
        return self.parse_nodes(data)
    
    def parse_nodes(self, data: dict) -> List[Schema__Node]:
        pass
```

**Rationale**: In Type_Safe classes, all methods are part of the public interface. The underscore convention adds visual noise without providing meaningful encapsulation.

---

## Class Definitions

### Schema Classes

Schema classes are pure data containers - no methods:

```python
class Schema__User(Type_Safe):                                  # User account data
    user_id    : User_Id                                        # Unique identifier
    username   : Safe_Str__Username                             # Login username
    email      : Safe_Str__Email                                # Contact email
    created_at : Timestamp_Now                                  # Account creation time
    settings   : Schema__User_Settings                          # User preferences
```

### Collection Subclasses

Collection subclasses are pure type definitions - no methods:

```python
class Dict__Users__By_Id(Type_Safe__Dict):                      # Maps user IDs to user data
    expected_key_type   = User_Id
    expected_value_type = Schema__User

class List__User_Ids(Type_Safe__List):                          # List of user identifiers
    expected_type = User_Id
```

### Service/Helper Classes

Service classes contain the business logic:

```python
class User__Service(Type_Safe):                                 # User management service
    cache: Dict__Users__By_Id                                   # In-memory user cache
    
    @type_safe
    def get(self, user_id: User_Id) -> Schema__User:            # Retrieve user by ID
        return self.cache.get(user_id)
    
    @type_safe
    def create(self, username : Safe_Str__Username,             # Create new user account
                     email    : Safe_Str__Email   ) -> Schema__User:
        user = Schema__User(username = username,
                            email    = email   )
        self.cache[user.user_id] = user
        return user
```

---

## Type Annotations

### Class Attribute Annotations

Align colons for class attributes:

```python
class Schema__Config(Type_Safe):
    host        : Safe_Str__Host
    port        : Safe_UInt__Port
    ssl_enabled : bool
    timeout     : Safe_UInt
    endpoints   : List[Safe_Str__Url]
```

### Default Values

Align default values with annotations:

```python
class Schema__Config(Type_Safe):
    host        : Safe_Str__Host       = "localhost"
    port        : Safe_UInt__Port      = 8080
    ssl_enabled : bool                 = True
    timeout     : Safe_UInt            = 30
    max_retries : Safe_UInt            = 3
```

### Complex Type Annotations

For long type annotations, keep on one line if possible:

```python
class Schema__Graph(Type_Safe):
    nodes         : Dict__Nodes__By_Id
    edges         : Dict__Edges__By_Id
    node_index    : Dict[Node_Type_Id, List__Node_Ids]
    metadata      : Dict[Safe_Str__Key, Safe_Str__Text]
```

---

## Control Flow

### If Statements

Align conditions when checking multiple related values:

```python
if file_exists(path) is False:
    return None
if data              is None:
    return None
if len(data)         == 0:
    return None
```

### Guard Clauses

Use early returns for validation:

```python
def process(self, data: dict) -> Schema__Result:
    if data is None:
        return None
    if 'required_field' not in data:
        return None
    
    # Main processing logic
    return self.parse(data)
```

### Boolean Comparisons

Use explicit `is True` / `is False` for clarity:

```python
# ✓ CORRECT - Explicit boolean check
if file_exists(path) is False:
    return None

# ✗ AVOID - Implicit boolean
if not file_exists(path):
    return None
```

---

## Dictionary Operations

### Dict Comprehensions

Align for readability:

```python
result = {key: self.transform(value)
          for key, value in data.items()
          if value is not None}
```

### Multi-Line Dict Literals

```python
config = {'host'   : 'localhost',
          'port'   : 8080       ,
          'timeout': 30         }
```

---

## List Operations

### List Comprehensions

Keep simple comprehensions on one line:

```python
ids = [item.id for item in items]
names = [user.name for user in users if user.active]
```

### Multi-Line List Literals

```python
endpoints = ['https://api.example.com/v1',
             'https://api.example.com/v2',
             'https://backup.example.com' ]
```

---

## Test Code Formatting

### Test Method Structure

```python
def test_user_creation(self):
    # Setup
    service = User__Service()
    username = Safe_Str__Username("testuser")
    email    = Safe_Str__Email("test@example.com")
    
    # Execute
    user = service.create(username=username, email=email)
    
    # Verify
    assert type(user)          is Schema__User
    assert user.username       == username
    assert user.email          == email
    assert type(user.user_id)  is User_Id
```

### Aligned Assertions

```python
assert type(result)           is Schema__Result
assert result.status          == "success"
assert len(result.items)      == 3
assert result.metadata        is not None
assert result.error           is None
```

---

## Common Patterns

### Pattern: Registry/Service Class

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Ontology Registry - Central registry for ontology definitions
# ═══════════════════════════════════════════════════════════════════════════════

class Ontology__Registry(Type_Safe):                            # Central ontology registry
    cache: Dict__Ontologies__By_Id                              # In-memory cache
    
    @type_safe
    def get(self, ontology_id: Ontology_Id) -> Schema__Ontology:
        return self.cache.get(ontology_id)
    
    @type_safe
    def register(self, ontology: Schema__Ontology) -> Schema__Ontology:
        self.cache[ontology.ontology_id] = ontology
        return ontology
    
    @type_safe
    def exists(self, ontology_id: Ontology_Id) -> bool:
        return ontology_id in self.cache
```

### Pattern: Parser Class

```python
# ═══════════════════════════════════════════════════════════════════════════════
# Ontology Parser - Parses ontology definitions from JSON
# ═══════════════════════════════════════════════════════════════════════════════

class Ontology__Parser(Type_Safe):                              # JSON to Schema parser
    
    @type_safe
    def parse(self, data: dict) -> Schema__Ontology:            # Parse ontology from dict
        if data is None:
            return None
        
        node_types = self.parse_node_types(data.get('node_types', {}))
        
        return Schema__Ontology(ontology_id = Ontology_Id(data.get('ontology_id', '')),
                                version     = data.get('version', '1.0.0')            ,
                                node_types  = node_types                              )
    
    @type_safe
    def parse_node_types(self, data: dict) -> Dict__Node_Types__By_Id:
        node_types = Dict__Node_Types__By_Id()                  # Direct instantiation
        
        for type_id, type_data in data.items():
            node_type = self.parse_node_type(type_id, type_data)
            if node_type:
                node_types[node_type.node_type_id] = node_type
        
        return node_types
```

### Pattern: File Operations

```python
@type_safe
def load_from_file(self, file_path: Safe_Str__File__Path) -> Schema__Config:
    if file_exists(file_path) is False:
        return None
    
    data = json_load_file(file_path)
    if not data:
        return None
    
    return self.parse(data)

@type_safe
def save_to_file(self, config   : Schema__Config       ,
                       file_path: Safe_Str__File__Path ) -> bool:
    data = config.json()
    json_save_file(data, file_path)
    return True
```

---

## Anti-Patterns to Avoid

### Avoid: Docstrings

```python
# ✗ WRONG
def process(self, data: dict) -> Result:
    """Process the input data and return result."""
    pass

# ✓ CORRECT
def process(self, data: dict) -> Result:                        # Process input data
    pass
```

### Avoid: Underscore Private Methods

```python
# ✗ WRONG
def _helper_method(self):
    pass

# ✓ CORRECT
def helper_method(self):
    pass
```

### Avoid: Line Break Before First Parameter

```python
# ✗ WRONG
result = SomeClass(
    param1=value1,
    param2=value2
)

# ✓ CORRECT
result = SomeClass(param1 = value1,
                   param2 = value2)
```

### Avoid: Methods in Schemas

```python
# ✗ WRONG
class Schema__User(Type_Safe):
    name: str
    
    def validate(self):                                          # NO!
        pass

# ✓ CORRECT
class Schema__User(Type_Safe):
    name: str
```

### Avoid: Implicit Boolean Checks

```python
# ✗ WRONG
if not data:
    return None

# ✓ CORRECT
if data is None:
    return None
```

---

## Summary Checklist

When formatting Python code:

- [ ] File header with `═══` borders before imports
- [ ] Section dividers for logical method groups
- [ ] Aligned imports at consistent column
- [ ] NO docstrings - use inline comments
- [ ] Inline comments aligned at column 70-80
- [ ] Multi-parameter methods with vertical alignment
- [ ] Return type's first letter aligns with parameter names
- [ ] No line break before first parameter in calls
- [ ] No underscore prefix on helper methods
- [ ] Aligned `=` signs in related assignments
- [ ] Aligned comparison operators in assertions
- [ ] Explicit `is True` / `is False` for booleans
- [ ] Schemas are pure data - no methods
- [ ] Collection subclasses are pure type definitions - no methods
- [ ] Guard clauses with early returns
- [ ] Test methods: Setup, Execute, Verify structure
