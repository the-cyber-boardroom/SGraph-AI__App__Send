# LLM Brief: Cache Service Integration Testing

## Overview

This document provides guidance for writing integration tests that verify a service's interaction with the Cache Service. The pattern described here allows testing the full client-server communication stack in under 500ms, making it suitable for regular test runs rather than isolated integration test suites.

**Key Value**: These tests make it easy to spot and debug any issues related to the use of the Cache Service (via the `Cache__Service__Fast_API__Client`) in a particular service. When something breaks in cache communication, these tests pinpoint exactly where.

---

## Architecture Context

### The Cache Service Client Pattern

Services that need caching use `Cache__Service__Fast_API__Client` which supports two modes:

1. **IN_MEMORY mode**: Uses a FastAPI test client directly (for unit tests)
2. **REMOTE mode**: Makes real HTTP calls to a cache service URL (for integration/production)

The client uses **lazy configuration** - it reads environment variables on first request, not at initialization. This allows the same codebase to work in multiple contexts without code changes.

### Environment Variables

```bash
URL__TARGET_SERVER__CACHE_SERVICE          # Base URL (e.g., http://0.0.0.0:10017)
AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_NAME   # API key header name (if auth required)
AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE  # API key value (if auth required)
```

---

## Case Study: Graph Service Integration Test

### What Gets Tested in ~385ms

This single test file validates:

1. **Full Cache Service Stack** - Complete `Cache_Service__Fast_API` on ephemeral server
2. **Full Graph Service Stack** - `Graph_Service__Fast_API` with routes, areas, services
3. **Client-Server HTTP Communication** - Real HTTP calls Graph Service → Cache Service
4. **Dependency Chain** - Entire object graph initialization and wiring
5. **Lazy Configuration** - Environment variables picked up on first request
6. **Data Round-Trip** - Create → Store → Retrieve via client → Retrieve directly
7. **Schema Validation** - Response objects deserialize correctly
8. **Data Integrity** - Stored data matches expected structure

### Test Structure

```python
from unittest                                           import TestCase
from osbot_fast_api.utils.Fast_API_Server              import Fast_API_Server
from osbot_utils.helpers.Temp_Env_Vars                 import Temp_Env_Vars
from osbot_utils.testing.Stdout                        import Stdout
from mgraph_ai_service_graph.fast_api.Graph_Service__Fast_API import Graph_Service__Fast_API
from cache_service.fast_api.Cache_Service__Fast_API    import Cache_Service__Fast_API


class test_Graph_Service__Fast_API__local_cache_server(TestCase):

    @classmethod
    def setUpClass(cls):                                                    # Expensive setup - runs once
        cls.cache_service      = Cache_Service__Fast_API()                  # Create cache service instance
        cls.cache_service__app = cls.cache_service.setup()                  # Get FastAPI app
        cls.fast_api_server    = Fast_API_Server(app=cls.cache_service__app)# Wrap in ephemeral server
        cls.cache_server_url   = cls.fast_api_server.url()                  # Get dynamic URL (random port)
        cls.fast_api_server.start()                                         # Start server in background thread
        
        cls.graph_service      = Graph_Service__Fast_API()                  # Service under test
        cls.graph_service.setup()
        
        cls.env_vars__cache_client = {                                      # Environment config for tests
            'URL__TARGET_SERVER__CACHE_SERVICE'          : cls.cache_server_url,
            'AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_NAME' : '',            # No auth for local testing
            'AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE': ''
        }

    @classmethod
    def tearDownClass(cls):                                                 # Cleanup after all tests
        cls.fast_api_server.stop()

    def test__config__before_env_vars(self):                               # Verify initial state
        graph_service   = self.graph_service
        graph_crud      = graph_service.routes__graph__crud
        graph_service_  = graph_crud.area_graph_crud.graph_service
        graph_cache_client = graph_service_.graph_cache_client
        
        # Before any request, config shows defaults (lazy loading not triggered)
        assert graph_cache_client.cache_client.config.obj() == __(
            base_url       = None,
            api_key_header = None,
            api_key        = None,
            mode           = 'in_memory',
            fast_api_app   = __SKIP__                                       # Skip dynamic value
        )

    def test__graph_create__with_cache_server(self):                       # Main integration test
        with Temp_Env_Vars(env_vars=self.env_vars__cache_client):          # Set env vars for this block only
            graph_service      = self.graph_service
            graph_crud         = graph_service.routes__graph__crud
            graph_service_     = graph_crud.area_graph_crud.graph_service
            graph_cache_client = graph_service_.graph_cache_client
            
            # Make actual request - this triggers lazy config loading
            response = graph_crud.create()
            
            # Verify config updated to remote mode
            assert graph_cache_client.cache_client.config.obj() == __(
                base_url       = self.cache_server_url,
                api_key_header = '',
                api_key        = '',
                mode           = 'remote',                                  # Now in remote mode!
                fast_api_app   = None
            )
            
            # Verify response structure
            assert type(response)   is Schema__Graph__Create__Response
            assert response.status  == 'success'
            graph_id = response.graph_id
            
            # Verify data retrievable via cache client
            cache_response = graph_cache_client.retrieve(graph_id)
            assert cache_response is not None
            
            # Verify data retrievable directly from cache service
            direct_response = self.cache_service.routes_cache.retrieve(graph_id)
            assert type(direct_response) is Schema__Cache__Retrieve__Success
            assert direct_response.data is not None
```

---

## Key Techniques

### 1. Fast_API_Server with Ephemeral Port

```python
cls.fast_api_server = Fast_API_Server(app=cls.cache_service__app)
cls.cache_server_url = cls.fast_api_server.url()  # Gets http://127.0.0.1:{random_port}
cls.fast_api_server.start()
```

**Benefits**:
- No port conflicts between parallel test runs
- No external dependencies or Docker required
- Server runs in background thread
- Fully isolated per test class

### 2. Temp_Env_Vars Context Manager

```python
with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
    # Environment is configured only within this block
    response = graph_crud.create()
# Automatically restored after block exits
```

**Benefits**:
- Tests don't pollute each other
- No global state leakage
- Can test different configurations in same test class
- Automatic cleanup even on test failure

### 3. setUpClass for Expensive Operations

```python
@classmethod
def setUpClass(cls):
    # Server startup (~300ms) happens once
    cls.fast_api_server.start()
    
# Individual tests reuse the server
def test__first(self):   # ~40ms
def test__second(self):  # ~40ms
```

**Benefits**:
- Server startup cost amortized across all tests
- Individual tests run in milliseconds
- Still isolated because each test uses fresh data

### 4. Type-Safe Assertions with obj() and __()

```python
from osbot_utils.testing.Temp_Assert import __

assert config.obj() == __(
    base_url       = self.cache_server_url,
    api_key_header = '',
    mode           = 'remote',
    dynamic_field  = __SKIP__  # Skip fields that change each run
)
```

**Benefits**:
- Complete state verification in one assertion
- Clear diff output on failure
- `__SKIP__` handles dynamic values (timestamps, IDs, etc.)
- Works with any Type_Safe object

### 5. Multiple Verification Angles

```python
# Angle 1: Via service response
response = graph_crud.create()
assert response.status == 'success'

# Angle 2: Via cache client
cache_response = graph_cache_client.retrieve(graph_id)
assert cache_response is not None

# Angle 3: Via cache service directly
direct_response = self.cache_service.routes_cache.retrieve(graph_id)
assert direct_response.data is not None
```

**Benefits**:
- Catches bugs where one layer lies about success
- Validates data actually persisted
- Tests both client and server perspectives

---

## Template for New Services

When adding Cache Service integration to a new service (e.g., `My_Service__Fast_API`), create this test structure:

```python
from unittest                                           import TestCase
from osbot_fast_api.utils.Fast_API_Server              import Fast_API_Server
from osbot_utils.helpers.Temp_Env_Vars                 import Temp_Env_Vars
from osbot_utils.testing.Temp_Assert                   import __, __SKIP__
from cache_service.fast_api.Cache_Service__Fast_API   import Cache_Service__Fast_API
from my_service.fast_api.My_Service__Fast_API         import My_Service__Fast_API


class test_My_Service__Fast_API__local_cache_server(TestCase):
    """Integration tests for My_Service cache client communication."""

    @classmethod
    def setUpClass(cls):
        # 1. Start cache service on ephemeral server
        cls.cache_service      = Cache_Service__Fast_API()
        cls.cache_service__app = cls.cache_service.setup()
        cls.fast_api_server    = Fast_API_Server(app=cls.cache_service__app)
        cls.cache_server_url   = cls.fast_api_server.url()
        cls.fast_api_server.start()
        
        # 2. Initialize service under test
        cls.my_service = My_Service__Fast_API()
        cls.my_service.setup()
        
        # 3. Prepare environment variables
        cls.env_vars__cache_client = {
            'URL__TARGET_SERVER__CACHE_SERVICE'           : cls.cache_server_url,
            'AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_NAME': '',
            'AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE': ''
        }

    @classmethod
    def tearDownClass(cls):
        cls.fast_api_server.stop()

    # ===== CONFIGURATION TESTS =====
    
    def test__cache_client__config__initial_state(self):
        """Verify cache client starts in in_memory mode before env vars loaded."""
        cache_client = self._get_cache_client()
        assert cache_client.config.mode == 'in_memory'
        assert cache_client.config.base_url is None

    def test__cache_client__config__after_first_request(self):
        """Verify lazy configuration loads env vars on first request."""
        with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
            cache_client = self._get_cache_client()
            
            # Trigger a request
            self._make_request_that_uses_cache()
            
            # Config should now be in remote mode
            assert cache_client.config.obj() == __(
                base_url       = self.cache_server_url,
                api_key_header = '',
                api_key        = '',
                mode           = 'remote',
                fast_api_app   = None
            )

    # ===== DATA FLOW TESTS =====
    
    def test__create__stores_in_cache(self):
        """Verify create operation stores data in cache service."""
        with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
            # Create via service
            response = self._create_resource()
            assert response.status == 'success'
            resource_id = response.resource_id
            
            # Verify via cache client
            cached = self._get_cache_client().retrieve(resource_id)
            assert cached is not None
            
            # Verify via cache service directly
            direct = self.cache_service.routes_cache.retrieve(resource_id)
            assert direct.data is not None

    def test__update__updates_cache(self):
        """Verify update operation updates cached data."""
        with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
            # Create resource
            create_response = self._create_resource()
            resource_id = create_response.resource_id
            
            # Update resource
            update_response = self._update_resource(resource_id)
            assert update_response.status == 'success'
            
            # Verify cache contains updated data
            cached = self._get_cache_client().retrieve(resource_id)
            assert cached['updated_field'] == 'new_value'

    def test__delete__removes_from_cache(self):
        """Verify delete operation removes data from cache."""
        with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
            # Create resource
            create_response = self._create_resource()
            resource_id = create_response.resource_id
            
            # Delete resource
            delete_response = self._delete_resource(resource_id)
            assert delete_response.status == 'success'
            
            # Verify cache no longer contains data
            cached = self._get_cache_client().retrieve(resource_id)
            assert cached is None

    # ===== HELPER METHODS =====
    
    def _get_cache_client(self):
        """Navigate dependency chain to get cache client."""
        # Adjust path based on your service structure
        return self.my_service.routes.area.service.cache_client
    
    def _make_request_that_uses_cache(self):
        """Make any request that triggers cache client usage."""
        return self.my_service.routes.list()
    
    def _create_resource(self):
        """Create a resource through the service."""
        return self.my_service.routes.create()
    
    def _update_resource(self, resource_id):
        """Update a resource through the service."""
        return self.my_service.routes.update(resource_id, data={'updated_field': 'new_value'})
    
    def _delete_resource(self, resource_id):
        """Delete a resource through the service."""
        return self.my_service.routes.delete(resource_id)
```

---

## Debugging Guide

### Common Issues and Solutions

#### 1. "fast_api_app must be configured" Error

**Symptom**: 
```
ValueError: in Cache__Service__Fast_API__Client__Requests.test_client 
the target self.config.fast_api_app must be configured
```

**Cause**: Cache client is in `in_memory` mode but no FastAPI app was provided.

**Solution**: Set environment variables before the request:
```python
with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
    response = service.make_request()
```

#### 2. Config Shows `mode='in_memory'` After Setting Env Vars

**Cause**: Lazy loading - config only reads env vars on first request.

**Solution**: Make a request first, then check config:
```python
with Temp_Env_Vars(env_vars=self.env_vars__cache_client):
    service.make_any_request()  # Triggers lazy load
    assert cache_client.config.mode == 'remote'  # Now correct
```

#### 3. Connection Refused Errors

**Cause**: Cache server not started or wrong URL.

**Debug**:
```python
print(f"Cache server URL: {self.cache_server_url}")
print(f"Server running: {self.fast_api_server.is_running()}")
```

#### 4. Data Not Found in Cache Service

**Cause**: Data stored under different key, or cache_id not propagated.

**Debug**: Check both perspectives:
```python
# Via cache client
cached = cache_client.retrieve(resource_id)
print(f"Via client: {cached}")

# Via cache service directly
direct = self.cache_service.routes_cache.retrieve(resource_id)
print(f"Via service: {direct}")
```

#### 5. Test Pollution Between Test Methods

**Cause**: Tests sharing state, or env vars not cleaned up.

**Solution**: Always use `Temp_Env_Vars` context manager, create fresh data per test.

---

## Checklist for New Service Integration

- [ ] Create test file: `test_{Service}__Fast_API__local_cache_server.py`
- [ ] Implement `setUpClass` with cache server and service setup
- [ ] Implement `tearDownClass` with server stop
- [ ] Define `env_vars__cache_client` dictionary
- [ ] Add helper method to navigate to cache client
- [ ] Test initial config state (in_memory mode, no URL)
- [ ] Test config after first request (remote mode, correct URL)
- [ ] Test create → cache store → retrieve flow
- [ ] Test update → cache update flow (if applicable)
- [ ] Test delete → cache removal flow (if applicable)
- [ ] Verify from multiple angles (client response, cache client, cache service direct)
- [ ] Run tests and verify total time < 1 second

---

## Why This Pattern Matters

### Traditional Integration Testing Problems

1. **Docker dependency** - Requires containers, slow startup
2. **Port conflicts** - Fixed ports cause CI failures
3. **Flaky tests** - Network timing issues
4. **Slow execution** - Minutes per test suite
5. **Isolated from unit tests** - Developers skip them

### This Pattern's Solutions

1. **No Docker** - In-process FastAPI server
2. **Ephemeral ports** - No conflicts, parallel-safe
3. **Deterministic** - Same process, controlled timing
4. **Fast execution** - Hundreds of milliseconds
5. **Part of unit tests** - Developers actually run them

### The Real Win

When cache communication breaks in production, you don't need to:
- Reproduce the full environment
- Set up complex debugging
- Guess which layer failed

Instead, run these tests locally and immediately see:
- Is the client configured correctly?
- Is the request being sent?
- Is the response being parsed?
- Is the data actually stored?

**Production-realistic integration tests at unit test speeds.**

---

## File Location Convention

Place these tests in your service's test directory:
```
tests/
  integration/
    test_{Service}__Fast_API__local_cache_server.py
```

Or alongside unit tests if your project doesn't separate:
```
tests/
  unit/
    fast_api/
      test_{Service}__Fast_API__local_cache_server.py
```

---

## Version History

- **v1.0** - Initial document based on Graph Service case study
