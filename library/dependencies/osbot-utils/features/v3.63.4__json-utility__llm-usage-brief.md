# Json Utility - LLM Usage Brief

**Version**: v3.63.4  
**Purpose**: Guide for LLMs and developers on using the comprehensive JSON serialization utility  
**Location**: `osbot_utils.utils.Json`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What is the Json Utility?

**The Json utility is a battle-tested toolkit that simplifies JSON operations in Python.** It wraps the standard `json` module with sensible defaults, robust error handling, and seamless file I/O integration, eliminating the boilerplate of exception handling, encoding issues, and file operations.

Instead of writing try/except blocks around every JSON operation, remembering encoding parameters, or handling edge cases for None values, you get simple, reliable operations that return useful values or fail gracefully.

### The Problem It Solves

Python's standard `json` module requires verbose handling for common scenarios:

```python
# Standard library - verbose and error-prone
import json

# Serialize with pretty printing
try:
    result = json.dumps(data, indent=4, sort_keys=False, default=str)
except Exception as e:
    result = None
    print(f"Error: {e}")

# Load from file
try:
    with open(path, 'r') as f:
        data = json.load(f)
except FileNotFoundError:
    data = {}
except json.JSONDecodeError:
    data = {}

# Handle None gracefully
if data is not None:
    json_str = json.dumps(data)
else:
    json_str = None
```

**With the Json utility:**

```python
from osbot_utils.utils.Json import json_dumps, json_load_file, json_loads

# Serialize with pretty printing (default)
result = json_dumps(data)                    # Pretty by default, handles None

# Load from file (returns {} on any error)
data = json_load_file(path)

# Parse JSON string (returns {} on error)
data = json_loads(json_string)
```

### Design Philosophy

1. **Graceful failure** — Operations return `{}` or `None` on error by default, never crash
2. **Sensible defaults** — Pretty printing enabled, 4-space indent, `str` as default serializer
3. **Dual API** — Use `Json.method()` class syntax or `function_name()` aliases
4. **Rich aliases** — Multiple function names for discoverability (`json_parse` = `json_loads` = `str_to_json`)
5. **File integration** — Seamless read/write with gzip support built-in

### The Power of the Json Utility

#### 1. Eliminate Exception Handling Boilerplate

```python
# Standard library - must handle exceptions
try:
    data = json.loads(maybe_invalid_json)
except json.JSONDecodeError:
    data = {}

# Json utility - just works
data = json_loads(maybe_invalid_json)  # Returns {} on error
```

#### 2. Handle None Gracefully

```python
# Standard library - crashes on None
json.dumps(None)  # Returns "null", but what if you want None?

# Json utility - returns None for None input
json_dumps(None)  # Returns None, not "null"
```

#### 3. Sensible Serialization Defaults

```python
# Standard library - must specify everything
json.dumps(data, indent=4, default=str)  # Manual every time

# Json utility - pretty and safe by default
json_dumps(data)  # Pretty printed, uses str() for non-serializable types
```

#### 4. Integrated File Operations

```python
# Standard library - multiple steps
with open(path, 'w') as f:
    json.dump(data, f, indent=2)

# Json utility - one function
json_save_file(data, path, pretty=True)
```

#### 5. Deep Equality with Type Flexibility

```python
# Compare JSON structures where lists and sets should be equivalent
list_data = {"items": [1, 2, 3]}
set_data  = {"items": {1, 2, 3}}

json__equals__list_and_set(list_data, set_data)  # True
```

---

## Quick Start

### Basic Serialization

```python
from osbot_utils.utils.Json import json_dumps, json_loads

# Python → JSON string
data = {"name": "Alice", "scores": [95, 87, 92]}
json_str = json_dumps(data)  # Pretty printed by default

# JSON string → Python
parsed = json_loads(json_str)
```

### File Operations

```python
from osbot_utils.utils.Json import json_load_file, json_save_file

# Save to file
json_save_file(data, '/path/to/file.json', pretty=True)

# Load from file
data = json_load_file('/path/to/file.json')  # Returns {} if file missing
```

### Compact Output

```python
from osbot_utils.utils.Json import json_dumps

# Compact (no whitespace)
compact = json_dumps(data, pretty=False)
```

---

## Import Reference

### Function Aliases (Recommended)

```python
# Serialization (Python → JSON string)
from osbot_utils.utils.Json import (
    json_dumps,              # Primary - serialize to string
    json_dump,               # Alias for json_dumps
    json_format,             # Alias for json_dumps
    json_to_str,             # Alias for json_dumps
    to_json_str,             # Alias for json_dumps
    str_from_json,           # Alias for json_dumps
)

# Deserialization (JSON string → Python)
from osbot_utils.utils.Json import (
    json_loads,              # Primary - parse JSON string
    json_load,               # Alias for json_loads
    json_parse,              # Alias for json_loads
    json_from_string,        # Alias for json_loads
    str_to_json,             # Alias for json_loads
    from_json_str,           # Alias for json_loads
)

# File operations
from osbot_utils.utils.Json import (
    json_load_file,          # Load JSON from file
    json_save_file,          # Save JSON to file
    json_load_file_gz,       # Load from gzipped file
    json_save_file_gz,       # Save to gzipped file
    json_save_file_pretty,   # Save with pretty printing
    json_lines_file_load,    # Load JSON Lines format
    json_lines_file_load_gz, # Load gzipped JSON Lines
)

# Bytes conversion
from osbot_utils.utils.Json import (
    json_dumps_to_bytes,     # Serialize to UTF-8 bytes
    json_to_bytes,           # Alias for json_dumps_to_bytes
    bytes_to_json,           # Parse bytes to Python
    bytes_to_json_loads,     # Alias for bytes_to_json
)

# Compression
from osbot_utils.utils.Json import (
    json_to_gz,              # Serialize and gzip compress
    gz_to_json,              # Decompress gzip and parse
)

# Hashing
from osbot_utils.utils.Json import (
    json_sha_256,            # SHA-256 hash of JSON representation
    json_md5,                # MD5 hash of JSON representation
)

# Comparison
from osbot_utils.utils.Json import (
    json__equals__list_and_set,  # Deep equality treating list/set as equivalent
    json__type_key,              # Sorting key for mixed-type structures
)

# Utilities
from osbot_utils.utils.Json import (
    json_round_trip,         # Serialize then parse (normalize data)
    json_lines_loads,        # Parse JSON Lines string
    json_lines_parse,        # Alias for json_lines_loads
)
```

### Class-Based API

```python
from osbot_utils.utils.Json import Json

# Same operations via class methods
Json.loads(json_string)              # Parse JSON string
Json.load_file(path)                 # Load from file
Json.load_file_gz(path)              # Load from gzipped file
Json.save_file(data, path)           # Save to file
Json.save_file_pretty(data, path)    # Save with pretty printing
Json.save_file_gz(data, path)        # Save to gzipped file
Json.md5(data)                       # MD5 hash
Json.round_trip(data)                # Normalize via JSON round-trip
Json.loads_json_lines(lines_string)  # Parse JSON Lines format
```

---

## API Reference by Category

### Serialization (Python → JSON String)

| Function | Description | Returns |
|----------|-------------|---------|
| `json_dumps(obj, indent=4, pretty=True, sort_keys=False, default=str)` | Serialize Python object to JSON string | `str` or `None` |
| `json_dumps(obj, pretty=False)` | Compact serialization (no whitespace) | `str` |
| `json_dumps_to_bytes(obj, ...)` | Serialize to UTF-8 encoded bytes | `bytes` |

**Parameters:**
- `python_object` — The object to serialize
- `indent` — Number of spaces for indentation (default: 4)
- `pretty` — Enable pretty printing (default: True)
- `sort_keys` — Sort dictionary keys alphabetically (default: False)
- `default` — Fallback serializer for non-JSON types (default: `str`)
- `raise_exception` — Raise on error instead of returning None (default: False)

### Deserialization (JSON String → Python)

| Function | Description | Returns |
|----------|-------------|---------|
| `json_loads(json_string)` | Parse JSON string to Python object | `dict`/`list` or `{}` |
| `json_loads(json_string, raise_exception=True)` | Parse with exception on error | `dict`/`list` or raises |
| `bytes_to_json_loads(data)` | Parse UTF-8 bytes to Python | `dict`/`list` |

### File Operations

| Function | Description | Returns |
|----------|-------------|---------|
| `json_load_file(path)` | Load JSON from file | `dict`/`list` or `{}` |
| `json_save_file(obj, path, pretty=False)` | Save to file | `str` (path) |
| `json_save_file_pretty(obj, path)` | Save with pretty printing | `str` (path) |
| `json_load_file_gz(path)` | Load from gzipped file | `dict`/`list` or `{}` |
| `json_save_file_gz(obj, path)` | Save to gzipped file | `str` (path) |
| `json_load_file_and_delete(path)` | Load then delete file | `dict`/`list` |
| `json_load_file_gz_and_delete(path)` | Load gzipped then delete | `dict`/`list` |

### JSON Lines Format

| Function | Description | Returns |
|----------|-------------|---------|
| `json_lines_file_load(path)` | Load JSON Lines file to list | `list` |
| `json_lines_file_load_gz(path)` | Load gzipped JSON Lines | `list` |
| `json_lines_loads(lines_string)` | Parse JSON Lines string | `list` |

### Compression

| Function | Description | Returns |
|----------|-------------|---------|
| `json_to_gz(data)` | Serialize and gzip compress | `bytes` (gzipped) |
| `gz_to_json(gz_data)` | Decompress and parse | `dict`/`list` |

### Hashing

| Function | Description | Returns |
|----------|-------------|---------|
| `json_sha_256(target)` | SHA-256 of JSON representation | `str` (hex) |
| `json_md5(data)` | MD5 of JSON representation | `str` (hex) |

### Comparison & Utilities

| Function | Description | Returns |
|----------|-------------|---------|
| `json__equals__list_and_set(val1, val2)` | Deep equality (list≈set) | `bool` |
| `json__type_key(obj)` | Sorting key for mixed types | `tuple` |
| `json_round_trip(data)` | Normalize via serialize/parse | `dict`/`list` |

---

## Usage Patterns

### Pattern 1: Safe JSON Parsing

```python
from osbot_utils.utils.Json import json_loads

# Parse user input safely
user_input = request.body.decode('utf-8')
data = json_loads(user_input)  # Returns {} on invalid JSON

if not data:
    return error_response("Invalid JSON")

# Or raise exception for explicit error handling
try:
    data = json_loads(user_input, raise_exception=True)
except Exception as e:
    return error_response(f"Parse error: {e}")
```

### Pattern 2: Configuration File Handling

```python
from osbot_utils.utils.Json import json_load_file, json_save_file_pretty

CONFIG_PATH = '/app/config.json'

def load_config():
    config = json_load_file(CONFIG_PATH)
    if not config:
        return default_config()
    return config

def save_config(config):
    json_save_file_pretty(config, CONFIG_PATH)
```

### Pattern 3: API Response Formatting

```python
from osbot_utils.utils.Json import json_dumps

def api_response(data, compact=False):
    if compact:
        return json_dumps(data, pretty=False)
    return json_dumps(data)  # Pretty printed for debugging
```

### Pattern 4: JSON Lines (NDJSON) Processing

```python
from osbot_utils.utils.Json import json_lines_file_load, json_lines_file_load_gz

# Load log file in JSON Lines format
# Each line is a separate JSON object
logs = json_lines_file_load('/var/log/app.jsonl')

for entry in logs:
    if entry.get('level') == 'ERROR':
        process_error(entry)

# Load compressed JSON Lines
archived_logs = json_lines_file_load_gz('/var/log/archive.jsonl.gz')
```

### Pattern 5: Data Deduplication with Hashing

```python
from osbot_utils.utils.Json import json_sha_256

def deduplicate_records(records):
    seen = set()
    unique = []
    
    for record in records:
        hash_key = json_sha_256(record)
        if hash_key not in seen:
            seen.add(hash_key)
            unique.append(record)
    
    return unique
```

### Pattern 6: Compressed JSON Storage

```python
from osbot_utils.utils.Json import json_to_gz, gz_to_json, json_save_file_gz, json_load_file_gz

# In-memory compression for transmission
compressed = json_to_gz(large_data)
send_over_network(compressed)

# Receive and decompress
received = receive_from_network()
data = gz_to_json(received)

# File-based compression
json_save_file_gz(large_data, '/data/archive.json.gz')
restored = json_load_file_gz('/data/archive.json.gz')
```

### Pattern 7: Deep Comparison with Type Flexibility

```python
from osbot_utils.utils.Json import json__equals__list_and_set

# Compare structures where list/set ordering shouldn't matter
expected = {"tags": ["python", "json", "utils"]}
actual   = {"tags": {"utils", "python", "json"}}  # Different order, set vs list

assert json__equals__list_and_set(expected, actual)  # True

# Nested comparison works too
config_a = {"servers": [{"host": "a"}, {"host": "b"}]}
config_b = {"servers": [{"host": "b"}, {"host": "a"}]}  # Different order

assert json__equals__list_and_set(config_a, config_b)  # True
```

### Pattern 8: Bytes Handling for Network/Storage

```python
from osbot_utils.utils.Json import json_dumps_to_bytes, bytes_to_json_loads

# Serialize to bytes for storage/transmission
data = {"message": "Hello, World!"}
raw_bytes = json_dumps_to_bytes(data)

# Store in binary cache
cache.set(b'my_key', raw_bytes)

# Retrieve and parse
retrieved = cache.get(b'my_key')
parsed = bytes_to_json_loads(retrieved)
```

### Pattern 9: Data Normalization via Round-Trip

```python
from osbot_utils.utils.Json import json_round_trip

# Normalize data by serializing and parsing
# Converts sets to lists, custom objects to their string representation, etc.
messy_data = {
    "items": {1, 2, 3},           # set
    "timestamp": datetime.now(),  # datetime
}

normalized = json_round_trip(messy_data)
# {"items": [1, 2, 3], "timestamp": "2024-01-15 10:30:00"}
```

### Pattern 10: Temporary JSON Files

```python
from osbot_utils.utils.Json import json_save_file, json_load_file_and_delete

# Create temp file for inter-process communication
temp_path = json_save_file(data, path=None)  # Auto-generates temp path

# In another process - load and cleanup
data = json_load_file_and_delete(temp_path)  # File removed after reading
```

---

## Common Recipes

### Recipe: Safe Config Loading with Defaults

```python
from osbot_utils.utils.Json import json_load_file

def load_config_with_defaults(path, defaults):
    config = json_load_file(path)
    return {**defaults, **config}  # Config overrides defaults

# Usage
config = load_config_with_defaults('/app/config.json', {
    'debug': False,
    'port': 8080,
    'workers': 4,
})
```

### Recipe: JSON Schema Validation Prep

```python
from osbot_utils.utils.Json import json_loads, json_round_trip

def validate_json_input(raw_input):
    # Parse and normalize
    data = json_loads(raw_input)
    if not data:
        return None, "Invalid JSON"
    
    # Normalize to ensure consistent types
    normalized = json_round_trip(data)
    
    # Now validate against schema...
    return normalized, None
```

### Recipe: Incremental JSON Lines Writing

```python
from osbot_utils.utils.Json import json_dumps

def write_json_lines(records, path):
    with open(path, 'w') as f:
        for record in records:
            line = json_dumps(record, pretty=False)  # Compact, one line
            f.write(line + '\n')
```

### Recipe: Compare JSON Files

```python
from osbot_utils.utils.Json import json_load_file, json__equals__list_and_set

def json_files_equivalent(path1, path2):
    data1 = json_load_file(path1)
    data2 = json_load_file(path2)
    return json__equals__list_and_set(data1, data2)
```

### Recipe: Cache with JSON Hashing

```python
from osbot_utils.utils.Json import json_sha_256, json_dumps, json_loads

class JsonCache:
    def __init__(self):
        self.store = {}
    
    def get_or_compute(self, key_data, compute_fn):
        cache_key = json_sha_256(key_data)
        
        if cache_key in self.store:
            return self.store[cache_key]
        
        result = compute_fn()
        self.store[cache_key] = result
        return result
```

---

## Best Practices

### DO: Use Graceful Error Handling

```python
# ✅ Good - returns {} on error, check for empty
data = json_loads(user_input)
if not data:
    handle_invalid_input()

# ✅ Good - explicit exception when needed
try:
    data = json_loads(user_input, raise_exception=True)
except Exception as e:
    log_error(e)
```

### DO: Use Pretty Printing for Debugging

```python
# ✅ Good - pretty for debugging/logs
debug_output = json_dumps(response_data)  # Pretty by default
logger.debug(f"API Response:\n{debug_output}")

# ✅ Good - compact for production transmission
api_response = json_dumps(response_data, pretty=False)
```

### DO: Use Appropriate File Functions

```python
# ✅ Good - use built-in file operations
data = json_load_file('/config.json')
json_save_file_pretty(data, '/config.json')

# ❌ Bad - manual file handling
with open('/config.json', 'r') as f:
    data = json.loads(f.read())
```

### DO: Use json_round_trip for Normalization

```python
# ✅ Good - normalize data before comparison/storage
normalized = json_round_trip(potentially_messy_data)

# ❌ Bad - comparing data with inconsistent types
data1 == data2  # May fail due to set vs list, datetime vs string, etc.
```

### DON'T: Ignore Return Values

```python
# ❌ Bad - ignoring potential parse failure
data = json_loads(untrusted_input)
process(data['key'])  # May fail if data is {}

# ✅ Good - check result
data = json_loads(untrusted_input)
if data and 'key' in data:
    process(data['key'])
```

### DON'T: Use Wrong Function for Format

```python
# ❌ Bad - wrong function for JSON Lines
data = json_load_file('/logs.jsonl')  # Won't work correctly

# ✅ Good - use JSON Lines specific function
data = json_lines_file_load('/logs.jsonl')
```

### DON'T: Forget Compression for Large Files

```python
# ❌ Bad - large files without compression
json_save_file(huge_data, '/archive.json')  # Large file

# ✅ Good - compress large files
json_save_file_gz(huge_data, '/archive.json.gz')  # Much smaller
```

---

## Troubleshooting

### Problem: json_loads Returns Empty Dict

**Cause 1**: Invalid JSON input
```python
# Check if input is valid
data = json_loads('not valid json')  # Returns {}

# Solution: Use raise_exception to see error
try:
    data = json_loads('not valid json', raise_exception=True)
except Exception as e:
    print(f"Parse error: {e}")  # Shows actual error
```

**Cause 2**: Empty or None input
```python
# json_loads returns {} for empty/None input
json_loads(None)    # Returns {}
json_loads('')      # Returns {}
json_loads('   ')   # Returns {}
```

### Problem: json_dumps Returns None

**Cause**: Input is None
```python
json_dumps(None)  # Returns None by design

# If you want "null" string, use standard json
import json
json.dumps(None)  # Returns "null"
```

### Problem: Non-Serializable Types

**Cause**: Object cannot be converted to JSON
```python
# Default behavior uses str() for unknown types
data = {"date": datetime.now()}
result = json_dumps(data)  # Works - datetime converted via str()

# If default=str isn't enough
def custom_serializer(obj):
    if isinstance(obj, datetime):
        return obj.isoformat()
    return str(obj)

result = json_dumps(data, default=custom_serializer)
```

### Problem: json_load_file Returns Empty Dict

**Cause 1**: File doesn't exist
```python
from osbot_utils.utils.Files import file_exists

if not file_exists(path):
    print("File not found")
```

**Cause 2**: File contains invalid JSON
```python
# Check file contents
from osbot_utils.utils.Files import file_contents
raw = file_contents(path)
print(f"File contents: {raw!r}")  # See what's actually in file
```

### Problem: JSON Lines Not Parsing Correctly

**Cause**: Using wrong function
```python
# ❌ Wrong - json_load_file expects single JSON object
data = json_load_file('/logs.jsonl')  # Fails or wrong result

# ✅ Correct - use JSON Lines function
data = json_lines_file_load('/logs.jsonl')
```

### Problem: Deep Comparison Fails Unexpectedly

**Cause**: Type differences not in list/set
```python
# json__equals__list_and_set handles list/set, but not int/float
val1 = {"count": 1}
val2 = {"count": 1.0}

json__equals__list_and_set(val1, val2)  # False - different types

# Solution: normalize first
json__equals__list_and_set(
    json_round_trip(val1),
    json_round_trip(val2)
)  # True after normalization
```

---

## Function Alias Quick Reference

The module provides extensive aliases for discoverability. Use whichever reads best in your context:

### Serialization Aliases

| Alias | Same As | Semantic |
|-------|---------|----------|
| `json_dumps` | Primary | "dumps" from stdlib |
| `json_dump` | `json_dumps` | Shorter form |
| `json_format` | `json_dumps` | "Format as JSON" |
| `json_to_str` | `json_dumps` | Direction: to string |
| `to_json_str` | `json_dumps` | Direction: to string |
| `str_from_json` | `json_dumps` | Direction: string from object |

### Deserialization Aliases

| Alias | Same As | Semantic |
|-------|---------|----------|
| `json_loads` | Primary | "loads" from stdlib |
| `json_load` | `json_loads` | Shorter form |
| `json_parse` | `json_loads` | "Parse JSON" |
| `json_from_string` | `json_loads` | Direction: from string |
| `str_to_json` | `json_loads` | Direction: string to object |
| `from_json_str` | `json_loads` | Direction: from string |

### File Aliases

| Alias | Same As | Semantic |
|-------|---------|----------|
| `json_load_file` | `Json.load_file` | "Load from file" |
| `json_file_contents` | `Json.load_file` | "Get file contents" |
| `json_from_file` | `Json.load_file` | Direction: from file |
| `load_file_json` | `json_load_file` | "Load file as JSON" |
| `json_save_file` | `Json.save_file` | "Save to file" |
| `json_to_file` | `Json.save_file` | Direction: to file |
| `json_file_create` | `Json.save_file` | "Create file" |
| `file_create_json` | `Json.save_file_pretty` | "Create JSON file" |

---

## Summary Checklist

When working with JSON in OSBot-Utils:

- [ ] Import from `osbot_utils.utils.Json`
- [ ] Use `json_dumps()` for serialization (pretty by default)
- [ ] Use `json_loads()` for parsing (returns `{}` on error)
- [ ] Check for empty dict when parsing untrusted input
- [ ] Use `raise_exception=True` when you need explicit error handling
- [ ] Use `json_load_file()` / `json_save_file()` for file operations
- [ ] Use `json_lines_file_load()` for JSON Lines format (`.jsonl`)
- [ ] Use `json_to_gz()` / `gz_to_json()` for compression
- [ ] Use `json_sha_256()` for content hashing
- [ ] Use `json__equals__list_and_set()` for deep comparison ignoring list/set differences
- [ ] Use `json_round_trip()` to normalize data types
- [ ] Use `pretty=False` for compact transmission
- [ ] Remember: `json_dumps(None)` returns `None`, not `"null"`
- [ ] Remember: `json_loads()` returns `{}` for empty/invalid input