# Temp Utilities - LLM Usage Brief

**Version**: v3.69.2  
**Purpose**: Guide for LLMs and developers on using the temporary resource context managers for testing  
**Location**: `osbot_utils.testing.*`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What are the Temp Utilities?

**The Temp utilities are a collection of context managers that create, manage, and automatically clean up temporary resources during testing and development.** They wrap the tedious setup/teardown pattern into simple `with` statements, ensuring resources are properly cleaned up even when exceptions occur.

Instead of manually creating temp files, remembering to delete them, handling cleanup in `finally` blocks, and debugging leftover artifacts, you get deterministic resource lifecycle management that just works.

### The Problem They Solve

Testing and development workflows constantly need temporary resources:

```python
# Standard approach - verbose and error-prone
import tempfile
import os
import shutil

# Create temp file
fd, tmp_path = tempfile.mkstemp('.txt')
os.close(fd)
with open(tmp_path, 'w') as f:
    f.write('test data')

try:
    # Your test code
    result = process_file(tmp_path)
    assert result == expected
finally:
    # Must remember to clean up
    if os.path.exists(tmp_path):
        os.remove(tmp_path)
    # What if there's a temp folder too? More cleanup code...

# Environment variables are even worse
original_api_key = os.environ.get('API_KEY')
os.environ['API_KEY'] = 'test-key'
try:
    run_test()
finally:
    if original_api_key:
        os.environ['API_KEY'] = original_api_key
    else:
        del os.environ['API_KEY']
```

**With Temp utilities:**

```python
from osbot_utils.testing.Temp_File     import Temp_File
from osbot_utils.testing.Temp_Env_Vars import Temp_Env_Vars

# Temp file - created with content, auto-deleted on exit
with Temp_File(contents='test data') as temp_file:
    result = process_file(temp_file.path())
    assert result == expected

# Environment variables - set temporarily, auto-restored
with Temp_Env_Vars(env_vars={'API_KEY': 'test-key'}):
    run_test()
# Original value automatically restored (or removed if it didn't exist)
```

### Design Philosophy

1. **Context manager pattern** — Every Temp utility is a `with` statement. Enter creates, exit cleans.
2. **Automatic cleanup** — Resources are deleted/restored even if exceptions occur inside the block.
3. **Rich defaults** — `Temp_File()` creates a file with default content. Zero ceremony required.
4. **Chainable/nestable** — Combine multiple temps freely; cleanup happens in reverse order.
5. **Test-first mindset** — Built for the realities of testing: isolation, reproducibility, and no side effects.

### The Power of Temp Utilities

#### 1. Zero-Leakage Testing

```python
# Every resource created inside 'with' is guaranteed cleaned up
with Temp_Folder(temp_files_to_add=10) as folder:
    with Temp_Web_Server(root_folder=folder.path()) as server:
        response = server.GET('/file_0.txt')
        # Test assertions...

# Folder gone, server stopped, port released - automatically
```

#### 2. Isolated Environment Testing

```python
# Test code that depends on environment variables
with Temp_Env_Vars(env_vars={'DATABASE_URL': 'sqlite:///:memory:',
                              'DEBUG'       : 'true'              }):
    app = create_app()  # Uses test config
    # Run tests...
# Original environment restored exactly
```

#### 3. Temporary Module Paths

```python
# Test dynamic imports from custom locations
with Temp_Folder() as folder:
    folder.add_file('my_module.py', 'def hello(): return "world"')
    
    with Temp_Sys_Path(folder.path()):
        import my_module
        assert my_module.hello() == "world"
# Path removed from sys.path, no import pollution
```

#### 4. In-Memory Zip Operations

```python
# Create zip files without touching disk
with Temp_Zip_In_Memory() as zip_mem:
    zip_mem.add_file_from_content('config.json', '{"key": "value"}')
    zip_mem.add_file_from_content('data/file.txt', 'contents')
    
    zip_bytes = zip_mem.zip_bytes()  # Use directly or save
```

#### 5. Local Web Servers for Integration Tests

```python
# Spin up a real HTTP server for testing
with Temp_File(contents='{"status": "ok"}') as json_file:
    with Temp_Web_Server(root_folder=json_file.folder()) as server:
        response = requests.get(server.url(json_file.file_name()))
        assert response.json()['status'] == 'ok'
# Server stopped, file deleted
```

---

## Quick Start

### Temp_File - Temporary Files

```python
from osbot_utils.testing.Temp_File import Temp_File

# Basic usage - file with default content
with Temp_File() as temp_file:
    print(temp_file.path())       # /tmp/temp_folder_xxx/random_name.tmp
    print(temp_file.contents())   # '...'
    print(temp_file.exists())     # True

# File is automatically deleted after the block

# Custom content and extension
with Temp_File(contents='{"key": "value"}', extension='json') as tf:
    data = json.loads(tf.contents())

# Get just the path (convenient for APIs that need paths)
with Temp_File(return_file_path=True) as path:
    print(path)  # Returns string path directly, not Temp_File object
```

### Temp_Folder - Temporary Directories

```python
from osbot_utils.testing.Temp_Folder import Temp_Folder

# Basic usage
with Temp_Folder() as folder:
    print(folder.path())    # /tmp/temp_folder_xxx
    print(folder.exists())  # True

# Create with auto-generated test files
with Temp_Folder(temp_files_to_add=5) as folder:
    print(folder.files())   # ['file1.txt', 'subdir/file2.txt', ...]

# Add files programmatically
with Temp_Folder() as folder:
    path = folder.add_file('test.txt', 'content')
    subfolder = folder.add_folder('subdir')
```

### Temp_Env_Vars - Temporary Environment Variables

```python
from osbot_utils.testing.Temp_Env_Vars import Temp_Env_Vars

# Set environment variables temporarily
with Temp_Env_Vars(env_vars={'API_KEY': 'test-123', 'DEBUG': 'true'}):
    assert os.environ['API_KEY'] == 'test-123'
    assert os.environ['DEBUG'] == 'true'

# After block: original values restored (or vars removed if they didn't exist)
```

### Temp_Sys_Path - Temporary Python Path

```python
from osbot_utils.testing.Temp_Sys_Path import Temp_Sys_Path

# Add path to sys.path temporarily
with Temp_Sys_Path('/custom/module/path'):
    import custom_module  # Can now import from /custom/module/path

# Path automatically removed from sys.path
```

### Temp_Web_Server - Temporary HTTP Server

```python
from osbot_utils.testing.Temp_Web_Server import Temp_Web_Server

# Serve files from a directory
with Temp_Web_Server(root_folder='/path/to/files') as server:
    html = server.GET('index.html')
    assert server.GET_contains('<title>', path='index.html')
    print(server.url('api/data'))  # http://127.0.0.1:xxxxx/api/data
```

### Temp_Zip - Temporary Zip Files

```python
from osbot_utils.testing.Temp_Zip import Temp_Zip

# Zip a folder temporarily
with Temp_Folder(temp_files_to_add=3) as folder:
    with Temp_Zip(folder) as temp_zip:
        print(temp_zip.path())   # /tmp/xxx.zip
        print(temp_zip.files())  # ['file1.txt', 'file2.txt', 'file3.txt']
# Zip file automatically deleted
```

### Temp_Zip_In_Memory - In-Memory Zip Creation

```python
from osbot_utils.testing.Temp_Zip_In_Memory import Temp_Zip_In_Memory

# Create zip entirely in memory
with Temp_Zip_In_Memory() as zip_mem:
    zip_mem.add_file_from_content('readme.txt', 'Hello World')
    zip_mem.add_file_from_content('data/config.json', '{}')
    
    # Get as bytes (for API uploads, etc.)
    zip_bytes = zip_mem.zip_bytes()
    
    # Or save to disk
    zip_path = zip_mem.create_zip_file('/output/archive.zip')
```

---

## Import Reference

### All Temp Utilities

```python
# Individual imports
from osbot_utils.testing.Temp_File          import Temp_File
from osbot_utils.testing.Temp_Folder        import Temp_Folder
from osbot_utils.testing.Temp_Env_Vars      import Temp_Env_Vars
from osbot_utils.testing.Temp_Sys_Path      import Temp_Sys_Path
from osbot_utils.testing.Temp_Web_Server    import Temp_Web_Server
from osbot_utils.testing.Temp_Zip           import Temp_Zip
from osbot_utils.testing.Temp_Zip_In_Memory import Temp_Zip_In_Memory
```

---

## API Reference by Category

### Temp_File

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_File(contents, extension, file_name, return_file_path, create_file)` | Constructor | `Temp_File` |
| `path()` | Get full file path | `str` |
| `contents()` | Read file contents | `str` or `None` |
| `exists()` | Check if file exists | `bool` |
| `file_name()` | Get just the filename | `str` |
| `folder()` | Get parent folder path | `str` |
| `files_in_folder()` | List all files in temp folder | `list[str]` |
| `write(contents)` | Write new contents | `Temp_File` |
| `delete()` | Manually delete file | `bool` |

**Constructor Parameters:**
- `contents` — Initial file content (default: `'...'`)
- `extension` — File extension without dot (default: `'tmp'`)
- `file_name` — Custom filename (default: random)
- `return_file_path` — If True, `__enter__` returns path string instead of object
- `create_file` — If False, don't create file on enter (default: `True`)

### Temp_Folder

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_Folder(folder_name, parent_folder, delete_on_exit, temp_files_to_add)` | Constructor | `Temp_Folder` |
| `path()` | Get folder path | `str` |
| `exists()` | Check if folder exists | `bool` |
| `files(show_parent_folder, include_folders)` | List files in folder | `list[str]` |
| `folders(show_parent_folder)` | List subfolders | `list[str]` |
| `files_and_folders(show_parent_folder)` | List all contents | `list[str]` |
| `add_file(file_name, contents)` | Create file in folder | `str` (path) |
| `add_folder(name)` | Create subfolder | `str` (path) |
| `add_temp_files(count)` | Add random temp files | `None` |
| `file_contents(target_file)` | Read file by relative path | `str` |
| `files_contents()` | Read all files as dict | `dict[str, str]` |
| `zip()` | Create zip of folder | `str` (zip path) |

**Constructor Parameters:**
- `folder_name` — Custom folder name (default: random)
- `parent_folder` — Parent directory (default: system temp)
- `delete_on_exit` — Auto-delete on exit (default: `True`)
- `temp_files_to_add` — Auto-generate N test files (default: `0`)

### Temp_Env_Vars

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_Env_Vars(env_vars)` | Constructor | `Temp_Env_Vars` |
| `set_vars()` | Apply env vars (called by `__enter__`) | `Temp_Env_Vars` |
| `restore_vars()` | Restore original values (called by `__exit__`) | `None` |

**Constructor Parameters:**
- `env_vars` — Dict of `{var_name: value}` to set temporarily

### Temp_Sys_Path

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_Sys_Path(path)` | Constructor | `Temp_Sys_Path` |

**Constructor Parameters:**
- `path` — Directory path to add to `sys.path`

### Temp_Web_Server

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_Web_Server(host, port, root_folder, server_name, http_handler, wait_for_stop)` | Constructor | `Temp_Web_Server` |
| `start()` | Start the server | `Temp_Web_Server` |
| `stop()` | Stop the server | `Temp_Web_Server` |
| `url(path)` | Build URL for path | `str` |
| `GET(path)` | HTTP GET request | `str` or `None` |
| `GET_contains(content, path)` | Check if response contains text | `bool` |
| `add_file(relative_file_path, file_contents)` | Add file to server root | `str` (path) |
| `server_port_open()` | Check if port is listening | `bool` |

**Constructor Parameters:**
- `host` — Bind address (default: `'127.0.0.1'`)
- `port` — Port number (default: random available port)
- `root_folder` — Directory to serve (default: `'.'`)
- `server_name` — Thread name for debugging
- `http_handler` — Custom handler class (default: `SimpleHTTPRequestHandler`)
- `wait_for_stop` — Block on stop until port released (default: `False`)

### Temp_Zip

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_Zip(target, target_zip_file, delete_zip_file)` | Constructor | `Temp_Zip` |
| `path()` | Get zip file path | `str` |
| `files()` | List files in zip | `list[str]` |
| `file_name()` | Get zip filename | `str` |
| `zip_file_exists()` | Check if zip exists | `bool` |
| `move_to(target_file)` | Move zip to new location | `None` |

**Constructor Parameters:**
- `target` — Folder to zip (can be `Temp_Folder`)
- `target_zip_file` — Custom output path (default: temp)
- `delete_zip_file` — Auto-delete on exit (default: `True`)

### Temp_Zip_In_Memory

| Method/Property | Description | Returns |
|-----------------|-------------|---------|
| `Temp_Zip_In_Memory(targets, targets_as_bytes)` | Constructor | `Temp_Zip_In_Memory` |
| `add_file(file, root_folder)` | Add existing file to zip | `Temp_Zip_In_Memory` |
| `add_folder(folder, root_folder)` | Add folder contents to zip | `Temp_Zip_In_Memory` |
| `add_file_from_content(file_path, file_contents)` | Add virtual file from string | `Temp_Zip_In_Memory` |
| `set_root_folder(root_folder)` | Set base path for relative paths | `Temp_Zip_In_Memory` |
| `zip_bytes()` | Get zip as bytes | `bytes` |
| `zip_bytes_files()` | List files in zip | `list[str]` |
| `zip_bytes_file_content(file_path)` | Read file from zip | `bytes` |
| `create_zip_file(target_zip_file)` | Save zip to disk | `str` (path) |
| `target_files()` | List all source files | `list[str]` |

---

## Usage Patterns

### Pattern 1: Isolated File-Based Tests

```python
from osbot_utils.testing.Temp_File import Temp_File

def test_file_processor():
    with Temp_File(contents='line1\nline2\nline3', extension='txt') as tf:
        processor = FileProcessor()
        result = processor.count_lines(tf.path())
        
        assert result == 3
        assert tf.exists()
    
    # File automatically cleaned up - no assertions needed
```

### Pattern 2: Testing with Directory Structures

```python
from osbot_utils.testing.Temp_Folder import Temp_Folder

def test_directory_scanner():
    with Temp_Folder() as folder:
        # Create test structure
        folder.add_file('config.json', '{"version": 1}')
        folder.add_file('data/users.csv', 'id,name\n1,Alice')
        folder.add_folder('empty_dir')
        
        scanner = DirectoryScanner(folder.path())
        
        assert scanner.count_files() == 2
        assert 'config.json' in scanner.list_files()
```

### Pattern 3: Environment-Dependent Code Testing

```python
from osbot_utils.testing.Temp_Env_Vars import Temp_Env_Vars

def test_config_loading():
    # Test with specific environment
    with Temp_Env_Vars(env_vars={'APP_ENV'  : 'testing' ,
                                  'LOG_LEVEL': 'DEBUG'   ,
                                  'API_URL'  : 'http://test.local'}):
        config = AppConfig.from_environment()
        
        assert config.environment == 'testing'
        assert config.log_level == 'DEBUG'
    
    # Original environment restored - next test unaffected
```

### Pattern 4: Integration Tests with HTTP

```python
from osbot_utils.testing.Temp_Web_Server import Temp_Web_Server
from osbot_utils.testing.Temp_Folder     import Temp_Folder

def test_http_client():
    with Temp_Folder() as folder:
        folder.add_file('api/users.json', '[{"id": 1, "name": "Alice"}]')
        
        with Temp_Web_Server(root_folder=folder.path()) as server:
            client = HttpClient(base_url=server.url())
            users = client.get_users()
            
            assert len(users) == 1
            assert users[0]['name'] == 'Alice'
```

### Pattern 5: Custom HTTP Handler for Mocking

```python
from http.server import BaseHTTPRequestHandler
from osbot_utils.testing.Temp_Web_Server import Temp_Web_Server

class MockAPIHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.end_headers()
        self.wfile.write(b'{"status": "mocked"}')
    
    def log_message(self, format, *args):
        pass  # Suppress logging

def test_with_mock_api():
    with Temp_Web_Server(http_handler=MockAPIHandler) as server:
        response = requests.get(server.url('/anything'))
        assert response.json()['status'] == 'mocked'
```

### Pattern 6: Testing Import Behavior

```python
from osbot_utils.testing.Temp_Folder   import Temp_Folder
from osbot_utils.testing.Temp_Sys_Path import Temp_Sys_Path

def test_plugin_loading():
    with Temp_Folder() as folder:
        # Create a test plugin
        plugin_code = '''
class MyPlugin:
    name = "test_plugin"
    def run(self):
        return "executed"
'''
        folder.add_file('my_plugin.py', plugin_code)
        
        with Temp_Sys_Path(folder.path()):
            from my_plugin import MyPlugin
            
            plugin = MyPlugin()
            assert plugin.name == "test_plugin"
            assert plugin.run() == "executed"
```

### Pattern 7: Creating Test Archives

```python
from osbot_utils.testing.Temp_Folder        import Temp_Folder
from osbot_utils.testing.Temp_Zip           import Temp_Zip
from osbot_utils.testing.Temp_Zip_In_Memory import Temp_Zip_In_Memory

# From existing folder
def test_zip_extraction():
    with Temp_Folder(temp_files_to_add=5) as folder:
        with Temp_Zip(folder) as temp_zip:
            extractor = ZipExtractor()
            files = extractor.list_contents(temp_zip.path())
            
            assert len(files) == 5

# From scratch (in memory)
def test_zip_upload():
    with Temp_Zip_In_Memory() as zip_mem:
        zip_mem.add_file_from_content('manifest.json', '{"version": "1.0"}')
        zip_mem.add_file_from_content('data/payload.bin', 'binary data here')
        
        response = api_client.upload_archive(zip_mem.zip_bytes())
        assert response.status_code == 200
```

### Pattern 8: Nested Temps for Complex Scenarios

```python
from osbot_utils.testing.Temp_File     import Temp_File
from osbot_utils.testing.Temp_Folder   import Temp_Folder
from osbot_utils.testing.Temp_Env_Vars import Temp_Env_Vars

def test_full_integration():
    with Temp_Env_Vars(env_vars={'CONFIG_PATH': '/custom/path'}):
        with Temp_Folder() as workspace:
            config_path = workspace.add_file('config.yaml', 'debug: true')
            
            with Temp_File(contents='input data') as input_file:
                app = Application(workspace=workspace.path(),
                                  config   =config_path      ,
                                  input    =input_file.path())
                
                result = app.process()
                assert result.success
    
    # All resources cleaned up in reverse order:
    # 1. input_file deleted
    # 2. workspace folder deleted
    # 3. CONFIG_PATH env var restored
```

### Pattern 9: Temp_Folder with Nested Folders

```python
from osbot_utils.testing.Temp_Folder import Temp_Folder

def test_nested_folder_handling():
    with Temp_Folder() as root:
        # Create nested structure via Temp_Folder chaining
        with Temp_Folder(parent_folder=root) as level1:
            level1.add_file('file_at_level1.txt', 'content')
            
            with Temp_Folder(parent_folder=level1) as level2:
                level2.add_file('file_at_level2.txt', 'deep content')
                
                # Verify structure
                all_files = root.files()
                assert len(all_files) == 2
        
        # Inner folders deleted when their context exits
```

### Pattern 10: Keeping Files for Debugging

```python
from osbot_utils.testing.Temp_Folder import Temp_Folder
from osbot_utils.testing.Temp_Zip    import Temp_Zip

def test_with_debug_output():
    # Don't delete on exit - useful for post-mortem debugging
    with Temp_Folder(delete_on_exit=False) as folder:
        folder.add_file('debug_data.json', debug_info)
        
        # ... run test ...
        
        print(f"Debug files at: {folder.path()}")
    
    # Folder still exists after context exit!
    
    # Similarly for zip files
    with Temp_Zip(folder, delete_zip_file=False) as temp_zip:
        print(f"Zip preserved at: {temp_zip.path()}")
```

---

## Best Practices

### DO: Use Context Managers Properly

```python
# ✅ Good - resources always cleaned up
with Temp_File(contents='data') as tf:
    process(tf.path())

# ❌ Bad - manual cleanup is error-prone
tf = Temp_File(contents='data')
tf.__enter__()
try:
    process(tf.path())
finally:
    tf.__exit__(None, None, None)
```

### DO: Nest Contexts for Complex Scenarios

```python
# ✅ Good - clear lifecycle, automatic cleanup order
with Temp_Folder() as folder:
    with Temp_Web_Server(root_folder=folder.path()) as server:
        with Temp_Env_Vars(env_vars={'API_URL': server.url()}):
            run_tests()

# ❌ Bad - manual coordination
folder = Temp_Folder().__enter__()
server = Temp_Web_Server(root_folder=folder.path()).__enter__()
# ... lots of error-prone cleanup code
```

### DO: Use return_file_path for Path-Only APIs

```python
# ✅ Good - when you just need the path
with Temp_File(contents='data', return_file_path=True) as path:
    result = some_api_that_takes_path(path)

# ✅ Also good - explicit path() call
with Temp_File(contents='data') as tf:
    result = some_api_that_takes_path(tf.path())
```

### DO: Use temp_files_to_add for Bulk Testing

```python
# ✅ Good - generates realistic test structure
with Temp_Folder(temp_files_to_add=20) as folder:
    scanner = DirectoryScanner()
    results = scanner.scan(folder.path())
    assert len(results) == 20
```

### DO: Accept Both Temp_Folder and String Paths

```python
# ✅ Good - flexible APIs that accept both
with Temp_Folder() as folder:
    with Temp_Zip(folder) as zip:       # Works with Temp_Folder
        pass
    with Temp_Zip(folder.path()) as zip: # Also works with string
        pass
```

### DON'T: Store References Beyond Context

```python
# ❌ Bad - reference invalid after context exits
temp_file_ref = None
with Temp_File() as tf:
    temp_file_ref = tf

# temp_file_ref.path() points to deleted file!
```

### DON'T: Forget to Check Server Port in Tests

```python
# ❌ Bad - may fail on port collision
with Temp_Web_Server(port=8080) as server:  # What if 8080 is in use?
    pass

# ✅ Good - let it pick a random available port
with Temp_Web_Server() as server:  # Random port, always works
    print(server.url())  # http://127.0.0.1:xxxxx
```

### DON'T: Use Temp Resources in Production

```python
# ❌ Bad - temp resources are for testing only
def production_handler(request):
    with Temp_File() as tf:  # Creates temp files on every request!
        tf.write(request.body)
        return process(tf.path())

# ✅ Good - use proper file handling in production
def production_handler(request):
    path = get_upload_path(request)
    with open(path, 'wb') as f:
        f.write(request.body)
    return process(path)
```

### DON'T: Assume Cleanup Order in Parallel Tests

```python
# ❌ Risky - parallel tests may interfere
def test_a():
    with Temp_Folder(folder_name='shared') as folder:  # Same name!
        pass

def test_b():
    with Temp_Folder(folder_name='shared') as folder:  # Collision!
        pass

# ✅ Safe - unique names (default behavior)
def test_a():
    with Temp_Folder() as folder:  # Random unique name
        pass
```

---

## Troubleshooting

### Problem: File Not Found After Context

**Cause**: Accessing temp resource after `with` block exits

```python
# ❌ This won't work
with Temp_File() as tf:
    path = tf.path()

content = open(path).read()  # File already deleted!

# ✅ Do everything inside the context
with Temp_File() as tf:
    content = tf.contents()
    process(content)
```

### Problem: Temp_Web_Server Port Not Releasing

**Cause**: Server threads not fully stopped

```python
# ✅ Solution: Use wait_for_stop=True
with Temp_Web_Server(wait_for_stop=True) as server:
    # ... tests ...
# Port guaranteed released after block
```

**Note**: `wait_for_stop=True` adds ~500ms delay but ensures port is fully released.

### Problem: Environment Variables Still Set

**Cause**: Exception before `__exit__` ran

```python
# This should NOT happen with proper context manager usage
# But if manually calling methods:

env = Temp_Env_Vars(env_vars={'KEY': 'value'})
env.set_vars()
# ... exception here ...
# env.restore_vars() never called!

# ✅ Always use context manager
with Temp_Env_Vars(env_vars={'KEY': 'value'}):
    # Even if exception occurs here, restore_vars is called
    raise Exception("test")
```

### Problem: Temp_Zip Shows Wrong Files

**Cause**: Not setting root_folder correctly

```python
# ❌ Full paths in zip
with Temp_Folder() as folder:
    folder.add_file('test.txt', 'content')
    with Temp_Zip_In_Memory() as zip_mem:
        zip_mem.add_folder(folder)
        print(zip_mem.zip_bytes_files())  
        # ['/tmp/temp_folder_xxx/test.txt'] - full path!

# ✅ Set root_folder for relative paths
with Temp_Folder() as folder:
    folder.add_file('test.txt', 'content')
    with Temp_Zip_In_Memory() as zip_mem:
        zip_mem.add_folder(folder)
        zip_mem.set_root_folder(folder)
        print(zip_mem.zip_bytes_files())  
        # ['test.txt'] - relative path!
```

### Problem: Temp_Sys_Path Import Caching

**Cause**: Python caches imports

```python
# First import works
with Temp_Sys_Path('/path/v1'):
    import my_module  # Imports from /path/v1

# Second import uses cached version!
with Temp_Sys_Path('/path/v2'):
    import my_module  # Still the v1 version!

# ✅ Solution: Reload or use importlib
import importlib
with Temp_Sys_Path('/path/v2'):
    importlib.reload(my_module)  # Forces re-import
```

### Problem: Temp_Folder Files Not Found

**Cause**: Using wrong path format

```python
with Temp_Folder() as folder:
    folder.add_file('sub/dir/file.txt', 'content')
    
    # ❌ Wrong - files() returns relative paths
    for f in folder.files():
        open(f).read()  # FileNotFoundError!
    
    # ✅ Correct - use show_parent_folder or combine paths
    for f in folder.files(show_parent_folder=True):
        open(f).read()  # Works!
    
    # ✅ Or use file_contents
    content = folder.file_contents('sub/dir/file.txt')
```

### Problem: Tests Fail on CI but Pass Locally

**Cause**: Different temp directory locations or permissions

```python
# ✅ Use Temp_Folder's default location (uses system temp)
with Temp_Folder() as folder:
    pass  # Uses /tmp on Linux, appropriate location on Windows

# ❌ Avoid hardcoded paths
with Temp_Folder(parent_folder='/my/local/path') as folder:
    pass  # May not exist on CI
```

---

## Summary Checklist

When using Temp utilities in tests:

**General:**
- [ ] Always use `with` statement (context manager pattern)
- [ ] Don't store references to temp resources outside their context
- [ ] Nest contexts for complex scenarios (cleanup is automatic)
- [ ] Use default random names for parallel test safety

**Temp_File:**
- [ ] Use `contents` parameter for initial content
- [ ] Use `extension` for file type (without dot: `'json'` not `'.json'`)
- [ ] Use `return_file_path=True` when you only need the path string
- [ ] Use `write()` to update contents, `contents()` to read

**Temp_Folder:**
- [ ] Use `temp_files_to_add` for quick test data generation
- [ ] Use `files()` for relative paths, `files(show_parent_folder=True)` for absolute
- [ ] Use `add_file()` and `add_folder()` to build structure
- [ ] Set `delete_on_exit=False` for debugging (remember to clean up!)

**Temp_Env_Vars:**
- [ ] Pass `env_vars` as dict: `{'VAR_NAME': 'value'}`
- [ ] Original values automatically restored (including deletion if didn't exist)
- [ ] Works with Type_Safe classes

**Temp_Web_Server:**
- [ ] Let port auto-assign (no port conflicts)
- [ ] Use `wait_for_stop=True` if you need port released immediately
- [ ] Use custom `http_handler` for mock APIs
- [ ] Use `GET()` and `GET_contains()` for simple testing

**Temp_Zip / Temp_Zip_In_Memory:**
- [ ] Use `set_root_folder()` to get relative paths in zip
- [ ] Use `add_file_from_content()` for virtual files (no disk I/O)
- [ ] Use `zip_bytes()` for in-memory operations
- [ ] Use `create_zip_file()` when you need a file on disk
