# Files Utility - LLM Usage Brief

**Version**: v3.59.2  
**Purpose**: Guide for LLMs and developers on using the comprehensive file system utility  
**Location**: `osbot_utils.utils.Files`  
**Repo**: https://github.com/owasp-sbot/OSBot-Utils  
**Install**: `pip install osbot-utils`

---

## What is the Files Utility?

**The Files utility is a comprehensive, battle-tested toolkit that eliminates the friction of file system operations in Python.** It wraps the scattered functionality of `os`, `os.path`, `shutil`, `pathlib`, `tempfile`, `gzip`, `pickle`, and `glob` into a single, consistent, and intuitive API.

Instead of remembering which module has which function, or writing the same boilerplate for the hundredth time, you get simple, readable operations that just work.

### The Problem It Solves

Python's standard library spreads file operations across multiple modules with inconsistent APIs:

```python
# Standard library - scattered and verbose
import os
import os.path
import shutil
import tempfile
from pathlib import Path

# Does this file exist?
os.path.exists(path) and os.path.isfile(path)  # Two calls needed

# Read file contents
with open(path, 'r') as f:
    contents = f.read()

# Create a temp file with content
fd, tmp_path = tempfile.mkstemp('.txt')
os.close(fd)
with open(tmp_path, 'w') as f:
    f.write(contents)

# Get parent folder
os.path.dirname(os.path.abspath(path))

# Copy file, ensuring target folder exists
os.makedirs(os.path.dirname(dest), exist_ok=True)
shutil.copy(src, dest)
```

**With the Files utility:**

```python
from osbot_utils.utils.Files import file_exists, file_contents, file_create, parent_folder, file_copy

# Does this file exist?
file_exists(path)

# Read file contents
contents = file_contents(path)

# Create a temp file with content
tmp_path = file_create(contents=contents, extension='.txt')

# Get parent folder
parent_folder(path)

# Copy file (target folder created automatically)
file_copy(src, dest)
```

### Design Philosophy

1. **One function, one job** — `file_exists()` checks if a file exists. That's it.
2. **Sensible defaults** — `temp_file()` creates a unique temp file. No ceremony required.
3. **Automatic safety** — Copy operations create parent folders. Delete operations check existence first.
4. **Dual API** — Use `Files.method()` class syntax or `function_name()` aliases—your choice.
5. **No surprises** — Functions return useful values (paths created, success booleans) or `None` on failure.

### The Power of the Files Utility

#### 1. Eliminate Boilerplate

```python
# Create a file with content, in a folder that may not exist
file_create_all_parent_folders('/path/to/deep/nested/file.txt')
file_create('/path/to/deep/nested/file.txt', 'content')

# Or even simpler - temp file with content
path = file_create(contents='my data', extension='.json')
```

#### 2. Consistent Return Values

Every function returns something useful:

```python
path = file_create(contents='data')           # Returns: path to created file
path = folder_create('/new/folder')           # Returns: path to folder
success = file_delete('/some/file.txt')       # Returns: True/False
contents = file_contents('/some/file.txt')    # Returns: string or None
```

#### 3. Safe Operations by Default

```python
# Won't crash if file doesn't exist
file_delete('/nonexistent/file.txt')  # Returns False, no exception

# Won't crash if folder already exists
folder_create('/existing/folder')     # Returns path, no exception

# Automatically creates parent folders
file_copy(src, '/new/deep/path/file.txt')  # Creates /new/deep/path/ first
```

#### 4. Rich Content Handling

```python
# Text, bytes, gzip, base64, pickle - all covered
text = file_contents(path)
data = file_bytes(path)
text = file_contents_gz(path)
b64 = file_to_base64(path)
obj = pickle_load_from_file(path)

# Hashing built in
md5 = file_contents_md5(path)
sha = file_contents_sha256(path)
```

#### 5. Powerful File Finding

```python
# Find all Python files recursively
py_files = files_find('**/*.py', recursive=True)

# List files in folder with pattern
configs = files_list('/app/config', pattern='*.yaml')

# Get files without full path (virtual paths)
relative = files_list__virtual_paths('/app/data')
```

---

## Quick Start

### Basic File Operations

```python
from osbot_utils.utils.Files import (
    file_exists, file_contents, file_create, file_delete,
    file_copy, file_name, file_extension
)

# Check and read
if file_exists('/path/to/file.txt'):
    content = file_contents('/path/to/file.txt')

# Create file (returns path)
path = file_create('/path/to/new.txt', 'Hello World')

# Create temp file with content
temp = file_create(contents='temporary data', extension='.tmp')

# Copy and delete
file_copy('/source.txt', '/dest.txt')
file_delete('/source.txt')

# File info
name = file_name('/path/to/file.txt')       # 'file.txt'
ext = file_extension('/path/to/file.txt')   # '.txt'
```

### Basic Folder Operations

```python
from osbot_utils.utils.Files import (
    folder_exists, folder_create, folder_delete, folder_delete_all,
    files_list, parent_folder
)

# Create folder (returns path)
folder_create('/new/folder')

# List files
all_files = files_list('/my/folder')
py_files = files_list('/my/folder', pattern='*.py')

# Get parent
parent = parent_folder('/path/to/file.txt')  # '/path/to'

# Delete (empty folder only)
folder_delete('/empty/folder')

# Delete recursively (CAREFUL!)
folder_delete_all('/folder/with/contents')
```

### Temp Files and Folders

```python
from osbot_utils.utils.Files import (
    temp_file, temp_folder, temp_folder_current
)

# Create temp file (returns path)
tmp = temp_file()                            # /tmp/xxxxx.tmp
tmp = temp_file(extension='.json')           # /tmp/xxxxx.json
tmp = temp_file(contents='data')             # Creates with content

# Create temp folder (returns path)
tmp_dir = temp_folder()                      # /tmp/xxxxx
tmp_dir = temp_folder(prefix='myapp_')       # /tmp/myapp_xxxxx

# Get system temp folder
sys_tmp = temp_folder_current()              # /tmp (or platform equivalent)
```

---

## Import Reference

### Function Aliases (Recommended)

```python
# File operations
from osbot_utils.utils.Files import (
    file_exists, file_not_exists,
    file_contents, file_contents_gz, file_bytes,
    file_create, file_create_gz, file_create_bytes,
    file_delete, file_copy, file_move,
    file_name, file_extension, file_size, file_stats,
    file_lines, file_lines_gz,
    file_to_base64, file_from_base64,
    file_contents_md5, file_contents_sha256,
)

# Folder operations
from osbot_utils.utils.Files import (
    folder_exists, folder_not_exists,
    folder_create, folder_delete, folder_delete_all,
    folder_copy, folder_name,
    folders_in_folder, folders_recursive,
)

# Path operations
from osbot_utils.utils.Files import (
    path_combine, path_combine_safe,
    parent_folder, parent_folder_create,
    absolute_path, current_folder,
)

# File finding
from osbot_utils.utils.Files import (
    files_list, files_find, files_recursive,
    files_names, files_in_folder,
)

# Temp operations
from osbot_utils.utils.Files import (
    temp_file, temp_folder, temp_filename,
    temp_folder_current,
)

# Pickle operations
from osbot_utils.utils.Files import (
    pickle_save_to_file, pickle_load_from_file,
)

# Safety utilities
from osbot_utils.utils.Files import (
    safe_file_name, is_file, is_folder,
)
```

### Class-Based API

```python
from osbot_utils.utils.Files import Files

# Same operations via class
Files.exists(path)
Files.contents(path)
Files.write(path, contents)
Files.delete(path)
Files.copy(src, dest)
Files.folder_create(path)
Files.temp_file(extension='.json')
```

---

## API Reference by Category

### File Existence & Info

| Function | Description | Returns |
|----------|-------------|---------|
| `file_exists(path)` | Check if file exists | `bool` |
| `file_not_exists(path)` | Check if file doesn't exist | `bool` |
| `file_size(path)` | Get file size in bytes | `int` |
| `file_stats(path)` | Get full file stats | `os.stat_result` |
| `file_name(path)` | Get filename from path | `str` - `'file.txt'` |
| `file_extension(path)` | Get extension | `str` - `'.txt'` |
| `file_name_without_extension(path)` | Get name without ext | `str` - `'file'` |
| `is_file(path)` | Check if path is a file | `bool` |

### File Reading

| Function | Description | Returns |
|----------|-------------|---------|
| `file_contents(path)` | Read file as text | `str` or `None` |
| `file_contents_gz(path)` | Read gzip file as text | `str` or `None` |
| `file_bytes(path)` | Read file as bytes | `bytes` |
| `file_lines(path)` | Iterate lines (generator) | `Generator[str]` |
| `file_lines_gz(path)` | Iterate gzip lines | `Generator[str]` |
| `file_contains(path, content)` | Check if file contains text | `bool` |

### File Writing

| Function | Description | Returns |
|----------|-------------|---------|
| `file_create(path, contents)` | Create/overwrite file | `str` - path |
| `file_create(contents=x, extension=y)` | Create temp file | `str` - path |
| `file_create_bytes(path, bytes)` | Write bytes to file | `str` - path |
| `file_create_gz(path, contents)` | Write gzip file | `str` - path |
| `file_write(path, contents)` | Alias for file_create | `str` - path |

### File Operations

| Function | Description | Returns |
|----------|-------------|---------|
| `file_copy(src, dest)` | Copy file | `str` - dest path |
| `file_move(src, dest)` | Move file | `bool` |
| `file_delete(path)` | Delete file | `bool` |

### File Encoding

| Function | Description | Returns |
|----------|-------------|---------|
| `file_to_base64(path)` | Encode file to base64 | `str` |
| `file_from_base64(b64, path)` | Decode base64 to file | `str` - path |
| `file_contents_md5(path)` | Get MD5 hash | `str` |
| `file_contents_sha256(path)` | Get SHA256 hash | `str` |
| `pickle_save_to_file(obj, path)` | Pickle object to file | `str` - path |
| `pickle_load_from_file(path)` | Load pickled object | `object` |

### Folder Existence & Info

| Function | Description | Returns |
|----------|-------------|---------|
| `folder_exists(path)` | Check if folder exists | `bool` |
| `folder_not_exists(path)` | Check if folder doesn't exist | `bool` |
| `folder_name(path)` | Get folder name | `str` |
| `is_folder(path)` | Check if path is folder | `bool` |

### Folder Operations

| Function | Description | Returns |
|----------|-------------|---------|
| `folder_create(path)` | Create folder (with parents) | `str` - path |
| `folder_delete(path)` | Delete empty folder | `bool` |
| `folder_delete_all(path)` | Delete folder recursively | `bool` |
| `folder_copy(src, dest)` | Copy folder tree | `str` - dest path |
| `folder_copy(src, dest, ignore_pattern='*.pyc')` | Copy with exclusions | `str` - dest path |

### Folder Listing

| Function | Description | Returns |
|----------|-------------|---------|
| `files_list(path)` | List files in folder | `List[str]` |
| `files_list(path, pattern='*.py')` | List with pattern | `List[str]` |
| `files_in_folder(path)` | List files (non-recursive) | `List[str]` |
| `files_recursive(path)` | List all files recursively | `List[str]` |
| `folders_in_folder(path)` | List subfolders | `List[str]` |
| `folders_recursive(path)` | List all folders recursively | `List[str]` |

### Path Operations

| Function | Description | Returns |
|----------|-------------|---------|
| `path_combine(base, sub)` | Join paths safely | `str` |
| `path_combine_safe(base, sub)` | Join with traversal protection | `str` or `None` |
| `parent_folder(path)` | Get parent directory | `str` |
| `parent_folder_create(path)` | Create parent directory | `str` |
| `absolute_path(path)` | Get absolute path | `str` |
| `current_folder()` | Get current directory | `str` |

### Temp Files & Folders

| Function | Description | Returns |
|----------|-------------|---------|
| `temp_file()` | Create temp file | `str` - path |
| `temp_file(extension='.json')` | With extension | `str` - path |
| `temp_file(contents='data')` | With content | `str` - path |
| `temp_folder()` | Create temp folder | `str` - path |
| `temp_folder(prefix='app_')` | With prefix | `str` - path |
| `temp_folder_current()` | Get system temp dir | `str` |
| `temp_filename()` | Generate temp filename | `str` |

### File Finding

| Function | Description | Returns |
|----------|-------------|---------|
| `files_find(pattern)` | Glob pattern search | `List[str]` |
| `files_find('**/*.py', recursive=True)` | Recursive glob | `List[str]` |

### Safety Utilities

| Function | Description | Returns |
|----------|-------------|---------|
| `safe_file_name(name)` | Sanitize filename | `str` |
| `file_extension_fix(ext)` | Ensure extension has dot | `str` |
| `file_create_all_parent_folders(path)` | Create all parents | `str` - parent path |

---

## Usage Patterns

### Pattern 1: Read, Process, Write

```python
from osbot_utils.utils.Files import file_contents, file_create, file_exists

def process_config(input_path, output_path):
    if not file_exists(input_path):
        return None
    
    # Read
    content = file_contents(input_path)
    
    # Process
    processed = content.upper()
    
    # Write (creates parent folders automatically via copy if needed)
    return file_create(output_path, processed)
```

### Pattern 2: Safe Temp File Workflow

```python
from osbot_utils.utils.Files import temp_file, file_contents, file_delete

def safe_transform(data):
    # Create temp file with data
    tmp = temp_file(contents=data, extension='.json')
    
    try:
        # Do something with temp file
        result = external_tool_process(tmp)
        return result
    finally:
        # Cleanup
        file_delete(tmp)
```

### Pattern 3: Batch File Processing

```python
from osbot_utils.utils.Files import files_list, file_contents, file_create, parent_folder

def convert_all_markdown(source_dir, dest_dir):
    md_files = files_list(source_dir, pattern='*.md')
    
    for md_file in md_files:
        content = file_contents(md_file)
        html = markdown_to_html(content)
        
        # Preserve relative structure
        relative = md_file.replace(source_dir, '')
        dest = path_combine(dest_dir, relative.replace('.md', '.html'))
        
        file_create(dest, html)
```

### Pattern 4: Finding and Filtering Files

```python
from osbot_utils.utils.Files import files_find, file_size, file_contents_md5

# Find all Python files
py_files = files_find('**/*.py', recursive=True)

# Filter by size (> 10KB)
large_files = [f for f in py_files if file_size(f) > 10240]

# Find duplicates by hash
hashes = {}
for f in py_files:
    h = file_contents_md5(f)
    hashes.setdefault(h, []).append(f)

duplicates = {h: files for h, files in hashes.items() if len(files) > 1}
```

### Pattern 5: Working with Gzip Files

```python
from osbot_utils.utils.Files import file_create_gz, file_contents_gz, file_lines_gz

# Write compressed
file_create_gz('/logs/app.log.gz', log_content)

# Read compressed
content = file_contents_gz('/logs/app.log.gz')

# Stream large compressed files
for line in file_lines_gz('/logs/huge.log.gz'):
    process_log_line(line)
```

### Pattern 6: Safe Path Handling (Prevent Directory Traversal)

```python
from osbot_utils.utils.Files import path_combine_safe

def serve_file(base_dir, user_requested_path):
    # Safe: prevents ../../../etc/passwd attacks
    safe_path = path_combine_safe(base_dir, user_requested_path)
    
    if safe_path is None:
        raise SecurityError("Invalid path")
    
    return file_contents(safe_path)
```

### Pattern 7: File Hashing and Integrity

```python
from osbot_utils.utils.Files import file_contents_md5, file_contents_sha256, file_exists

def verify_download(path, expected_sha256):
    if not file_exists(path):
        return False
    
    actual = file_contents_sha256(path)
    return actual == expected_sha256

def get_file_fingerprint(path):
    return {
        'md5': file_contents_md5(path),
        'sha256': file_contents_sha256(path),
        'size': file_size(path),
    }
```

### Pattern 8: Pickle Serialization

```python
from osbot_utils.utils.Files import pickle_save_to_file, pickle_load_from_file

# Save complex object
model = train_ml_model(data)
path = pickle_save_to_file(model, '/models/trained_v1.pickle')

# Load later
loaded_model = pickle_load_from_file('/models/trained_v1.pickle')
predictions = loaded_model.predict(new_data)
```

### Pattern 9: Base64 Encoding for APIs

```python
from osbot_utils.utils.Files import file_to_base64, file_from_base64

# Encode file for JSON API
image_b64 = file_to_base64('/images/photo.png')
api_request = {'image': image_b64, 'format': 'png'}

# Decode received file
received_b64 = api_response['document']
path = file_from_base64(received_b64, extension='.pdf')
```

### Pattern 10: Folder Tree Operations

```python
from osbot_utils.utils.Files import (
    folder_create, folder_copy, folder_delete_all,
    folders_recursive, files_recursive
)

# Create project structure
for folder in ['src', 'tests', 'docs', 'config']:
    folder_create(f'/project/{folder}')

# Clone folder tree (excluding patterns)
folder_copy('/template', '/new_project', ignore_pattern=['*.pyc', '__pycache__'])

# Get full inventory
all_folders = folders_recursive('/project')
all_files = files_recursive('/project')

# Clean up
folder_delete_all('/project/build')
```

---

## Common Recipes

### Recipe: Create File with Parent Folders

```python
from osbot_utils.utils.Files import file_create_all_parent_folders, file_create

path = '/deep/nested/path/that/may/not/exist/file.txt'
file_create_all_parent_folders(path)
file_create(path, 'content')
```

### Recipe: Read JSON/YAML Config

```python
import json
from osbot_utils.utils.Files import file_contents, file_exists

def load_config(path):
    if not file_exists(path):
        return {}
    return json.loads(file_contents(path))
```

### Recipe: Atomic Write (via Temp File)

```python
from osbot_utils.utils.Files import temp_file, file_copy, file_delete

def atomic_write(path, content):
    """Write atomically - either succeeds completely or not at all."""
    tmp = temp_file(contents=content)
    try:
        file_copy(tmp, path)
    finally:
        file_delete(tmp)
```

### Recipe: Get All Files with Extension

```python
from osbot_utils.utils.Files import files_list

# In single folder
python_files = files_list('/src', pattern='*.py')

# Recursive
from osbot_utils.utils.Files import files_find
all_python = files_find('/project/**/*.py', recursive=True)
```

### Recipe: Compare Two Files

```python
from osbot_utils.utils.Files import file_contents_sha256

def files_identical(path1, path2):
    return file_contents_sha256(path1) == file_contents_sha256(path2)
```

### Recipe: Safe Filename from User Input

```python
from osbot_utils.utils.Files import safe_file_name, path_combine

def save_user_upload(user_filename, content, upload_dir):
    safe_name = safe_file_name(user_filename)  # Removes dangerous chars
    path = path_combine(upload_dir, safe_name)
    return file_create(path, content)
```

---

## Best Practices

### DO: Use Existence Checks

```python
# ✅ Good - check before read
if file_exists(path):
    content = file_contents(path)

# ✅ Good - file_contents returns None if not exists
content = file_contents(path)
if content is not None:
    process(content)
```

### DO: Use Temp Files for Intermediate Results

```python
# ✅ Good - use temp for scratch work
tmp = temp_file(extension='.json')
# ... work with tmp ...
file_delete(tmp)

# ✅ Good - let system choose location
tmp = temp_file()  # Uses system temp dir
```

### DO: Use path_combine for Path Building

```python
# ✅ Good - handles separators correctly
full_path = path_combine(base_dir, 'subdir', 'file.txt')

# ❌ Bad - manual string concatenation
full_path = base_dir + '/' + 'subdir' + '/' + 'file.txt'
```

### DO: Use path_combine_safe for User Input

```python
# ✅ Good - prevents directory traversal
safe = path_combine_safe('/uploads', user_input)
if safe:
    return file_contents(safe)

# ❌ Dangerous - user could pass '../../../etc/passwd'
path = path_combine('/uploads', user_input)
```

### DON'T: Assume Folder Exists

```python
# ❌ Bad - may fail if folder doesn't exist
file_create('/new/path/file.txt', content)

# ✅ Good - ensure parent exists
file_create_all_parent_folders('/new/path/file.txt')
file_create('/new/path/file.txt', content)
```

### DON'T: Use folder_delete_all Carelessly

```python
# ❌ DANGEROUS - deletes everything recursively!
folder_delete_all(user_provided_path)

# ✅ Safer - validate path first
if path.startswith('/safe/prefix/') and folder_exists(path):
    folder_delete_all(path)
```

### DON'T: Ignore Return Values

```python
# ❌ Bad - ignoring failure
file_delete(path)

# ✅ Good - check result
if not file_delete(path):
    logger.warning(f"Could not delete {path}")
```

---

## Troubleshooting

### Problem: file_contents Returns None

**Cause 1**: File doesn't exist
```python
# Check first
if file_exists(path):
    content = file_contents(path)
```

**Cause 2**: Path is actually a folder
```python
# Verify it's a file
if is_file(path):
    content = file_contents(path)
```

### Problem: file_create Fails

**Cause**: Parent folder doesn't exist
```python
# Solution: create parents first
file_create_all_parent_folders(path)
file_create(path, contents)
```

### Problem: Permission Denied

**Cause**: Insufficient permissions
```python
# Check if writable location
import os
if os.access(parent_folder(path), os.W_OK):
    file_create(path, contents)
else:
    # Use temp location instead
    path = temp_file(contents=contents)
```

### Problem: folder_delete Returns False

**Cause**: Folder is not empty
```python
# Use recursive delete for non-empty folders
folder_delete_all(path)  # CAREFUL - deletes everything!
```

### Problem: files_find Returns Empty

**Cause 1**: Pattern syntax wrong
```python
# ✅ Correct recursive pattern
files_find('**/*.py', recursive=True)

# ❌ Wrong - missing recursive flag
files_find('**/*.py')  # recursive=False by default for some patterns
```

**Cause 2**: Path doesn't exist
```python
# Verify base path
if folder_exists('/search/path'):
    results = files_find('/search/path/**/*.py', recursive=True)
```

### Problem: Encoding Errors Reading Files

**Cause**: File is binary or different encoding
```python
# For binary files
data = file_bytes(path)

# For specific encoding
with open(path, 'r', encoding='utf-8') as f:
    content = f.read()
```

---

## Function Alias Quick Reference

The module provides multiple aliases for common operations. Use whichever reads best:

| Alias | Same As | Purpose |
|-------|---------|---------|
| `file_create` | `Files.write` | Create/write file |
| `file_contents` | `Files.contents` | Read file text |
| `file_bytes` | `Files.bytes` | Read file bytes |
| `create_folder` | `folder_create` | Create folder |
| `folder_delete_recursively` | `folder_delete_all` | Delete folder tree |
| `load_file` | `file_contents` | Read file |
| `save_string_as_file` | `Files.save` | Write string to file |
| `bytes_to_file` | `Files.write_bytes` | Write bytes to file |
| `path_append` | `path_combine` | Join paths |
| `find_files` | `files_list` | List files |

---

## Summary Checklist

When working with files in OSBot-Utils:

- [ ] Import from `osbot_utils.utils.Files`
- [ ] Use function aliases (`file_exists`, `file_contents`) for readability
- [ ] Check existence before reading: `file_exists()` or handle `None` return
- [ ] Use `temp_file()` and `temp_folder()` for scratch work
- [ ] Use `path_combine()` instead of string concatenation
- [ ] Use `path_combine_safe()` for user-provided paths
- [ ] Use `file_create_all_parent_folders()` before creating files in new paths
- [ ] Use `folder_delete_all()` carefully—it's recursive!
- [ ] Use `safe_file_name()` for user-provided filenames
- [ ] Remember: most functions return the path on success, making chaining easy
- [ ] For gzip: `file_create_gz()`, `file_contents_gz()`, `file_lines_gz()`
- [ ] For hashing: `file_contents_md5()`, `file_contents_sha256()`
- [ ] For encoding: `file_to_base64()`, `file_from_base64()`
- [ ] For serialization: `pickle_save_to_file()`, `pickle_load_from_file()`
