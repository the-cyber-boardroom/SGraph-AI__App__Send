# @type_safe Decorator: Comprehensive Guide for LLMs

- **version**: v3.63.3
- **updated**: January 2026
- **prerequisite**: Familiarity with the main Type_Safe & Python Formatting Guide

---

## Why the @type_safe Decorator Exists

### The Problem: Python Methods Have No Runtime Type Checking

Python's type hints for function parameters and return values are **completely ignored at runtime**. They're just documentation for static analyzers like mypy or PyCharm—Python itself never checks them:

```python
from typing import List, Dict

def process_user(user_id: str, age: int, tags: List[str]) -> Dict[str, int]:
    # Python allows ALL of these - type hints are IGNORED
    pass

# These all execute without error - Python doesn't care about types!
process_user(12345, "not an int", [1, 2, 3])     # ✗ Wrong types everywhere
process_user(None, None, None)                   # ✗ All None
process_user({"wrong": "type"}, [], "string")   # ✗ Completely wrong

# Even the return type is ignored
def get_count() -> int:
    return "not an int"                          # ✗ No error! Returns wrong type

result = get_count()
print(result + 1)                                # ✗ TypeError HERE, far from source
```

This leads to:
- **Silent failures**: Wrong types flow through your system undetected
- **Delayed errors**: Crashes occur far from where bad data entered
- **Debugging nightmares**: "Where did this None come from?"
- **Security vulnerabilities**: Unchecked input reaches sensitive operations
- **Contract violations**: Functions return wrong types, breaking callers
- **False confidence**: Type hints suggest safety that doesn't exist

### The Real-World Impact

```python
# A typical bug cascade without runtime checking

def fetch_user(user_id: str) -> User:
    # Someone passes int instead of str
    return db.query(f"SELECT * FROM users WHERE id = {user_id}")

def get_user_name(user: User) -> str:
    return user.name                             # AttributeError: 'NoneType' has no attribute 'name'

def format_greeting(name: str) -> str:
    return f"Hello, {name}!"

# The call chain
user_id = 12345                                  # ✗ Should be "12345" 
user = fetch_user(user_id)                       # SQL injection AND wrong type
name = get_user_name(user)                       # Crashes HERE
greeting = format_greeting(name)                 # Never reached

# The error message says "NoneType has no attribute 'name'"
# But the actual bug was passing int instead of str THREE calls earlier!
```

### The Solution: @type_safe Decorator

The `@type_safe` decorator provides **runtime type enforcement** for both **parameters** and **return values**:

```python
from osbot_utils.type_safe.type_safe_core.decorators.type_safe import type_safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

@type_safe
def process_user(user_id: Safe_Id, age: int, active: bool) -> str:
    return f"User {user_id}, age {age}, active={active}"

# Runtime validation catches errors IMMEDIATELY
process_user(Safe_Id("usr-123"), 25, True)       # ✓ Valid
process_user("usr-123", 25, True)                # ✓ Auto-converts to Safe_Id
process_user(12345, 25, True)                    # ✗ ValueError: Expected 'Safe_Id', but got 'int'
process_user(Safe_Id("usr-123"), "25", True)     # ✗ ValueError: Expected 'int', but got 'str'

# Return type is also validated
@type_safe
def get_status() -> int:
    return "not an int"                          # ✗ TypeError: return type validation failed
```

### Key Capabilities

| Capability | Python Default | @type_safe |
|------------|----------------|------------|
| Parameter type checking | ❌ None | ✓ Every call |
| Return type checking | ❌ None | ✓ Every non-None return |
| Auto-conversion to Safe_* | ❌ None | ✓ Parameters & returns |
| List/Dict element validation | ❌ None | ✓ Validates each element |
| Optional via `= None` default | ❌ None | ✓ Full support |
| Clear error messages | ❌ Generic errors | ✓ Names parameter, expected vs got |
| Callable validation | ❌ None | ✓ Checks List[Callable] |
| Collection auto-conversion | ❌ None | ✓ list→Type_Safe__List on return |

### The Two-Phase Validation

The `@type_safe` decorator validates at **two critical points**:

```python
@type_safe
def transform(data: List[str]) -> Dict[str, int]:
    #         ↑                    ↑
    #    PHASE 1: Call-time    PHASE 2: Return-time
    #    - All parameters      - Return value matches annotation
    #    - Each list element   - Auto-converts if needed
    #    - Union matching      - Validates constraints
    
    result = {}
    for item in data:
        result[item] = len(item)
    return result                                # Validated here!
```

---

## Call-Time Validation

### Basic Type Validation

Every parameter is checked against its annotation:

```python
from osbot_utils.type_safe.type_safe_core.decorators.type_safe import type_safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

@type_safe
def basic_method(param: Safe_Id, number: int) -> str:
    return f"{param}-{number}"

# Valid calls
basic_method(Safe_Id("test"), 42)                # ✓ Exact types
basic_method("test_id", 42)                      # ✓ Auto-converts str to Safe_Id

# Invalid calls - caught immediately
basic_method(b"bytes", 42)                       
# ✗ ValueError: Parameter 'param' expected type <class 'Safe_Id'>, but got <class 'bytes'>

basic_method(Safe_Id("test"), "not_int")
# ✗ ValueError: Parameter 'number' expected type <class 'int'>, but got <class 'str'>
```

### Union Types

Parameters accepting multiple types use `Union`:

```python
from typing import Union
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid import Random_Guid

@type_safe
def handle_identifier(param: Union[Safe_Id, Random_Guid]) -> str:
    if isinstance(param, Safe_Id):
        return f"Safe_Id: {param}"
    return f"Random_Guid: {param}"

# Either type is valid
handle_identifier(Safe_Id("test"))               # ✓ "Safe_Id: test"
handle_identifier(Random_Guid())                 # ✓ "Random_Guid: a4f3c2b1-..."

# Other types rejected
handle_identifier(42)
# ✗ ValueError: Parameter 'param' expected one of types (Safe_Id, Random_Guid), but got <class 'int'>
```

### Optional Parameters (Using Default = None)

A parameter becomes optional by setting `= None` as its default value - **no need for `Optional[T]`**:

```python
@type_safe
def required_param(value: str) -> str:
    return value

@type_safe
def optional_param(value: str = None) -> str:   # = None makes it optional
    return value

# Required parameter rejects None
required_param(None)
# ✗ ValueError: Parameter 'value' is not optional but got None

# Optional parameter accepts None
optional_param(None)                             # ✓ Returns None
optional_param("test")                           # ✓ Returns "test"
```

**Design Philosophy: Don't Use `Optional[T]`**

While `Optional[T]` is supported, the recommended pattern is simply `param: T = None`:

```python
# ✓ RECOMMENDED: Use = None default
@type_safe
def find_user(user_id: Safe_Id = None) -> User:
    if user_id is None:
        return None                              # Not found
    return self.repository.get(user_id)

# ✗ AVOID: Optional[T] is unnecessary verbosity
@type_safe
def find_user(user_id: Optional[Safe_Id] = None) -> Optional[User]:
    # Same behavior, more typing
    pass
```

**Why avoid `Optional`?**
- `None` is a valid response meaning "not found" or "not set"
- It's the **caller's responsibility** to handle `None` appropriately
- The `= None` default clearly signals optionality
- Less verbose, same behavior

### Type[T] Parameters (Class Types)

When a parameter expects a **class** (not an instance), use `Type[T]`:

```python
from typing import Type, Optional

@type_safe
def accept_class(string_class: Optional[Type[str]] = None,
                 int_class   : Optional[Type[int]] = None) -> dict:
    return {'string_class': string_class, 'int_class': int_class}

# Pass actual classes
accept_class(string_class=str)                   # ✓ str is Type[str]
accept_class(string_class=Safe_Id)               # ✓ Safe_Id is subclass of str
accept_class(int_class=int)                      # ✓ int is Type[int]
accept_class(int_class=Timestamp_Now)            # ✓ Timestamp_Now is subclass of int

# Wrong class hierarchies rejected
accept_class(string_class=int)
# ✗ ValueError: Parameter 'string_class' expected Type[str], but int is not a subclass of str

accept_class(int_class=Safe_Id)
# ✗ ValueError: Parameter 'int_class' expected Type[int], but Safe_Id is not a subclass of int
```

### List Element Validation

`List[T]` validates **every element**, not just the list itself:

```python
from typing import List

@type_safe
def process_items(items: List[str]) -> int:
    return len(items)

process_items(['a', 'b', 'c'])                   # ✓ All strings

process_items(['a', 'b', 123])
# ✗ ValueError: List item at index 2 expected type <class 'str'>, but got <class 'int'>
#                                  ↑ Identifies WHICH element failed
```

This is **critical** - Python's type hints don't catch this:

```python
# Without @type_safe - bugs slip through
def unsafe_process(items: List[str]) -> int:
    return len(items)

unsafe_process(['a', 'b', 123])                  # ✗ No error! Bug continues...

# With @type_safe - caught immediately
@type_safe
def safe_process(items: List[str]) -> int:
    return len(items)

safe_process(['a', 'b', 123])                    # ✗ Caught at index 2!
```

### List[Callable] Validation

Special handling for lists of functions:

```python
from typing import List, Callable, Any

@type_safe
def apply_transforms(transformations: List[Callable[[Any], Any]]) -> None:
    pass

# Valid callables
def func1(x): return x
def func2(x): return x * 2

apply_transforms([func1, func2])                 # ✓ Functions
apply_transforms([lambda x: x + 1])              # ✓ Lambdas
apply_transforms([str.upper, str.lower])         # ✓ Built-in methods
apply_transforms([len, abs, round])              # ✓ Built-in functions
apply_transforms([])                             # ✓ Empty list

# Invalid items caught with index
apply_transforms(["not_a_function"])
# ✗ ValueError: List item at index 0 expected callable but got <class 'str'>

apply_transforms([func1, 123])
# ✗ ValueError: List item at index 1 expected callable but got <class 'int'>

apply_transforms([func1, func2, None])
# ✗ ValueError: List item at index 2 expected callable but got <class 'NoneType'>

# Callable class instances work too
class CallableClass:
    def __call__(self, x):
        return x * 2

apply_transforms([CallableClass()])              # ✓ Has __call__

class NonCallable:
    pass

apply_transforms([NonCallable()])
# ✗ ValueError: List item at index 0 expected callable but got <class 'NonCallable'>
```

### Complex Type_Safe Types

Type_Safe classes as parameters get full validation:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class ComplexType(Type_Safe):
    id   : str
    value: int

@type_safe
def process_complex(data: ComplexType) -> str:
    return f"{data.id}-{data.value}"

# Must be actual ComplexType instance
obj = ComplexType(id="test", value=42)
process_complex(obj)                             # ✓ "test-42"

# Dict won't auto-convert for parameters (unlike Type_Safe class fields)
process_complex({"id": "test", "value": 42})
# ✗ ValueError: Parameter 'data' expected type <class 'ComplexType'>, but got <class 'dict'>
```

### Multiple Parameters

All parameters validated in order:

```python
@type_safe
def multi_param(id    : Safe_Id,
                number: int,
                guid  : Random_Guid,
                text  : str) -> str:
    return "success"

# All must be valid
multi_param(Safe_Id("test"), 42, Random_Guid(), "string")  # ✓

# First invalid parameter triggers error
multi_param(Safe_Id("test"), "not_int", Random_Guid(), "string")
# ✗ ValueError: Parameter 'number' expected type <class 'int'>, but got <class 'str'>
```

### Default Values

Default values work normally:

```python
@type_safe
def with_defaults(param: Safe_Id = Safe_Id("default")) -> str:
    return str(param)

with_defaults()                                  # ✓ "default"
with_defaults(Safe_Id("custom"))                 # ✓ "custom"
```

---

## Return-Time Validation

### Basic Return Type Validation

Return values are checked against the annotation:

```python
@type_safe
def return_int() -> int:
    return 42                                    # ✓ Valid

@type_safe
def return_wrong() -> int:
    return "not an int"                          # ✗ Checked here!

return_wrong()
# ✗ TypeError: Function 'return_wrong' return type validation failed: 
#              Expected type <class 'int'>, but got <class 'str'>
```

### Type_Safe Primitive Returns

Primitives are validated AND auto-converted:

```python
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

@type_safe
def return_safe_id() -> Safe_Id:
    return Safe_Id("test")                       # ✓ Already correct type

result = return_safe_id()
assert type(result) is Safe_Id

# String return with Safe_Id annotation - auto-converts!
@type_safe
def return_converted() -> Safe_Id:
    return "will_be_converted"                   # Auto-converts to Safe_Id

result = return_converted()
assert type(result) is Safe_Id                   # ✓ Converted!
assert result == "will_be_converted"
```

### Return Auto-Conversion with Validation

When returning a primitive that should be a Safe_* type, the decorator:
1. Converts to the Safe_* type
2. **Validates constraints** during conversion

```python
from osbot_utils.type_safe.primitives.core.Safe_UInt import Safe_UInt

@type_safe
def returns_safe_uint() -> Safe_UInt:
    return 42                                    # int → Safe_UInt

result = returns_safe_uint()
assert isinstance(result, Safe_UInt)             # ✓ Converted
assert result == 42

# Constraint validation happens during conversion!
@type_safe
def returns_negative() -> Safe_UInt:
    return -1                                    # int → Safe_UInt (fails!)

returns_negative()
# ✗ ValueError: Safe_UInt must be >= 0, got -1
#   The Safe_UInt constraint is enforced even though we returned plain int
```

### Optional Return Types

Returning `None` is **always allowed**, regardless of whether the return type includes `Optional`:

```python
@type_safe
def might_return_none(value: str) -> str:
    return None                                  # ✓ Allowed! None bypasses validation

result = might_return_none("test")
assert result is None                            # ✓ Works

# This is by design: None means "not found" or "no result"
# The caller is responsible for handling None appropriately
```

**Design Philosophy**: Return type validation only applies to **non-None** values. When a function returns `None`, it signals "no result" and the caller must handle it. This avoids forcing unnecessary `Optional[T]` declarations everywhere.

### Union Return Types

`Union` allows returning multiple types:

```python
from typing import Union

@type_safe
def return_union(which: str) -> Union[int, str]:
    return 42 if which == "int" else "hello"

return_union("int")                              # ✓ 42
return_union("str")                              # ✓ "hello"

@type_safe
def return_union_wrong() -> Union[int, str]:
    return []                                    # Neither int nor str

return_union_wrong()
# ✗ TypeError: return type validation failed
```

### List Return Validation

`List[T]` validates every returned element:

```python
from typing import List

@type_safe
def return_list() -> List[int]:
    return [1, 2, 3]                             # ✓ All ints

@type_safe
def return_list_wrong() -> List[int]:
    return [1, "two", 3]                         # ✗ Index 1 is str

return_list_wrong()
# ✗ TypeError: In Type_Safe__List: Invalid type for item: Expected 'int', but got 'str'
```

### Dict Return Validation

`Dict[K, V]` validates all keys AND values:

```python
from typing import Dict

@type_safe
def return_dict() -> Dict[str, int]:
    return {"a": 1, "b": 2}                      # ✓ Valid

@type_safe
def return_dict_wrong_key() -> Dict[str, int]:
    return {1: 1, 2: 2}                          # ✗ Keys should be str

return_dict_wrong_key()
# ✗ TypeError: Expected 'str', but got 'int'

@type_safe
def return_dict_wrong_value() -> Dict[str, int]:
    return {"a": "one", "b": "two"}              # ✗ Values should be int

return_dict_wrong_value()
# ✗ TypeError: Expected 'int', but got 'str'
```

### Inheritance Support

Subclasses are valid when base class is declared:

```python
class Base(Type_Safe):
    name: str

class Derived(Base):
    value: int

@type_safe
def return_base() -> Base:
    return Derived()                             # ✓ Derived IS-A Base

result = return_base()
assert isinstance(result, Base)                  # ✓
assert isinstance(result, Derived)               # ✓ Actual type preserved
```

### Type_Safe Object Returns

Full validation for Type_Safe class returns:

```python
class MyClass(Type_Safe):
    value: str

class OtherClass(Type_Safe):
    number: int

@type_safe
def return_type_safe() -> MyClass:
    return MyClass(value="test")                 # ✓

@type_safe
def return_wrong_class() -> MyClass:
    return OtherClass(number=42)                 # ✗ Wrong class

return_wrong_class()
# ✗ TypeError: return type validation failed
```

---

## Return Value Auto-Conversion

The decorator automatically converts return values to Type_Safe collections when the return type annotation specifies them. This ensures type safety is maintained throughout the call chain.

### List → Type_Safe__List Conversion

```python
from typing import List
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List

@type_safe
def get_items() -> List[str]:
    return ["a", "b", "c"]                       # Plain list

result = get_items()
assert type(result) is Type_Safe__List           # ✓ Auto-converted!
assert result.expected_type is str               # ✓ Type preserved
result.append(123)                               # ✗ TypeError! Now type-safe
```

### Set → Type_Safe__Set Conversion

```python
from typing import Set
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Set import Type_Safe__Set

@type_safe
def get_unique() -> Set[str]:
    return {"a", "b", "c"}                       # Plain set

result = get_unique()
assert type(result) is Type_Safe__Set            # ✓ Auto-converted!
assert result.expected_type is str
result.add(123)                                  # ✗ TypeError! Now type-safe
```

### Dict → Type_Safe__Dict Conversion

```python
from typing import Dict
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict import Type_Safe__Dict

@type_safe
def get_mapping() -> Dict[str, int]:
    return {"a": 1, "b": 2}                      # Plain dict

result = get_mapping()
assert type(result) is Type_Safe__Dict           # ✓ Auto-converted!
assert result.expected_key_type is str
assert result.expected_value_type is int
result["c"] = "not int"                          # ✗ TypeError! Now type-safe
```

### Collection Subclass Returns

When returning a Type_Safe collection subclass, plain collections auto-convert:

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

class Id_List(Type_Safe__List):
    expected_type = Safe_Id

@type_safe
def get_ids() -> Id_List:
    return ["id-1", "id-2", "id-3"]              # Plain list with strings

result = get_ids()
assert type(result) is Id_List                   # ✓ Converted to Id_List!
assert all(isinstance(x, Safe_Id) for x in result)  # ✓ Elements converted!
```

Same for Dict and Set subclasses:

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict import Type_Safe__Dict
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash

class Hash_Mapping(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

@type_safe
def get_hashes() -> Hash_Mapping:
    return {"abc1234567": "value1", "def1234567": "value2"}

result = get_hashes()
assert type(result) is Hash_Mapping              # ✓ Correct subclass
assert all(isinstance(k, Safe_Str__Hash) for k in result.keys())  # ✓ Keys converted
```

---

## Performance Optimizations

### Direct Execution for Simple Methods

The decorator detects methods with no parameters (or only `self`) and bypasses most validation overhead:

```python
@type_safe
def no_params() -> str:
    return "fast"                                # ~5x overhead vs undecorated

@type_safe
def only_self(self) -> str:
    return "fast"                                # ~5x overhead

@type_safe  
def with_params(a: int, b: str) -> str:
    return f"{a}-{b}"                            # Full validation (~overhead varies)
```

The decorator pre-calculates:
- `has_no_params` - No parameters at all
- `has_only_self` - Only `self` parameter
- `direct_execution` - Can skip argument binding

### How It Works

```python
# From the decorator source:
has_only_self    = len(type_checker.params) == 1 and type_checker.params[0] == 'self'
has_no_params    = len(type_checker.params) == 0
direct_execution = has_no_params or has_only_self

# In the wrapper:
if direct_execution:
    result = func(*args, **kwargs)               # Skip validation overhead
else:
    bound_args = type_checker.handle_type_safety(args, kwargs)
    # ... full validation path
```

---

## Error Messages

The decorator provides **clear, actionable error messages**:

### Parameter Errors

```python
@type_safe
def example(user_id: Safe_Id, count: int) -> str:
    return f"{user_id}-{count}"

example(12345, 10)
# ValueError: Parameter 'user_id' expected type <class 'Safe_Id'>, but got <class 'int'>
#             ↑ Names the parameter
#                              ↑ Shows expected type
#                                                       ↑ Shows actual type
```

### List Element Errors

```python
@type_safe
def process(items: List[str]) -> int:
    return len(items)

process(['a', 'b', 123, 'd'])
# ValueError: List item at index 2 expected type <class 'str'>, but got <class 'int'>
#                        ↑ Identifies which element
```

### Return Type Errors

```python
@type_safe
def get_value() -> int:
    return "string"

get_value()
# TypeError: Function 'get_value' return type validation failed: 
#            Expected type <class 'int'>, but got <class 'str'>
#                    ↑ Names the function
```

### Optional/None Errors

```python
@type_safe
def required(param: Safe_Id) -> str:
    return str(param)

required(None)
# ValueError: Parameter 'param' is not optional but got None
```

---

## Best Practices

### 1. Use @type_safe on Public API Methods

```python
class UserService(Type_Safe):
    @type_safe                                   # ✓ Public API - validate
    def create_user(self, name: Safe_Str__Username, 
                          email: Safe_Str__Email) -> User:
        return self._internal_create(name, email)
    
    def _internal_create(self, name, email):     # Private - can skip
        # ... implementation
        pass
```

### 2. Always Annotate Return Types

```python
# ✓ GOOD: Return type enables validation
@type_safe
def get_count() -> int:
    return self.items.count()

# ✗ AVOID: No return validation
@type_safe
def get_count(self):                             # Missing -> int
    return self.items.count()
```

### 3. Use Safe_* Types for Parameters

```python
# ✓ GOOD: Domain-specific validation
@type_safe
def process_order(order_id: Safe_Id, 
                  amount: Safe_Float__Money) -> Receipt:
    pass

# ✗ AVOID: Raw types bypass validation benefits
@type_safe
def process_order(order_id: str, 
                  amount: float) -> Receipt:
    pass
```

### 4. Let Auto-Conversion Work For You

```python
# ✓ GOOD: Return plain list, get Type_Safe__List
@type_safe
def get_items() -> List[Safe_Id]:
    return ["id-1", "id-2", "id-3"]              # Auto-converts!

# ✗ UNNECESSARY: Manual conversion
@type_safe
def get_items() -> List[Safe_Id]:
    result = Type_Safe__List(expected_type=Safe_Id)
    for id in ["id-1", "id-2", "id-3"]:
        result.append(Safe_Id(id))
    return result                                # Redundant!
```

### 5. Use Type[T] for Factory Methods

```python
from typing import Type, TypeVar

T = TypeVar('T', bound=Type_Safe)

class Factory(Type_Safe):
    @type_safe
    def create(self, cls: Type[T], **kwargs) -> T:
        return cls(**kwargs)
```

### 6. Preserve Function Metadata

The decorator uses `@functools.wraps` to preserve docstrings and signatures:

```python
@type_safe
def documented_method(param: Safe_Id) -> str:
    """A test method with documentation."""
    return str(param)

# Preserved!
assert "test method" in documented_method.__doc__

import inspect
sig = inspect.signature(documented_method)
assert 'param' in sig.parameters
```

---

## Common Patterns

### Pattern: Validated Service Methods

```python
class OrderService(Type_Safe):
    repository: Order_Repository
    
    @type_safe
    def create_order(self, customer_id : Safe_Id,
                           items       : List[OrderItem],
                           total       : Safe_Float__Money) -> Order:
        # All parameters validated before we get here
        order = Order(customer_id=customer_id, items=items, total=total)
        return self.repository.save(order)
    
    @type_safe
    def get_order(self, order_id: Safe_Id) -> Optional[Order]:
        return self.repository.find(order_id)
    
    @type_safe
    def list_orders(self, customer_id: Safe_Id,
                          status     : Optional[OrderStatus] = None) -> List[Order]:
        # Returns Type_Safe__List automatically
        return self.repository.find_by_customer(customer_id, status)
```

### Pattern: Validated Data Transformation

```python
@type_safe
def transform_data(raw_input  : Dict[str, Any],
                   validators : List[Callable[[Any], bool]],
                   output_type: Type[Type_Safe]) -> Type_Safe:
    """Transform raw data with validation."""
    # raw_input: validated as dict
    # validators: each element validated as callable
    # output_type: validated as Type_Safe subclass
    
    for validator in validators:
        if not validator(raw_input):
            raise ValueError("Validation failed")
    
    return output_type.from_json(raw_input)
```

### Pattern: Optional Chaining with Validation

```python
@type_safe
def get_user_email(user_id: Safe_Id) -> Safe_Str__Email:
    user = self.find_user(user_id)
    if user is None:
        return None                              # ✓ None always allowed on return
    return user.email                            # ✓ Validated as Safe_Str__Email
```

---

## Import Reference

```python
# The decorator
from osbot_utils.type_safe.type_safe_core.decorators.type_safe import type_safe

# Common parameter types
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id      import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid  import Random_Guid
from osbot_utils.type_safe.primitives.core.Safe_Str                    import Safe_Str
from osbot_utils.type_safe.primitives.core.Safe_Int                    import Safe_Int
from osbot_utils.type_safe.primitives.core.Safe_UInt                   import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Float                  import Safe_Float

# For return type auto-conversion
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List  import Type_Safe__List
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict  import Type_Safe__Dict
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Set   import Type_Safe__Set

# Typing imports for annotations
from typing import List, Dict, Set, Union, Type, Callable, Any
# Note: Optional is supported but not recommended - use `param: T = None` instead
```

---

## Summary Checklist

When using `@type_safe`:

- [ ] Import decorator from `osbot_utils.type_safe.type_safe_core.decorators.type_safe`
- [ ] Add `@type_safe` above method definition
- [ ] Annotate ALL parameters with types
- [ ] Annotate return type with `-> Type`
- [ ] Use `param: T = None` for optional parameters (NOT `Optional[T]`)
- [ ] Don't use `Optional[T]` in return types - None is always allowed
- [ ] Use `Union[A, B]` for multiple acceptable types
- [ ] Use `List[T]` to validate all elements
- [ ] Use `Type[T]` for class/type parameters
- [ ] Use Safe_* types for domain validation
- [ ] Trust auto-conversion for return values
- [ ] Expect clear error messages with parameter names
- [ ] Remember: ~5x overhead for no-param methods, more for validated params
- [ ] Use on public API methods, skip for private helpers if performance critical
- [ ] Caller handles None - it means "not found" or "no result"
