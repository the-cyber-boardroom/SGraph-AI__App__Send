# Type_Safe Capabilities Guide for LLMs

- **version**: v3.63.4
- **updated**: January 2026
- **related**: Python Formatting & Coding Style Guide (v3.63_4__for_llms__python_formatting_guide.md)

---

## Overview

Type_Safe is a runtime type checking framework for Python that enforces type constraints during execution, catching errors at assignment rather than deep in execution. Unlike Python's type hints (which are ignored at runtime), Type_Safe validates every operation, auto-initializes attributes, and provides domain-specific primitive types for common use cases like IDs, money, URLs, and file paths.

**Key capabilities:**
- Runtime type enforcement on every operation
- Auto-initialization of attributes
- Domain-specific safe primitives
- JSON serialization with type preservation
- Collection types with element validation
- Enum support with automatic conversion

---

## Type_Safe Architecture

### Core Classes Hierarchy

Type_Safe has three foundational classes that power the entire system:

1. **Type_Safe__Base** - Core type checking logic
   - Contains `is_instance_of_type()` method
   - Handles type conversions with `try_convert()`
   - Manages Literal, Union, Optional validation

2. **Type_Safe__Primitive** - Base for safe primitive types
   - Extends built-in types (str, int, float)
   - Caches primitive base type in `__primitive_base__`
   - Overrides arithmetic operators to maintain type safety
   - Provides `__to_primitive__()` for serialization

3. **Type_Safe** - Main class for user schemas
   - Inherits from Type_Safe__Base
   - Provides auto-initialization
   - Handles JSON serialization/deserialization
   - Manages attribute type checking via `__setattr__`

---

## Critical Principle: Ban Raw Primitives

**NEVER use raw `str`, `int`, or `float` in Type_Safe classes.** There are very few cases where the full capabilities and range of these primitives are actually needed. Raw primitives enable entire categories of bugs and security vulnerabilities.

### Why Ban Raw Primitives?

```python
# ✗ NEVER DO THIS - Raw primitives are dangerous
class User(Type_Safe):
    name   : str                                             # Can contain SQL injection, XSS, any length
    age    : int                                             # Can overflow, be negative, be 999999
    balance: float                                           # Floating point errors in financial calculations

# ✓ ALWAYS DO THIS - Domain-specific types
class User(Type_Safe):
    name   : Safe_Str__Username                              # Sanitized, length-limited
    age    : Safe_UInt__Age                                  # 0-150 range enforced
    balance: Safe_Float__Money                               # Exact decimal arithmetic
```

Raw primitives have caused major bugs and security issues:
- **String**: SQL injection, XSS, buffer overflows, command injection
- **Integer**: Overflow bugs, negative values where positive expected
- **Float**: Financial calculation errors, precision loss

---

## Type_Safe Core Rules

### 1. Always Inherit from Type_Safe

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Schema__Config(Type_Safe):                             # ✓ CORRECT
    name  : Safe_Str
    count : Safe_UInt

class Config:                                                # ✗ WRONG - Missing Type_Safe
    name: Safe_Str
```

### 2. Type Annotate Everything

```python
class Schema__Config(Type_Safe):
    host        : Safe_Str__Host                             # ✓ Every attribute has type
    port        : Safe_UInt__Port
    ssl_enabled : bool
    endpoints   : List[Safe_Str__Url]                        # ✓ Specific generic types
    
    # ✗ WRONG:
    # host = "localhost"                                     # Missing annotation
    # items: list                                            # Untyped collection
```

### 3. Immutable Defaults Only

```python
class Schema__Settings(Type_Safe):
    name       : Safe_Str                                    # ✓ Auto-initializes to ''
    count      : Safe_UInt                                   # ✓ Auto-initializes to 0
    items      : List[Safe_Str]                              # ✓ Auto-initializes to []
    timeout    : Safe_UInt = 30                              # ✓ Immutable non-default value
    max_retries: Safe_UInt = 3                               # ✓ Immutable non-default value
    
    # ✗ NEVER:
    # items: List[Safe_Str] = []                             # Mutable default ERROR
```

### 4. Forward References = Current Class Only

```python
class Schema__Tree_Node(Type_Safe):
    value  : Safe_Int
    parent : 'Schema__Tree_Node' = None                      # ✓ Same class
    # parent: 'Schema__Other_Node'                           # ✗ Different class
```

### 5. Simplified Default Value Assignment

Type_Safe primitives auto-convert compatible values, so you don't need explicit type constructors for defaults:

```python
# ✗ VERBOSE - Unnecessary explicit construction
class Schema__Ontology(Type_Safe):
    version      : Safe_Str__Version = Safe_Str__Version('1.0.0')
    description  : Safe_Str__Text    = Safe_Str__Text('')
    taxonomy_ref : Taxonomy_Id       = Taxonomy_Id('')

# ✓ SIMPLIFIED - Auto-conversion handles it
class Schema__Ontology(Type_Safe):
    version      : Safe_Str__Version = '1.0.0'               # Auto-converts to Safe_Str__Version
    description  : Safe_Str__Text                            # Empty string is default anyway
    taxonomy_ref : Taxonomy_Id                               # Empty string is default anyway
```

**Key insight**: Safe_Str types default to empty string `''`, Safe_Int/Safe_UInt default to `0`, Safe_Float defaults to `0.0`. Only specify defaults when they differ from these.

### 6. Schemas Must Be Pure Data Containers

**CRITICAL: Schema classes should ONLY contain type annotations - NO methods, NO business logic!**

```python
# ✗ WRONG - Methods in schema
class Schema__Ontology(Type_Safe):
    ontology_id : Ontology_Id
    node_types  : Dict__Node_Types__By_Id
    
    def valid_edge(self, source, verb, target) -> bool:      # NO! Move to helper
        pass
    
    def get_inverse_verb(self, source, verb) -> Safe_Str:    # NO! Move to helper
        pass

# ✓ CORRECT - Schema is pure data
class Schema__Ontology(Type_Safe):
    ontology_id : Ontology_Id
    node_types  : Dict__Node_Types__By_Id

# ✓ CORRECT - Logic in separate helper class
class Ontology__Utils(Type_Safe):
    
    @type_safe
    def valid_edge(self, ontology : Schema__Ontology        ,
                         source   : Node_Type_Id            ,
                         verb     : Safe_Str__Ontology__Verb,
                         target   : Node_Type_Id            ) -> bool:
        pass
```

**Rationale**: Schemas capture data structure. Behavior belongs in service/helper classes. This separation enables clean serialization and maintains single responsibility.

---

## Reserved Method Names

Type_Safe classes have built-in methods that **cannot be used as attribute names**. Using these names as attributes will cause unexpected behavior:

### Methods That Cannot Be Attribute Names

| Method | Purpose | Why It Conflicts |
|--------|---------|------------------|
| `json()` | Serialize to dict | Attribute would shadow serialization |
| `from_json()` | Deserialize from dict | Class method conflict |
| `obj()` | Convert to namespace | Attribute would shadow method |
| `reset()` | Reset to defaults | Attribute would shadow method |
| `print()` | Pretty print | Attribute would shadow method |

```python
# ✗ WRONG - Reserved names as attributes
class Schema__Bad(Type_Safe):
    json     : Safe_Str                                      # Shadows json() method!
    from_json: Safe_Str                                      # Shadows from_json() method!
    obj      : Safe_Str                                      # Shadows obj() method!

# ✓ CORRECT - Use descriptive names
class Schema__Good(Type_Safe):
    json_data    : Safe_Str
    json_source  : Safe_Str
    target_object: Safe_Str
```

### Complete Reserved Names List

These method names are reserved and should never be used as attribute names:
- `json`, `json__compress`, `from_json`, `from_json__compressed`
- `obj`, `reset`, `print`
- `serialize_to_dict`, `update_from_kwargs`
- `__locals__`, `__kwargs__`, `__default_kwargs__`, `__cls_kwargs__`, `__attr_names__`

---

## Method Validation with @type_safe Decorator

The `@type_safe` decorator provides runtime type enforcement for method parameters and return values:

```python
from osbot_utils.type_safe.type_safe_core.decorators.type_safe import type_safe

class Ontology__Registry(Type_Safe):
    cache: Dict__Ontologies__By_Id
    
    @type_safe
    def get(self, ontology_id: Ontology_Id) -> Schema__Ontology:
        return self.cache.get(ontology_id)
    
    @type_safe
    def register(self, ontology: Schema__Ontology) -> None:
        self.cache[ontology.ontology_id] = ontology
```

### @type_safe Capabilities

**Call-Time Validation:**
- Validates all parameter types at runtime
- Union types: `Union[Safe_Id, Random_Guid]`
- Optional via default: `param: Safe_Id = None`
- List element validation: `List[Safe_Str]` checks each element
- Callable validation: `List[Callable[[Any], Any]]`

**Return-Time Validation:**
- Checks return value against annotation
- Auto-converts primitives to Safe_* types
- Collection auto-conversion: `list` → `Type_Safe__List`

**Performance:**
- ~5x overhead for no-parameter methods
- Full validation for methods with parameters
- Pre-calculates optimization flags

**See**: `v3_63_3__for_llms__type_safe__decorator_guide.md` for comprehensive decorator documentation.

---

## Return Values and None

### No Optional Return Types Needed

Returning `None` is **always allowed** regardless of return type annotation:

```python
# ✗ AVOID - Optional is redundant verbosity
@type_safe
def get(self, ontology_id: Ontology_Id) -> Optional[Schema__Ontology]:
    return self.cache.get(ontology_id)

# ✓ CORRECT - None is implicitly valid
@type_safe
def get(self, ontology_id: Ontology_Id) -> Schema__Ontology:
    return self.cache.get(ontology_id)                       # Can return None
```

**Design Philosophy**: `None` means "not found" or "no result" - it's the caller's responsibility to handle it. This avoids verbose `Optional[T]` declarations everywhere.

### Optional Parameters Use Default = None

```python
# ✗ AVOID - Optional[T] is unnecessary
@type_safe
def find(self, id: Optional[Safe_Id] = None) -> Schema__User:
    pass

# ✓ CORRECT - Default = None makes it optional
@type_safe
def find(self, id: Safe_Id = None) -> Schema__User:
    pass
```

---

## Type_Safe Collection Types

Type_Safe provides type-safe versions of Python's built-in collections that validate on **every operation**:

### Type_Safe__List

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List

class Schema__Document(Type_Safe):
    items: List[Safe_Str]                                    # Auto-creates Type_Safe__List

# Direct usage
safe_list = Type_Safe__List(expected_type=Safe_Str)
safe_list.append("test")                                     # ✓ Auto-converts to Safe_Str
safe_list.append(123)                                        # ✗ TypeError!
```

### Type_Safe__Dict

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict import Type_Safe__Dict

class Schema__Inventory(Type_Safe):
    mapping: Dict[Safe_Id, Safe_Float__Money]                # Type-safe dict

# Direct usage
safe_dict = Type_Safe__Dict(expected_key_type=Safe_Id, 
                            expected_value_type=Safe_Float__Money)
safe_dict["ID-1"] = 99.99                                    # ✓ Auto-converts both
safe_dict[123] = "invalid"                                   # ✗ TypeError!
```

### Type_Safe__Set and Type_Safe__Tuple

```python
class Schema__Tags(Type_Safe):
    unique_ids : Set[Safe_Id]                                # Type-safe set
    coordinates: Tuple[Safe_Float, Safe_Float]               # Fixed-type tuple
```

---

## Creating Type_Safe Collection Subclasses

For reusable collection types, create subclasses with class-level type definitions.

### Naming Convention: Prefix with Collection Type

**Always prefix with `Dict__`, `List__`, `Set__`, `Tuple__`**:

```python
# ✓ CORRECT - Collection type prefix
class Dict__Ontologies__By_Id(Type_Safe__Dict):
    expected_key_type   = Ontology_Id
    expected_value_type = Schema__Ontology

class Dict__Node_Types__By_Id(Type_Safe__Dict):
    expected_key_type   = Node_Type_Id
    expected_value_type = Schema__Ontology__Node_Type

class List__Node_Type_Ids(Type_Safe__List):
    expected_type = Node_Type_Id

class Set__Permission__Ids(Type_Safe__Set):
    expected_type = Safe_Id

# ✗ WRONG - No collection type indicator
class Ontologies_By_Id(Type_Safe__Dict): ...                 # What type is this?
class Node_Type_Ids(Type_Safe__List): ...                    # Ambiguous
```

### Collection Subclasses Must Be Pure Type Definitions

**CRITICAL: No methods allowed in collection subclasses!**

```python
# ✓ CORRECT - Pure type definition
class Dict__Ontologies__By_Id(Type_Safe__Dict):
    expected_key_type   = Ontology_Id
    expected_value_type = Schema__Ontology

# ✗ WRONG - Methods in collection subclass
class Dict__Ontologies__By_Id(Type_Safe__Dict):
    expected_key_type   = Ontology_Id
    expected_value_type = Schema__Ontology
    
    def find_by_name(self, name: Safe_Str):                  # NO! Move to helper
        pass
```

### Using Collection Subclasses

```python
class Schema__Document(Type_Safe):
    hashes: Dict__Content__Hashes                            # Auto-initializes, enforces types

# Usage
doc = Schema__Document()
doc.hashes['abc1234567'] = 'Content'                         # Key auto-converts to Safe_Str__Hash
```

### Instantiating Collection Subclasses Directly

Use collection subclasses directly when building data - don't use raw `{}` or `[]`:

```python
# ✗ WRONG - Raw dict/list loses type safety
def parse_ontology(self, data: dict) -> Schema__Ontology:
    node_types = {}                                          # Not type-safe!
    
# ✗ ALSO WRONG - Creating parent object just to get collection
def parse_ontology(self, data: dict) -> Schema__Ontology:
    node_types = Schema__Ontology().node_types               # Wasteful!

# ✓ CORRECT - Instantiate collection subclass directly
def parse_ontology(self, data: dict) -> Schema__Ontology:
    node_types = Dict__Node_Types__By_Id()                   # Direct instantiation
```

**See**: `v3_63_3__for_llms__type_safe__collections__subclassing_guide.md` for comprehensive collection documentation.

---

## Safe_Id vs Semantic_Id Distinction

Understanding when to use auto-generating IDs vs semantic identifiers is critical:

### Safe_Id - Auto-Generates When Empty

```python
# Safe_Id auto-generates random value when None/empty
class Safe_Id(Type_Safe__Primitive, str):
    def __new__(cls, value=None):
        if value is None:
            value = safe_id(random_id_short(prefix='safe-id'))  # Auto-generates!
```

**Use for**: Instance identifiers that need unique values
- `Node_Id`, `Edge_Id`, `Graph_Id`
- Any ID that represents a unique instance

### Semantic_Id - Never Auto-Generates

```python
# Semantic_Id allows empty, NEVER auto-generates
class Semantic_Id(Safe_Str):
    regex           = re.compile(r'[^a-zA-Z0-9_\-.]')
    max_length      = 128
    allow_empty     = True
    trim_whitespace = True
```

**Use for**: Human-readable identifiers that have meaning
- `Ontology_Id`, `Node_Type_Id`, `Taxonomy_Id`
- `Category_Id`, `Rule_Set_Id`
- Any ID that represents a concept, not an instance

### Key Distinction

| Category | Behavior | Use Cases |
|----------|----------|-----------|
| Instance IDs | Auto-generate via `Obj_Id()` | `Node_Id`, `Edge_Id`, `Graph_Id` |
| Semantic IDs | NEVER auto-generate, allow empty | `Ontology_Id`, `Node_Type_Id`, `Taxonomy_Id` |

**Why it matters**: Safe_Id breaks serialization round-trips because new IDs are generated on deserialization.

---

## Enum Support in Type_Safe

Type_Safe has full support for Python Enums with automatic serialization/deserialization:

```python
from enum import Enum
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Enum__LLM__Role(str, Enum):
    SYSTEM    = "system"
    USER      = "user"
    ASSISTANT = "assistant"
    TOOL      = "tool"
    
    def __str__(self):
        return self.value

class Schema__LLM__Message(Type_Safe):
    role    : Enum__LLM__Role
    content : Safe_Str__LLM__Message__User

# Automatic conversion from strings
message = Schema__LLM__Message(role="user", content="Hello")
print(message.role)                                          # Enum__LLM__Role.USER

# JSON serialization preserves enum values
json_data = message.json()                                   # {"role": "user", ...}
restored = Schema__LLM__Message.from_json(json_data)
assert restored.role == Enum__LLM__Role.USER                 # Enum restored!

# Runtime validation
message.role = "invalid"                                     # ✗ ValueError
```

### Using Literal for Quick Enums

For small, fixed sets of values, use `Literal` instead of creating Enum classes:

```python
from typing import Literal

class Schema__Message(Type_Safe):
    role    : Literal["assistant", "system", "user", "tool"]
    priority: Literal["low", "medium", "high"] = "medium"

message = Schema__Message()
message.role = "user"                                        # ✓ Valid
message.role = "admin"                                       # ✗ ValueError
```

---

## Type_Safe Validation Framework

Use `Annotated` types for additional constraints:

```python
from osbot_utils.type_safe.validators.Type_Safe__Validator import Validate
from osbot_utils.type_safe.validators.Validator__Min       import Min
from osbot_utils.type_safe.validators.Validator__Max       import Max
from osbot_utils.type_safe.validators.Validator__One_Of    import One_Of
from osbot_utils.type_safe.validators.Validator__Regex     import Regex

class Schema__User(Type_Safe):
    age      : Validate[Safe_UInt, Min(18), Max(100)]
    priority : Validate[Safe_Str, One_Of(["low", "medium", "high"])]
    code     : Validate[Safe_Str, Regex(r'^[A-Z]{3}-\d{4}$')]
```

---

## Safe Primitives Reference

### Core String Types

| Type | Purpose | Key Features |
|------|---------|--------------|
| `Safe_Str` | Base safe string | max_length=512, regex filtering |
| `Safe_Str__Text` | General text | 4KB, more chars allowed |
| `Safe_Str__Id` | Identifiers | Alphanumeric + underscore + hyphen |

### Domain String Types

**Identifiers** (domains.identifiers.safe_str):
- `Safe_Str__Display_Name` - User-facing names
- `Safe_Str__Key` - Dictionary/config keys (allows dots)
- `Safe_Str__Label` - Hierarchical labels (dots, colons, spaces)
- `Safe_Str__Namespace` - Namespaced identifiers
- `Safe_Str__Slug` - URL-friendly (lowercase, hyphens)

**Files** (domains.files.safe_str):
- `Safe_Str__File__Name` - Safe filenames
- `Safe_Str__File__Path` - File paths

**Web** (domains.web.safe_str):
- `Safe_Str__Url` - URL validation
- `Safe_Str__Email` - Email addresses
- `Safe_Str__Username` - Usernames
- `Safe_Str__API__Parameter` - API param names

**LLM** (domains.llm.safe_str):
- `Safe_Str__LLM__Prompt` - LLM prompts (32KB)
- `Safe_Str__LLM__Message__System/User/Assistant/Tool` - Message types
- `Safe_Str__LLM__Model_Id` - Model identifiers

**Cryptographic** (domains.cryptography.safe_str):
- `Safe_Str__Hash` - 10-char hash
- `Safe_Str__SHA1` - Full SHA1 (40 hex)

### Numeric Types

| Type | Purpose | Features |
|------|---------|----------|
| `Safe_Int` | Base integer | Range validation |
| `Safe_UInt` | Unsigned int | min_value=0 |
| `Safe_UInt__Port` | Network ports | 0-65535 |
| `Safe_Float` | Base float | Precision control |
| `Safe_Float__Money` | Currency | Decimal arithmetic, 2 places |

### Identity Types

| Type | Behavior |
|------|----------|
| `Safe_Id` | Auto-generates if None |
| `Random_Guid` | Always auto-generates UUID |
| `Timestamp_Now` | Auto-captures current time |
| `Obj_Id` | Unique object identifier |

---

## Files and JSON Utility Usage

Always use OSBot-Utils utilities instead of raw Python file/JSON handling:

```python
# ✗ WRONG - Raw Python handling
import json
from pathlib import Path

def load_from_file(self, file_path: str):
    with open(file_path, 'r') as f:
        return json.load(f)

# ✓ CORRECT - Use OSBot-Utils
from osbot_utils.utils.Files import file_exists
from osbot_utils.utils.Json  import json_load_file
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path import Safe_Str__File__Path

def load_from_file(self, file_path: Safe_Str__File__Path) -> Schema__Config:
    if file_exists(file_path) is False:
        return None
    data = json_load_file(file_path)                         # Returns {} on error
    if not data:
        return None
    return Schema__Config.from_json(data)
```

### Json Utility Functions

| Function | Purpose | Returns on Error |
|----------|---------|------------------|
| `json_dumps(obj)` | Serialize to JSON string | `None` |
| `json_loads(json_str)` | Parse JSON string | `{}` |
| `json_load_file(path)` | Load JSON from file | `{}` |
| `json_save_file(data, path)` | Save JSON to file | - |

---

## No Exceptions for Missing Resources

Return `None` instead of raising exceptions for missing resources:

```python
# ✗ WRONG - Exceptions inside methods
def load_from_file(self, file_path: Safe_Str__File__Path) -> Schema__Config:
    if not file_exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

# ✓ CORRECT - Return None, let caller decide
def load_from_file(self, file_path: Safe_Str__File__Path) -> Schema__Config:
    if file_exists(file_path) is False:
        return None
```

**Rationale**: Missing file/resource is not exceptional - it's a valid state. Caller has context to decide appropriate action.

---

## No str() Casts with Type_Safe

Type_Safe handles conversions automatically - never use explicit `str()` casts:

```python
# ✗ WRONG - Unnecessary str() cast
self.cache[str(ontology.ontology_id)] = ontology

# ✓ CORRECT - Type_Safe handles conversions
self.cache[ontology.ontology_id] = ontology
```

---

## Default Values and Auto-initialization

Type_Safe automatically initializes attributes based on their types:

```python
class Schema__Message(Type_Safe):
    content     : Safe_Str                                   # Auto: ''
    count       : Safe_UInt                                  # Auto: 0
    price       : Safe_Float__Money                          # Auto: 0.00
    tags        : List[Safe_Str]                             # Auto: [] (unique instance)
    metadata    : Dict[Safe_Str__Key, Safe_Str__Text]        # Auto: {} (unique instance)
    options     : Schema__Options                            # Auto: Schema__Options()
    parent_id   : Safe_Id = None                             # Explicitly nullable

message = Schema__Message()
print(message.content)                                       # ''
print(message.tags)                                          # []
print(message.parent_id)                                     # None
```

### Auto-Initializing Types

These types generate new values on each instantiation:

```python
class Schema__Response(Type_Safe):
    request_id : Random_Guid                                 # Auto-generates new GUID
    timestamp  : Timestamp_Now                               # Auto-generates current time

response1 = Schema__Response()
response2 = Schema__Response()
# response1.request_id != response2.request_id               # Different values!
```

---

## Type_Safe Methods Reference

### Data Access Methods
- `__locals__()` - Instance's attribute values
- `__kwargs__()` - All attributes including defaults
- `__default_kwargs__()` - Class-level defaults
- `__cls_kwargs__()` - Class variables
- `__attr_names__()` - List of attribute names

### Serialization Methods
- `json()` / `serialize_to_dict()` - Convert to dict
- `json__compress()` - Compressed JSON with type registry
- `from_json(data)` - Deserialize from JSON
- `from_json__compressed(data)` - Deserialize compressed JSON
- `obj()` - Convert to namespace object

### Utility Methods
- `reset()` - Reset all attributes to defaults
- `update_from_kwargs(**kwargs)` - Update multiple attributes
- `print()` - Pretty print the object

---

## Creating Custom Safe Types

### Custom Safe_Str Types

```python
from osbot_utils.type_safe.primitives.core.Safe_Str import Safe_Str
from osbot_utils.type_safe.primitives.core.enums.Enum__Safe_Str__Regex_Mode import Enum__Safe_Str__Regex_Mode
import re

class Safe_Str__Username(Safe_Str):
    max_length      = 20
    regex           = re.compile(r'[^a-zA-Z0-9_]')
    regex_mode      = Enum__Safe_Str__Regex_Mode.REPLACE
    allow_empty     = False

class Safe_Str__API_Key(Safe_Str):
    max_length         = 32
    regex              = re.compile(r'^[A-Z0-9]{32}$')
    regex_mode         = Enum__Safe_Str__Regex_Mode.MATCH
    strict_validation  = True
    exact_length       = True
```

### Custom Safe_Int Types

```python
from osbot_utils.type_safe.primitives.core.Safe_UInt import Safe_UInt

class Safe_UInt__Age(Safe_UInt):
    min_value = 0
    max_value = 150

class Safe_UInt__HTTP_Status(Safe_UInt):
    min_value = 100
    max_value = 599
```

---

## Import Reference

```python
# Core
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.type_safe_core.decorators.type_safe                      import type_safe

# Core Primitives
from osbot_utils.type_safe.primitives.core.Safe_Str                                 import Safe_Str
from osbot_utils.type_safe.primitives.core.Safe_Int                                 import Safe_Int
from osbot_utils.type_safe.primitives.core.Safe_UInt                                import Safe_UInt
from osbot_utils.type_safe.primitives.core.Safe_Float                               import Safe_Float

# Collections
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List               import Type_Safe__List
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict               import Type_Safe__Dict
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Set                import Type_Safe__Set
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Tuple              import Type_Safe__Tuple

# Validators
from osbot_utils.type_safe.validators.Type_Safe__Validator                          import Validate
from osbot_utils.type_safe.validators.Validator__Min                                import Min
from osbot_utils.type_safe.validators.Validator__Max                                import Max

# Identifiers
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id                   import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid               import Random_Guid
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now             import Timestamp_Now

# Domain Types (examples)
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url            import Safe_Str__Url
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Email          import Safe_Str__Email
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path   import Safe_Str__File__Path
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Money import Safe_Float__Money
from osbot_utils.type_safe.primitives.domains.llm.safe_str.Safe_Str__LLM__Prompt    import Safe_Str__LLM__Prompt

# Utilities
from osbot_utils.utils.Files import file_exists
from osbot_utils.utils.Json  import json_load_file, json_loads, json_dumps
```

---

## Related Documentation

> **Note for LLMs**: When working on code that involves any of these areas, request access to the relevant documentation files to ensure best practices are followed. Ask: *"Can you provide the [document name] for reference?"*

### Type Safety Guides

| Document | Purpose | Request When |
|----------|---------|--------------|
| `v3.63.3__for_llms__type_safe__collections__subclassing_guide.md` | Creating Dict__, List__, Set__ subclasses | Defining custom typed collections |
| `v3.63.3__for_llms__type_safe__decorator_guide.md` | @type_safe decorator behavior | Adding runtime validation to methods |
| `v3.63.4__for_llms__python_formatting_guide.md` | Code alignment and style rules | Writing any Type_Safe code |
| `v3.28.0__osbot-utils-safe-primitives__reference-guide.md` | Complete Safe_* primitives catalog | Choosing domain-specific types |
| `v3.1.1__for_llms__type_safe__testing_guidance.md` | Testing patterns for Type_Safe | Writing tests for Type_Safe classes |

### Feature Briefs

| Document | Purpose | Request When |
|----------|---------|--------------|
| `v3.63.4__json-utility__llm-usage-brief.md` | Json utility functions | Working with JSON serialization |
| `v3.59.2__files-utility__llm-usage-brief.md` | Files utility functions | File operations and path handling |
| `v3.59.2__timestamp-capture__llm-usage-brief.md` | Timestamp capture patterns | Working with timestamps |
| `v3.59.2__trace-call__llm-usage-brief.md` | Trace call debugging | Debugging and tracing execution |
| `v3.60.1__performance-measure-session__llm-usage-brief.md` | Performance measurement | Profiling and benchmarking |
| `v3.60.2__type-safe--on-demand__llm_usage_brief.md` | On-demand type safety | Lazy initialization patterns |
| `v3.63.0__ast-helpers__llm-usage-brief.md` | AST manipulation helpers | Code analysis and generation |

---

## Summary Checklist

When writing Type_Safe code:

- [ ] Inherit from Type_Safe
- [ ] Add type annotations for ALL attributes
- [ ] Use only immutable defaults (or none)
- [ ] Use specific generic types (`List[T]`, not `list`)
- [ ] Forward references only to current class
- [ ] Add `@type_safe` to validated methods
- [ ] Use Safe_* types - ban raw primitives
- [ ] Schemas are PURE DATA - no methods
- [ ] Collection subclasses are PURE TYPE DEFINITIONS - no methods
- [ ] Use `Dict__`, `List__`, `Set__` prefixes for collection subclasses
- [ ] Use Enums for fixed sets of values
- [ ] Use Literal for small inline enums
- [ ] Return `None` for not found - no `Optional[T]` needed
- [ ] No `str()` casts - Type_Safe handles conversions
- [ ] No exceptions for missing resources - return `None`
- [ ] Use OSBot-Utils for file/JSON operations
- [ ] Don't shadow reserved method names (`json`, `from_json`, etc.)