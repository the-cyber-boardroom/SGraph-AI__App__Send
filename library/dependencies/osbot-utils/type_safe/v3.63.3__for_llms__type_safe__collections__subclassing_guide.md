# Type_Safe Collections: Subclassing Guide for LLMs

- **version**: v3.63.3
- **updated**: January 2026
- **prerequisite**: Familiarity with the main Type_Safe & Python Formatting Guide

---

## Why Type_Safe Collections Exist

### The Problem: Python Collections Have No Runtime Type Safety

Python's built-in collections (`dict`, `list`, `set`, `tuple`) provide **zero runtime type enforcement**. Type hints like `Dict[str, int]` are completely ignored at runtime—they're just documentation for static analyzers:

```python
from typing import Dict, List

# Python allows this - type hints are IGNORED at runtime
users: Dict[str, int] = {}
users["alice"] = "not an int"      # ✗ No error! Silent corruption
users[123] = 456                   # ✗ No error! Key should be str

items: List[str] = []
items.append(999)                  # ✗ No error! Should be str
items.append(None)                 # ✗ No error! Silent None injection
```

This leads to:
- **Silent data corruption**: Wrong types enter your data structures undetected
- **Delayed failures**: Errors surface far from where bad data was introduced
- **Security vulnerabilities**: Unchecked input flows through your system
- **Debugging nightmares**: "How did a `float` get into my `Dict[str, User]`?"

### The Solution: Type_Safe Collection Classes

The `Type_Safe__Dict`, `Type_Safe__List`, `Type_Safe__Set`, and `Type_Safe__Tuple` classes provide **runtime type enforcement** for every operation:

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict import Type_Safe__Dict
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List

# Type_Safe__Dict enforces types on EVERY operation
safe_dict = Type_Safe__Dict(expected_key_type=str, expected_value_type=int)
safe_dict["alice"] = 42            # ✓ Valid
safe_dict["bob"] = "not an int"    # ✗ TypeError! Caught immediately
safe_dict[123] = 456               # ✗ TypeError! Key must be str

# Type_Safe__List enforces element types
safe_list = Type_Safe__List(expected_type=str)
safe_list.append("valid")          # ✓ Valid
safe_list.append(999)              # ✗ TypeError! Must be str
```

### Key Capabilities of Type_Safe Collections

| Capability | Python Built-in | Type_Safe Collections |
|------------|-----------------|----------------------|
| Runtime type checking | ❌ None | ✓ Every operation |
| Auto-conversion | ❌ None | ✓ `"123"` → `Safe_Id("123")` |
| Validation on insert | ❌ None | ✓ Invalid data rejected |
| Works with Type_Safe classes | ❌ Loses type info | ✓ Full integration |
| JSON serialization | ❌ Manual | ✓ Automatic with type preservation |
| Subclass type preservation | N/A | ✓ `copy()`, `|` return subclass |

### How Type_Safe Classes Already Use These Collections

When you use `Dict`, `List`, `Set`, or `Tuple` annotations in a `Type_Safe` class, the framework **automatically converts** them to their Type_Safe equivalents during construction:

```python
from typing                                      import Dict, List, Set
from osbot_utils.type_safe.Type_Safe             import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id import Obj_Id

class Ontology__Registry(Type_Safe):
    cache   : Dict[Obj_Id, Schema__Ontology]     # Auto-converts to Type_Safe__Dict
    items   : List[str]                          # Auto-converts to Type_Safe__List
    tags    : Set[str]                           # Auto-converts to Type_Safe__Set

# At runtime, Type_Safe converts the annotations automatically
registry = Ontology__Registry()

# The actual types are Type_Safe collections, not Python built-ins
assert type(registry.cache) is Type_Safe__Dict   # ✓ Runtime type is Type_Safe__Dict
assert type(registry.items) is Type_Safe__List   # ✓ Runtime type is Type_Safe__List
assert type(registry.tags)  is Type_Safe__Set    # ✓ Runtime type is Type_Safe__Set

# Full type enforcement is active
registry.cache[Obj_Id()] = Schema__Ontology()    # ✓ Valid
registry.cache["wrong"] = "bad"                  # ✗ TypeError! Key must be Obj_Id
```

This automatic conversion gives you **all the runtime type safety benefits** without any extra code. The Type_Safe constructor handles the conversion transparently.

### Limitations of Inline Annotations

While the auto-conversion works great, there are practical limitations:

**1. IDE Type Mismatch**: PyCharm/VS Code see the annotation type, not the runtime type:

```python
class Ontology__Registry(Type_Safe):
    cache : Dict[Obj_Id, Schema__Ontology]       # IDE sees Dict

def test__init__(self):
    with Ontology__Registry() as _:
        assert type(_.cache) is Type_Safe__Dict  # ✓ Passes at runtime
        
        # But in PyCharm:
        # _.cache is shown as Dict[Obj_Id, Schema__Ontology]
        # Not as Type_Safe__Dict
        # This causes false "type mismatch" warnings
```

**2. Repetition**: The same type combination must be repeated everywhere:

```python
class Service_A(Type_Safe):
    cache : Dict[Obj_Id, Schema__Ontology]       # Repeated

class Service_B(Type_Safe):
    cache : Dict[Obj_Id, Schema__Ontology]       # Repeated again

class Service_C(Type_Safe):
    cache : Dict[Obj_Id, Schema__Ontology]       # And again...

# If the value type changes, you must update ALL locations
```

**3. No Semantic Naming**: The type doesn't describe what it represents:

```python
cache : Dict[Obj_Id, Schema__Ontology]           # What kind of cache? For what?
# vs
cache : Ontology_Cache                           # Self-documenting
```

### Why Subclassing Takes It Further

While you can use `Type_Safe__Dict` directly with constructor parameters, **subclassing** solves all the limitations above:

```python
# ❌ REPETITIVE: Passing type parameters everywhere
def process_hashes(data: Type_Safe__Dict) -> Type_Safe__Dict:
    result = Type_Safe__Dict(expected_key_type=Safe_Str__Hash, 
                             expected_value_type=str)
    # ... more code creating the same type ...
    return result

# ✓ CLEAN: Define once, use everywhere
class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

def process_hashes(data: Dict__Content__Hashes) -> Dict__Content__Hashes:
    result = Dict__Content__Hashes()              # No parameters needed
    # ... cleaner code ...
    return result
```

Subclassing enables:
- **Named domain types**: `Dict__Users__By_Id`, `List__Event__Log`, `Set__Permission__Ids`
- **Type annotations**: Use as field types in `Type_Safe` classes
- **Auto-initialization**: Empty instance created automatically in parent classes
- **IDE support**: Better autocomplete and type checking
- **Self-documenting code**: The class name describes both collection type AND contents

---

## Overview

This guide covers creating **reusable, named collection types** by subclassing the Type_Safe collection classes: `Type_Safe__Dict`, `Type_Safe__List`, `Type_Safe__Set`, and `Type_Safe__Tuple`. These subclasses provide type-safe containers with fixed type parameters that can be used as type annotations in `Type_Safe` classes.

### Why Subclass Type_Safe Collections?

| Benefit | Example |
|---------|---------|
| **Reusability** | Define `Dict__Content__Hashes` once, use everywhere |
| **Clarity** | `hashes: Dict__Content__Hashes` vs `hashes: Dict[Safe_Str__Hash, str]` |
| **Encapsulation** | Type parameters defined in one place |
| **Full Integration** | Works with JSON serialization, auto-initialization, type enforcement |
| **Operation Preservation** | `copy()`, `|`, `fromkeys()` return the subclass type |

### When to Subclass vs Use Inline Annotations

```python
# ✓ USE INLINE when type combination is used once
class OneOffSchema(Type_Safe):
    temp_data: Dict[str, int]                    # One-off usage

# ✓ USE SUBCLASS when type combination is reused or has semantic meaning
class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

class Schema__Document(Type_Safe):
    content_hashes : Dict__Content__Hashes       # Reused type
    backup_hashes  : Dict__Content__Hashes       # Same type, different field
```

---

## Type_Safe__Dict Subclasses

### Basic Pattern

Create a subclass with class-level type definitions:

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict               import Type_Safe__Dict
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash  import Safe_Str__Hash

class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash         # Keys must be Safe_Str__Hash
    expected_value_type = str                    # Values must be str

# Create instance - no constructor arguments needed
hash_map = Dict__Content__Hashes()

# Type enforcement is active
hash_map['abc1234567'] = 'some value'           # ✓ Key auto-converts to Safe_Str__Hash
hash_map[Safe_Str__Hash('def1234567')] = 'ok'   # ✓ Already correct type

# Invalid types raise errors
hash_map[True] = 'value'                        # ✗ TypeError: Expected 'Safe_Str__Hash', but got 'bool'
hash_map['abc1234567'] = 123                    # ✗ TypeError: Expected 'str', but got 'int'
```

### Creating with Initial Data

Pass initial data as the first argument (like a regular dict):

```python
# Create with initial data
hash_map = Dict__Content__Hashes({'abc1234567': 'Value A',
                                  'def1234567': 'Value B'})

# Keys are auto-converted to Safe_Str__Hash
assert isinstance(list(hash_map.keys())[0], Safe_Str__Hash)

# Invalid data raises during construction
Dict__Content__Hashes({'short': 'value'})       # ✗ ValueError from Safe_Str__Hash validation
Dict__Content__Hashes({'abc1234567': 42})       # ✗ TypeError: Expected 'str', but got 'int'
```

### Using in Type_Safe Classes

Subclasses work seamlessly as type annotations:

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

class Schema__Document(Type_Safe):
    title  : str
    hashes : Dict__Content__Hashes               # Auto-initializes to empty Dict__Content__Hashes

# Auto-initialization
doc = Schema__Document()
assert type(doc.hashes) is Dict__Content__Hashes  # Correct subclass type
assert doc.hashes.expected_key_type is Safe_Str__Hash

# Use the mapping
doc.hashes['abc1234567'] = 'Content hash'
doc.hashes['def1234567'] = 'Backup hash'

assert len(doc.hashes) == 2
```

### Auto-Conversion from Plain Dicts

When assigning a plain `dict` to a `Type_Safe__Dict` subclass field, it auto-converts:

```python
class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

class Schema__Container(Type_Safe):
    data: Dict__Content__Hashes

# Plain dict in constructor - auto-converts to Dict__Content__Hashes
container = Schema__Container(data={'abc1234567': 'value'})
assert type(container.data) is Dict__Content__Hashes

# Plain dict assignment after init - also auto-converts
container.data = {'def1234567': 'new value'}
assert type(container.data) is Dict__Content__Hashes

# Keys are converted to Safe_Str__Hash
assert all(isinstance(k, Safe_Str__Hash) for k in container.data.keys())
```

### JSON Serialization

Subclasses serialize to plain dicts and deserialize back to the correct subclass:

```python
class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

class Schema__Document(Type_Safe):
    title  : str
    hashes : Dict__Content__Hashes

# Create and populate
doc = Schema__Document(title='Test Doc')
doc.hashes['abc1234567'] = 'Value A'
doc.hashes['def1234567'] = 'Value B'

# Serialize to JSON
json_data = doc.json()
# Result: {'title': 'Test Doc', 'hashes': {'abc1234567': 'Value A', 'def1234567': 'Value B'}}

# Keys are plain strings in JSON output
assert type(json_data['hashes']) is dict
assert all(type(k) is str for k in json_data['hashes'].keys())

# Deserialize - subclass type is restored
restored = Schema__Document.from_json(json_data)
assert type(restored.hashes) is Dict__Content__Hashes
assert restored.hashes.expected_key_type is Safe_Str__Hash

# Keys are Safe_Str__Hash instances again
assert all(isinstance(k, Safe_Str__Hash) for k in restored.hashes.keys())
```

### Operations Preserve Subclass Type

Dict operations return the same subclass type, not the base `Type_Safe__Dict`:

```python
class Dict__Content__Hashes(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash
    expected_value_type = str

hash_map = Dict__Content__Hashes({'abc1234567': 'value'})

# copy() returns Dict__Content__Hashes
copied = hash_map.copy()
assert type(copied) is Dict__Content__Hashes     # ✓ Not Type_Safe__Dict

# | operator returns Dict__Content__Hashes
merged = hash_map | {'def1234567': 'other'}
assert type(merged) is Dict__Content__Hashes     # ✓ Not Type_Safe__Dict

# |= modifies in place (type preserved)
hash_map |= {'ghi1234567': 'third'}
assert type(hash_map) is Dict__Content__Hashes

# fromkeys() returns Dict__Content__Hashes
from_keys = Dict__Content__Hashes.fromkeys(['aaa1234567', 'bbb1234567'], 'default')
assert type(from_keys) is Dict__Content__Hashes  # ✓ Not Type_Safe__Dict
```

---

## Nested Collection Subclasses

### Dict Containing Another Dict Subclass

```python
class Dict__Inner__Values(Type_Safe__Dict):
    expected_key_type   = str
    expected_value_type = int

class Dict__Outer__Groups(Type_Safe__Dict):
    expected_key_type   = Safe_Id
    expected_value_type = Dict__Inner__Values    # Value is another subclass

class Schema__Container(Type_Safe):
    data: Dict__Outer__Groups

# Nested plain dicts auto-convert to correct subclass types
container = Schema__Container(data={
    'outer-1': {'inner-1': 1, 'inner-2': 2},
    'outer-2': {'inner-3': 3}
})

assert type(container.data) is Dict__Outer__Groups
assert type(container.data['outer-1']) is Dict__Inner__Values
assert container.data['outer-1']['inner-1'] == 1
```

### Deep Nesting (3+ Levels)

```python
class Dict__Level3__Values(Type_Safe__Dict):
    expected_key_type   = str
    expected_value_type = int

class Dict__Level2__Groups(Type_Safe__Dict):
    expected_key_type   = str
    expected_value_type = Dict__Level3__Values

class Dict__Level1__Root(Type_Safe__Dict):
    expected_key_type   = str
    expected_value_type = Dict__Level2__Groups

class Schema__Container(Type_Safe):
    data: Dict__Level1__Root

# Triple-nested plain dict
container = Schema__Container(data={
    'level1': {
        'level2': {
            'level3': 42
        }
    }
})

assert type(container.data) is Dict__Level1__Root
assert type(container.data['level1']) is Dict__Level2__Groups
assert type(container.data['level1']['level2']) is Dict__Level3__Values
```

### Dict Containing Type_Safe Objects

```python
class Schema__Item(Type_Safe):
    name  : str
    value : int

class Dict__Items__By_Id(Type_Safe__Dict):
    expected_key_type   = Safe_Id
    expected_value_type = Schema__Item           # Value is a Type_Safe class

class Schema__Container(Type_Safe):
    items: Dict__Items__By_Id

# Plain dicts for values auto-convert to Schema__Item
container = Schema__Container(items={
    'item-1': {'name': 'First', 'value': 10},
    'item-2': {'name': 'Second', 'value': 20}
})

assert type(container.items) is Dict__Items__By_Id
assert type(container.items['item-1']) is Schema__Item
assert container.items['item-1'].name == 'First'
```

---

## Type_Safe__List Subclasses

### Basic Pattern

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List import Type_Safe__List
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id     import Safe_Id

class List__User__Ids(Type_Safe__List):
    expected_type = Safe_Id                      # Elements must be Safe_Id

# Create and use
id_list = List__User__Ids()
id_list.append('user-123')                       # ✓ Auto-converts to Safe_Id
id_list.append(Safe_Id('user-456'))              # ✓ Already correct type

# Type enforcement
id_list.append(123)                              # ✗ TypeError
```

### Using in Type_Safe Classes

```python
class List__User__Ids(Type_Safe__List):
    expected_type = Safe_Id

class Schema__User_Group(Type_Safe):
    name    : str
    members : List__User__Ids                    # Auto-initializes to empty List__User__Ids

group = Schema__User_Group(name='Admins')
group.members.append('admin-1')
group.members.append('admin-2')

assert type(group.members) is List__User__Ids
assert all(isinstance(m, Safe_Id) for m in group.members)
```

### Creating with Initial Data

```python
class List__User__Ids(Type_Safe__List):
    expected_type = Safe_Id

# Pass list as first argument
id_list = List__User__Ids(['user-1', 'user-2', 'user-3'])

assert len(id_list) == 3
assert all(isinstance(item, Safe_Id) for item in id_list)
```

### Operations Preserve Subclass Type

```python
class List__User__Ids(Type_Safe__List):
    expected_type = Safe_Id

list1 = List__User__Ids(['user-1'])

# copy() returns List__User__Ids
copied = list1.copy()
assert type(copied) is List__User__Ids

# + operator returns List__User__Ids
combined = list1 + ['user-2']
assert type(combined) is List__User__Ids

# * operator returns List__User__Ids
repeated = list1 * 3
assert type(repeated) is List__User__Ids
```

---

## Type_Safe__Set Subclasses

### Basic Pattern

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Set import Type_Safe__Set
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id    import Safe_Id

class Set__User__Ids(Type_Safe__Set):
    expected_type = Safe_Id

# Create and use
id_set = Set__User__Ids()
id_set.add('user-123')                           # ✓ Auto-converts to Safe_Id
id_set.add('user-123')                           # No duplicate (set behavior)

assert len(id_set) == 1
```

### Using in Type_Safe Classes

```python
class Set__User__Ids(Type_Safe__Set):
    expected_type = Safe_Id

class Schema__Access_Control(Type_Safe):
    resource    : str
    allowed_ids : Set__User__Ids                 # Auto-initializes to empty Set__User__Ids

acl = Schema__Access_Control(resource='/api/admin')
acl.allowed_ids.add('admin-1')
acl.allowed_ids.add('admin-2')

assert type(acl.allowed_ids) is Set__User__Ids
```

### Operations Preserve Subclass Type

```python
class Set__User__Ids(Type_Safe__Set):
    expected_type = Safe_Id

set1 = Set__User__Ids({'user-1', 'user-2'})
set2 = Set__User__Ids({'user-2', 'user-3'})

# | operator returns Set__User__Ids
union = set1 | set2
assert type(union) is Set__User__Ids

# & operator returns Set__User__Ids
intersection = set1 & set2
assert type(intersection) is Set__User__Ids

# - operator returns Set__User__Ids
difference = set1 - set2
assert type(difference) is Set__User__Ids

# copy() returns Set__User__Ids
copied = set1.copy()
assert type(copied) is Set__User__Ids
```

---

## Type_Safe__Tuple Subclasses

### Basic Pattern

`Type_Safe__Tuple` is different - it uses `expected_types` (plural) since tuples have fixed positions:

```python
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Tuple import Type_Safe__Tuple

# Note: Tuple subclassing is less common because tuples have fixed structure
# Usually use inline: Tuple[Safe_Float, Safe_Float, Safe_Float]

# For a subclass:
class Tuple__Coordinates__3D(Type_Safe__Tuple):
    expected_types = (float, float, float)

point = Tuple__Coordinates__3D((1.0, 2.0, 3.0))
```

### Using in Type_Safe Classes

For tuples, inline annotations are often clearer:

```python
from typing import Tuple

class Schema__Coordinate(Type_Safe):
    point: Tuple[float, float, float]            # Inline is usually cleaner for tuples
```

---

## Best Practices

### 1. Naming Conventions: Prefix with Collection Type

**Always prefix collection subclass names with the collection type** (`Dict__`, `List__`, `Set__`, `Tuple__`). This mirrors the `Schema__` prefix pattern for Type_Safe schema classes and provides immediate clarity:

```python
# ✓ RECOMMENDED: Collection type prefix + domain meaning
class Dict__Ontologies__By_Id(Type_Safe__Dict):          # Clearly a Dict
    expected_key_type   = Ontology_Id
    expected_value_type = Schema__Ontology

class Dict__Users__By_Email(Type_Safe__Dict):            # Clearly a Dict
    expected_key_type   = Safe_Str__Email
    expected_value_type = Schema__User

class List__Ontology__Node_Types(Type_Safe__List):       # Clearly a List
    expected_type = Schema__Ontology__Node_Type

class Set__Permission__Ids(Type_Safe__Set):              # Clearly a Set
    expected_type = Safe_Id

class Tuple__Coordinates(Type_Safe__Tuple):              # Clearly a Tuple
    expected_types = (Safe_Float, Safe_Float, Safe_Float)

# ✗ AVOID: No collection type indicator
class Ontologies_By_Id(Type_Safe__Dict): ...             # Is this a Dict? List? Set?
class User_Mapping(Type_Safe__Dict): ...                 # Ambiguous
class Hash_Index(Type_Safe__Dict): ...                   # Could be anything
```

**Why this pattern?**
- **Consistency with `Schema__` prefix**: Just as `Schema__Ontology` tells you it's a schema, `Dict__Ontologies` tells you it's a Dict
- **Immediate type recognition**: No need to check the base class
- **Distinguishes from schemas**: `Schema__` = data structure, `Dict__`/`List__`/`Set__`/`Tuple__` = typed collection
- **Searchability**: Easy to find all Dict subclasses with `grep "class Dict__"`

**Complete naming pattern:**
```python
# Schema classes: Schema__{Domain}__{Concept}
class Schema__Ontology(Type_Safe): ...
class Schema__Ontology__Node_Type(Type_Safe): ...

# Collection subclasses: {CollectionType}__{Domain}__{Description}
class Dict__Ontologies__By_Id(Type_Safe__Dict): ...
class List__Ontology__Nodes(Type_Safe__List): ...
class Set__Ontology__Tags(Type_Safe__Set): ...
```

### 2. Combine with Type_Safe__Primitive Keys

Type_Safe__Dict subclasses work best with Type_Safe__Primitive keys:

```python
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id                  import Safe_Id

# ✓ GOOD: Primitive key type with validation
class Dict__Content__By_Hash(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Hash         # 10-char hex hash
    expected_value_type = str

# ✓ GOOD: Safe_Id for identifiers
class Dict__Entities__By_Id(Type_Safe__Dict):
    expected_key_type   = Safe_Id                # Sanitized identifier
    expected_value_type = Entity

# ✗ AVOID: Raw str keys (no validation)
class Dict__Unsafe__Mapping(Type_Safe__Dict):
    expected_key_type   = str                    # Any string allowed
    expected_value_type = str
```

### 3. Document Type Parameters

Add inline comments explaining the type constraints (consistent with Type_Safe no-docstring style):

```python
class Dict__Content__Hash_Index(Type_Safe__Dict):    # Maps content hashes to file paths
    expected_key_type   = Safe_Str__Hash             # 10-char lowercase hex
    expected_value_type = Safe_Str__File__Path       # Validated file path
```

### 4. Use Subclasses for Domain Concepts

Create subclasses when the collection represents a domain concept:

```python
# ✓ GOOD: Named domain concept with collection type prefix
class Set__Permission__Ids(Type_Safe__Set):
    expected_type = Safe_Id

class Schema__User(Type_Safe):
    permissions: Set__Permission__Ids            # Clear: it's a Set of permission IDs

# ✗ LESS CLEAR: Inline annotation
class Schema__User(Type_Safe):
    permissions: Set[Safe_Id]                    # What kind of IDs? Set of what?
```

### 5. Validate Early with Subclass Constructors

Use subclass construction to validate data at boundaries:

```python
class Dict__Api_Keys__By_Key(Type_Safe__Dict):
    expected_key_type   = Safe_Str__API_Key
    expected_value_type = Safe_Str__Timestamp

def process_api_keys(raw_data: dict) -> Dict__Api_Keys__By_Key:
    """Convert and validate raw API key data."""
    return Dict__Api_Keys__By_Key(raw_data)      # Validates all keys/values
```

---

## Common Patterns

### Pattern: Registry/Index

```python
class Dict__Nodes__By_Id(Type_Safe__Dict):           # Index mapping node IDs to node objects
    expected_key_type   = Node_Id
    expected_value_type = Schema__Node

class Schema__Graph(Type_Safe):
    nodes: Dict__Nodes__By_Id
    
    def add_node(self, node: Schema__Node) -> None:
        self.nodes[node.id] = node
    
    def get_node(self, node_id: Node_Id) -> Schema__Node:
        return self.nodes[node_id]
```

### Pattern: Multi-Value Index

```python
class Dict__Documents__By_Tag(Type_Safe__Dict):      # Maps tags to sets of document IDs
    expected_key_type   = Safe_Str__Tag
    expected_value_type = Set__Document__Ids         # Value is another subclass

class Schema__Document_Store(Type_Safe):
    by_tag: Dict__Documents__By_Tag
    
    def add_tag(self, doc_id: Safe_Id, tag: str) -> None:
        if tag not in self.by_tag:
            self.by_tag[tag] = Set__Document__Ids()
        self.by_tag[tag].add(doc_id)
```

### Pattern: Configuration Registry

```python
class Dict__Config__Settings(Type_Safe__Dict):
    expected_key_type   = Safe_Str__Key
    expected_value_type = str

class Schema__Service_Config(Type_Safe):
    name     : Safe_Id
    settings : Dict__Config__Settings
    
# Usage
config = Schema__Service_Config(
    name='api-gateway',
    settings={
        'host'   : 'localhost',
        'port'   : '8080',
        'timeout': '30'
    }
)
```

---

## Import Reference

```python
# Core collection classes
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Dict  import Type_Safe__Dict
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__List  import Type_Safe__List
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Set   import Type_Safe__Set
from osbot_utils.type_safe.type_safe_core.collections.Type_Safe__Tuple import Type_Safe__Tuple

# Common key types for Type_Safe__Dict
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id                       import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id                        import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id         import Safe_Str__Id
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Key        import Safe_Str__Key
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash      import Safe_Str__Hash
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__SHA1      import Safe_Str__SHA1

# Type_Safe base class
from osbot_utils.type_safe.Type_Safe import Type_Safe
```

---

## Summary Checklist

When creating Type_Safe collection subclasses:

- [ ] **Name with collection type prefix**: `Dict__`, `List__`, `Set__`, `Tuple__`
- [ ] Define class-level `expected_key_type` and `expected_value_type` for dicts
- [ ] Define class-level `expected_type` for lists and sets
- [ ] Use Type_Safe__Primitive subclasses for keys when possible
- [ ] Use meaningful names that describe the domain concept (e.g., `Dict__Users__By_Email`)
- [ ] Add inline comments explaining type constraints (not docstrings)
- [ ] Trust auto-conversion from plain dicts/lists in Type_Safe classes
- [ ] Remember operations (`copy`, `|`, `fromkeys`) preserve subclass type
- [ ] Test JSON round-trip serialization if needed
- [ ] Use subclasses when the collection is reused or has semantic meaning
- [ ] Use inline annotations for one-off type combinations