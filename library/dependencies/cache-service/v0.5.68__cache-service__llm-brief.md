# MGraph-AI Cache Service - LLM Brief 

**version**: v0.5.68

## Service Overview
The MGraph-AI Cache Service is a production-ready, serverless caching system designed for AWS Lambda deployment. It provides intelligent content-addressable storage with multiple caching strategies, backed by flexible storage backends (AWS S3, SQLite, Local Disk, In-Memory, ZIP) with Memory-FS abstraction layer.

## Core Architecture

### Service Structure
- **FastAPI-based**: Built on `osbot-fast-api-serverless` framework
- **AWS Lambda optimized**: Includes dependency loading and cold-start optimization
- **Type-safe**: Extensive use of `Type_Safe` classes for validation
- **Modular design**: Clear separation between service, storage, and API layers

### Storage Backend Options (NEW in v0.5.68)
The service now supports multiple storage backends through auto-detection or explicit configuration:

- **S3 Storage** (Production): Primary backend via `Storage_FS__S3` class
- **Memory Storage** (Development): Fast in-memory storage via `Storage_FS__Memory`
- **Local Disk** (Development): File system storage via `Storage_FS__Local_Disk`
- **SQLite** (Testing): Database-backed storage via `Storage_FS__Sqlite`
- **ZIP** (Archive): Compressed file storage via `Storage_FS__Zip`

#### Storage Mode Auto-Detection
The service automatically selects the best storage mode:
1. Checks for explicit `ENV_VAR__CACHE__SERVICE__STORAGE_MODE` configuration
2. Checks for AWS credentials → uses S3
3. Falls back to Memory mode

#### Storage Configuration
```python
# Environment Variables
ENV_VAR__CACHE__SERVICE__STORAGE_MODE        # "s3", "memory", "local_disk", "sqlite", "zip"
ENV_VAR__CACHE__SERVICE__BUCKET_NAME         # For S3 mode
ENV_VAR__CACHE__SERVICE__LOCAL_DISK_PATH     # For local disk mode
ENV_VAR__CACHE__SERVICE__SQLITE_PATH         # For SQLite mode (:memory: for in-memory)
ENV_VAR__CACHE__SERVICE__ZIP_PATH            # For ZIP mode
ENV_VAR__CACHE__SERVICE__DEFAULT_TTL_HOURS   # Cache TTL (default: 24)
```

### Memory-FS Abstraction
- **Storage independence**: All operations work across storage backends
- **Path sharding**: Automatic 2-level hash sharding for performance
- **Namespace isolation**: Each namespace maps to storage-specific prefixes

## Storage Strategies

The service implements five distinct storage strategies through different `Memory_FS` implementations:

### 1. Direct (`direct`)
- Simple hash-based storage at `data/direct/`
- Uses `Memory_FS` with `Path__Handler__Hash_Sharded`
- Best for: Simple key-value storage without versioning

### 2. Temporal (`temporal`)
- Time-organized storage at `data/temporal/`
- Uses `Memory_FS__Temporal` for automatic timestamping
- Best for: Time-series data, audit logs

### 3. Temporal Latest (`temporal_latest`)
- Temporal storage with latest pointer at `data/temporal-latest/`
- Uses `Memory_FS__Latest_Temporal`
- Best for: Frequently updated content where you need both history and quick latest access

### 4. Temporal Versioned (`temporal_versioned`)
- Full versioning system at `data/temporal-versioned/`
- Maintains versions at `data/temporal-versioned/versions/`
- Uses combined handlers: temporal, latest, and versioned
- Best for: Complete version history with rollback capability

### 5. Key-Based (`key_based`)
- Semantic path-based storage at `data/key-based/`
- Uses `Path__Handler__Key_Based` for custom path organization
- Requires both `cache_key` (used as file path) and optionally `file_id`
- Best for: Human-readable paths, organized folder structures, predictable file locations

## API Endpoints

### Storage Operations

#### String Storage
```
# Basic (auto-generated hash)
POST /{namespace}/{strategy}/store/string

# With custom cache key
POST /{namespace}/{strategy}/store/string/{cache_key:path}
```
- Body: Raw string data
- Auto-generates hash from content or uses provided cache_key
- Optional `file_id` query parameter for custom file naming
- Returns: `Schema__Cache__Store__Response`

#### JSON Storage
```
# Basic (auto-generated hash)
POST /{namespace}/{strategy}/store/json

# With custom cache key
POST /{namespace}/{strategy}/store/json/{cache_key:path}
```
- Body: JSON object
- Sorted keys for consistent hashing
- Optional `file_id` query parameter for custom file naming
- Returns: `Schema__Cache__Store__Response`

#### Binary Storage
```
# Basic (auto-generated hash)
POST /{namespace}/{strategy}/store/binary

# With custom cache key
POST /{namespace}/{strategy}/store/binary/{cache_key:path}
```
- Body: Raw binary data
- Supports `Content-Encoding: gzip` header
- Auto-decompresses for hash calculation if compressed
- Optional `file_id` query parameter for custom file naming
- Returns: `Schema__Cache__Store__Response`

### Child Data File Operations (NEW in v0.5.68)

The service now supports storing lightweight child data files under cache entries without creating new cache entries. This enables organizing related data hierarchically.

#### Store Child Data Files
```
# Store with auto-generated file_id
POST /{namespace}/cache/{cache_id}/data/store/string
POST /{namespace}/cache/{cache_id}/data/store/json
POST /{namespace}/cache/{cache_id}/data/store/binary

# Store with specific data_file_id
POST /{namespace}/cache/{cache_id}/data/store/string/{data_file_id}
POST /{namespace}/cache/{cache_id}/data/store/json/{data_file_id}
POST /{namespace}/cache/{cache_id}/data/store/binary/{data_file_id}

# Store with data_key path and data_file_id
POST /{namespace}/cache/{cache_id}/data/store/string/{data_key:path}/{data_file_id}
POST /{namespace}/cache/{cache_id}/data/store/json/{data_key:path}/{data_file_id}
POST /{namespace}/cache/{cache_id}/data/store/binary/{data_key:path}/{data_file_id}
```

**Parameters:**
- `cache_id`: Parent cache entry ID (path parameter)
- `data_key`: Optional hierarchical path for organizing data (path parameter)
- `data_file_id`: Optional custom file identifier (path parameter)
- `namespace`: Cache namespace (path parameter)

**Returns:** `Schema__Cache__Data__Store__Response`
```json
{
  "cache_id": "parent-uuid",
  "data_files_created": ["data/path/to/file.json"],
  "data_key": "optional/path",
  "data_type": "json|string|binary",
  "extension": "json|txt|bin",
  "file_size": 1234,
  "file_id": "data-file-id",
  "namespace": "default"
}
```

#### Retrieve Child Data Files
```
# Retrieve with data_type and data_file_id
GET /{namespace}/cache/{cache_id}/data/json/{data_file_id}
GET /{namespace}/cache/{cache_id}/data/string/{data_file_id}
GET /{namespace}/cache/{cache_id}/data/binary/{data_file_id}

# Retrieve with data_key path
GET /{namespace}/cache/{cache_id}/data/json/{data_key:path}/{data_file_id}
GET /{namespace}/cache/{cache_id}/data/string/{data_key:path}/{data_file_id}
GET /{namespace}/cache/{cache_id}/data/binary/{data_key:path}/{data_file_id}
```

**Returns:** `Schema__Cache__Data__Retrieve__Response` or direct content

#### Delete Child Data Files
```
# Delete specific data file
DELETE /{namespace}/cache/{cache_id}/data/delete/{data_type}/{data_file_id}
DELETE /{namespace}/cache/{cache_id}/data/delete/{data_type}/{data_key:path}/{data_file_id}

# Delete all data files
DELETE /{namespace}/cache/{cache_id}/data/delete/all
DELETE /{namespace}/cache/{cache_id}/data/delete/all/{data_key:path}
```

**Parameters:**
- `data_type`: Type of data file (`json`, `string`, or `binary`)
- `data_key`: Optional path for scoped deletion
- `data_file_id`: Specific file identifier

**Returns:** Success/failure with deletion details

### ZIP File Operations (NEW in v0.5.68)

The service provides comprehensive ZIP file manipulation capabilities with immutable cache entries. Each modification creates a new cache entry while preserving the original.

#### Create and Store ZIP Files
```
# Create empty ZIP with semantic path
POST /{namespace}/{strategy}/zip/create/{cache_key:path}/{file_id}

# Store existing ZIP file
POST /{namespace}/{strategy}/zip/store/{cache_key:path}/{file_id}
Body: ZIP file bytes (application/zip)
```

**Returns:** `Schema__Cache__Zip__Store__Response`
```json
{
  "cache_id": "uuid",
  "cache_hash": "content-hash",
  "namespace": "default",
  "paths": {...},
  "size": 12345,
  "file_count": 10,
  "success": true
}
```

#### ZIP Operations (Read-Only)
```
# List all files in ZIP
GET /{namespace}/zip/{cache_id}/files/list

# Retrieve specific file from ZIP
GET /{namespace}/zip/{cache_id}/file/retrieve/{file_path:path}

# Download entire ZIP file
GET /{namespace}/zip/{cache_id}/retrieve
```

#### ZIP Operations (Mutating - Creates New Cache Entry)
```
# Add file to ZIP (from string)
POST /{namespace}/zip/{cache_id}/file/add/from/string/{file_path:path}
Body: String content

# Add file to ZIP (from bytes)
POST /{namespace}/zip/{cache_id}/file/add/from/bytes/{file_path:path}
Body: Binary content

# Delete file from ZIP
DELETE /{namespace}/zip/{cache_id}/file/delete/{file_path:path}
```

**Important:** All mutating operations return a **new cache_id** while preserving the original:
```json
{
  "success": true,
  "operation": "add|remove|replace",
  "cache_id": "new-uuid",           // NEW immutable entry
  "original_cache_id": "old-uuid",  // Original preserved
  "files_affected": ["path/to/file.txt"],
  "message": "..."
}
```

#### Batch ZIP Operations (NEW)
```
POST /{namespace}/zip/{cache_id}/batch/operations
Body: Schema__Cache__Zip__Batch__Request
```

**Request Schema:**
```json
{
  "cache_id": "uuid",
  "namespace": "default",
  "operations": [
    {
      "action": "add|remove|replace|rename|move",
      "path": "file/path.txt",
      "new_path": "new/path.txt",      // For rename/move
      "content": "...",                // For add/replace
      "pattern": "*.txt",              // For pattern-based remove
      "condition": "always|if_exists|if_not_exists"
    }
  ],
  "atomic": true  // Rollback all on any failure
}
```

**Response Schema:**
```json
{
  "success": true,
  "cache_id": "new-uuid",
  "original_cache_id": "old-uuid",
  "operations_applied": 5,
  "operations_failed": 0,
  "operation_results": [...],
  "files_added": ["path1.txt"],
  "files_removed": ["path2.txt"],
  "files_modified": ["path3.txt"],
  "new_file_count": 15,
  "new_size": 45678,
  "rollback_performed": false
}
```

**Batch Operation Actions:**
- `add`: Add new file (requires `path` and `content`)
- `remove`: Delete file(s) (requires `path` or `pattern`)
- `replace`: Replace file content (requires `path` and `content`)
- `rename`: Rename file (requires `path` and `new_path`)
- `move`: Move file to new location (requires `path` and `new_path`)

**Conditional Operations:**
- `always`: Execute regardless of file existence
- `if_exists`: Only execute if file exists
- `if_not_exists`: Only execute if file doesn't exist

### Retrieval Operations

#### Generic Retrieval (with metadata)
```
GET /{namespace}/retrieve/hash/{cache_hash}
GET /{namespace}/retrieve/{cache_id}
GET /{namespace}/retrieve/{cache_id}/config
GET /{namespace}/retrieve/{cache_id}/refs
GET /{namespace}/retrieve/{cache_id}/refs/all
GET /{namespace}/retrieve/{cache_id}/metadata
```
- Returns data with type information and metadata
- Binary data returns URL redirect instead of inline data
- Refs endpoints provide reference information
- Config endpoint returns Memory_FS file configuration
- Metadata endpoint returns file metadata

#### Type-Specific Retrieval
```
# By ID
GET /{namespace}/retrieve/{cache_id}/string
GET /{namespace}/retrieve/{cache_id}/json
GET /{namespace}/retrieve/{cache_id}/binary

# By Hash
GET /{namespace}/retrieve/hash/{cache_hash}/string
GET /{namespace}/retrieve/hash/{cache_hash}/json
GET /{namespace}/retrieve/hash/{cache_hash}/binary
```
- Returns data in appropriate format
- Binary endpoints return `application/octet-stream`
- String endpoints return `text/plain`
- JSON endpoints return parsed JSON

### Management Operations
```
GET /{namespace}/exists/hash/{cache_hash}
GET /{namespace}/file-hashes
GET /{namespace}/file-ids
GET /{namespace}/stats
DELETE /{namespace}/delete/{cache_id}
```

### Storage Admin Operations
```
GET /admin/storage/bucket-name
GET /admin/storage/file/exists/{path:path}
GET /admin/storage/file/bytes/{path:path}
GET /admin/storage/file/json/{path:path}
GET /admin/storage/files/parent-path
GET /admin/storage/files/all/{path:path}
GET /admin/storage/folders
DELETE /admin/storage/{path:path}
```

### Server Operations (NEW in v0.5.68)
```
GET /server/storage/info              # Current storage backend information
POST /server/create/test-fixtures     # Create test fixtures for development
```

### Service Information
```
GET /info/health          # Returns: {'status': 'ok'}
GET /info/server          # Server info including Fast_API details
GET /info/status          # Service status with environment
GET /info/versions        # All dependency versions
```

## Enhanced Features in v0.5.68

### 1. Child Data File System
Organize related data under cache entries without creating separate cache entries:

```python
# Example: Store multiple analysis results under one cache entry
cache_id = store_main_document(doc_content)

# Store child data with hierarchical organization
store_data(cache_id, "analysis/sentiment", sentiment_data, data_type="json")
store_data(cache_id, "analysis/keywords", keyword_data, data_type="json")
store_data(cache_id, "metadata/author", author_info, data_type="string")
```

**Use Cases:**
- Storing computed results alongside source data
- Organizing multi-part content (chapters, sections)
- Attaching metadata to cached items
- Building hierarchical data structures

### 2. ZIP File Manipulation
Full-featured ZIP operations with immutable versioning:

```python
# Create ZIP and add files
zip_id = create_empty_zip("projects/alpha")
new_id = add_file_to_zip(zip_id, "config.json", config_data)
newer_id = add_file_to_zip(new_id, "readme.md", readme_text)

# Batch operations with atomicity
batch_id = batch_operations(zip_id, [
    {"action": "add", "path": "data/file1.json", "content": data1},
    {"action": "add", "path": "data/file2.json", "content": data2},
    {"action": "remove", "pattern": "*.tmp"}
], atomic=True)
```

**Use Cases:**
- Managing configuration bundles
- Creating deployment packages
- Organizing related files
- Archiving versioned content

### 3. Content-Based ZIP Hashing
ZIP files are hashed based on their content and file structure, not raw bytes. This ensures:
- Identical content produces identical hashes regardless of creation time
- Deterministic hashing across compression settings
- Reliable deduplication

### 4. Test Fixtures System (NEW)
Automated test fixture management for development:

```python
# Endpoint: POST /server/create/test-fixtures
# Creates standardized test data:
# - string_simple, string_medium, string_large
# - json_simple, json_complex, json_empty
# - binary_small, binary_medium, binary_large
```

## Data Model

### Cache Hash (`Safe_Str__Cache_Hash`)
- Format: Lowercase hexadecimal, 10-96 characters
- Default length: 16 characters
- Configurable via `Cache__Hash__Config`
- Algorithms: MD5, SHA256 (default), SHA384

### Cache ID (`Random_Guid`)
- Format: Standard UUID/GUID
- Unique per storage operation
- Used for direct retrieval and deletion

### Storage Structure

#### Reference Stores
1. **Hash References** (`refs/by-hash/`)
   - Maps hash → list of cache IDs
   - Tracks latest_id and total_versions
   - Sharded path: `aa/bb/{hash}.json`
   - Schema: `Schema__Cache__Hash__Reference`

2. **ID References** (`refs/by-id/`)
   - Maps cache ID → hash and metadata
   - Stores all file paths and strategy info
   - Sharded path: `aa/bb/{cache_id}.json`
   - Schema: `Schema__Cache__File__Refs`

#### Data Storage
- Location depends on strategy (direct, temporal, temporal_latest, temporal_versioned, key_based)
- Files stored as `.json` or `.binary` based on content type
- Metadata stored in `.metadata` files
- Child data files stored in `data/` folders under each strategy

#### Path Constants
```python
CACHE__HANDLER__PREFIX_PATH__FS__REFS_ID                            = 'refs/by-id'
CACHE__HANDLER__PREFIX_PATH__FS__REFS_HASH                          = 'refs/by-hash'
CACHE__HANDLER__PREFIX_PATH__FS__DATA_DIRECT                        = 'data/direct'
CACHE__HANDLER__PREFIX_PATH__FS__DATA_KEY_BASED                     = 'data/key-based'
CACHE__HANDLER__PREFIX_PATH__FS__DATA_TEMPORAL                      = 'data/temporal'
CACHE__HANDLER__PREFIX_PATH__FS__DATA_TEMPORAL_LATEST               = 'data/temporal-latest'
CACHE__HANDLER__PREFIX_PATH__FS__DATA_TEMPORAL_VERSIONED            = 'data/temporal-versioned'
CACHE__HANDLER__PREFIX_PATH__FS__DATA_TEMPORAL_VERSIONED_VERSIONS   = 'data/temporal-versioned/versions'
```

## Response Schemas

### Store Response (`Schema__Cache__Store__Response`)
```json
{
  "cache_id": "uuid-format",
  "cache_hash": "16-char-hash",
  "namespace": "production",
  "paths": {
    "data": ["path/to/data/files"],
    "by_hash": ["refs/by-hash/paths"],
    "by_id": ["refs/by-id/paths"]
  },
  "size": 12345
}
```

### Retrieve Response (with metadata)
```json
{
  "data": "<content>",
  "metadata": {
    "cache_hash": "hash",
    "cache_id": "uuid",
    "cache_key": "original-key",
    "file_id": "file-identifier",
    "stored_at": "timestamp",
    "strategy": "temporal_latest",
    "namespace": "default",
    "file_type": "json|binary|string",
    "content_encoding": "gzip",
    "content_size": 12345
  },
  "data_type": "json|binary|string"
}
```

### Stats Response
```json
{
  "namespace": "default",
  "s3_bucket": "mgraph-ai-cache",
  "s3_prefix": "namespace-name",
  "ttl_hours": 24,
  "direct_files": 0,
  "temporal_files": 10,
  "temporal_latest_files": 5,
  "temporal_versioned_files": 15,
  "refs_hash_files": 20,
  "refs_id_files": 30,
  "total_files": 80
}
```

### File References Schema (`Schema__Cache__File__Refs`)
```json
{
  "all_paths": {
    "data": ["data/paths"],
    "by_hash": ["ref/paths"],
    "by_id": ["ref/paths"]
  },
  "cache_id": "uuid",
  "cache_hash": "hash",
  "file_paths": {
    "content_files": ["actual/content/paths"],
    "data_folders": ["child/data/folders"]
  },
  "namespace": "default",
  "strategy": "temporal_latest",
  "file_type": "json",
  "timestamp": "2025-01-01T00:00:00"
}
```

## Implementation Details

### Hash Generation (`Cache__Hash__Generator`)
- Consistent hashing across data types
- JSON: Sorted keys for deterministic hashing
- Strings: UTF-8 encoded before hashing
- Binary: Direct hash calculation
- Type_Safe objects: Converted to JSON first
- ZIP files: Content-based hashing using file paths and contents

### Compression Support
- Auto-detects `Content-Encoding: gzip`
- Decompresses for hash calculation
- Stores compressed version for efficiency
- Transparent decompression on retrieval

### Namespace Management
- Dynamic namespace creation
- Default namespace: "default"
- Each namespace has isolated:
  - Storage prefix (S3 prefix, file path, etc.)
  - TTL settings (default: 24 hours)
  - Storage handlers
  - Complete path isolation

### Storage Handler Architecture
Each namespace gets a `Cache__Handler` with:
- **Reference stores**: `fs__refs_hash` and `fs__refs_id`
- **Strategy stores**: `fs__data_direct`, `fs__data_temporal`, `fs__data_temporal_latest`, `fs__data_temporal_versioned`, `fs__data_key_based`
- **Shared backend**: All handlers share the same `Storage_FS` instance
- **Path prefixing**: Automatic namespace prefix for all paths

## AWS Lambda Deployment

### Configuration
- Handler: `mgraph_ai_service_cache.fast_api.lambda_handler.run`
- Dependencies loaded via `boto3__lambda.load_dependencies()`
- Environment detection via `AWS_REGION` variable
- Cold-start optimization with module cleanup

### Dependencies
```python
LAMBDA_DEPENDENCIES__FAST_API_SERVERLESS = [
    'osbot-fast-api-serverless==v1.23.0',
    'memory-fs==v0.35.0',
    'mgraph-ai-service-cache-client==v0.1.3'
]
```

### Deployment Class
- `Deploy__Service` extends `Deploy__Serverless__Fast_API`
- Service name: `mgraph_ai_service_cache`
- Supports environment variable configuration
- Configurable Lambda dependencies

## Best Practices

### Content Type Selection
- **String**: Plain text, logs, simple values
- **JSON**: Structured data, API responses
- **Binary**: Files, compressed data, images, ZIPs

### Strategy Selection
- **High read, rare update**: Use `temporal_latest`
- **Audit requirements**: Use `temporal_versioned`
- **Simple caching**: Use `direct`
- **Time-series data**: Use `temporal`
- **Organized structure**: Use `key_based` with meaningful paths

### Child Data Organization
- Use `data_key` paths for logical grouping
- Store computed results as child data
- Keep metadata separate from main content
- Use appropriate data types (json for structured, string for text, binary for files)

### ZIP File Management
- Use semantic paths for zip organization: `projects/{name}/deployments/{version}`
- Batch operations for multiple changes
- Use atomic mode for critical operations
- Preserve provenance with original_cache_id tracking

### Performance Optimization
- Hash sharding distributes storage load
- Compression reduces storage and transfer
- Reference stores enable fast lookups
- Namespace isolation prevents cross-contamination
- Content-based ZIP hashing enables deduplication

### Error Handling
- Returns 404 for missing content with detailed error schemas
- Graceful handling of compression errors
- Type conversion attempts for format mismatches
- Partial deletion tracking in delete operations
- Rollback support in atomic batch operations

## Security Considerations

### S3 Permissions Required
- `s3:GetObject`
- `s3:PutObject`
- `s3:DeleteObject`
- `s3:ListBucket`
- `s3:GetObjectMetadata`
- `s3:PutObjectMetadata`

### Data Isolation
- Complete namespace isolation
- No cross-namespace retrieval
- Separate storage prefixes per namespace
- Path validation through Type_Safe primitives

### Admin Endpoints
- `/admin/storage/*` endpoints provide direct storage access
- Should be protected with authentication in production
- Useful for debugging and maintenance

## Version Information
- Current version: v0.5.68
- Python package: `mgraph_ai_service_cache`
- Client library: `mgraph-ai-service-cache-client==v0.1.3`
- FastAPI framework with OpenAPI 3.1.0
- AWS Lambda runtime compatible

## Integration Examples

### Python Client Example
```python
import requests
import json

class CacheClient:
    def __init__(self, base_url="https://cache.dev.mgraph.ai"):
        self.base_url = base_url
    
    def store_json(self, data, strategy="temporal_latest", namespace="default"):
        response = requests.post(
            f"{self.base_url}/{namespace}/{strategy}/store/json",
            json=data
        )
        return response.json()
    
    def store_key_based_json(self, data, path, namespace="default", file_id=None):
        """Store JSON with key-based path"""
        url = f"{self.base_url}/{namespace}/key_based/store/json/{path}"
        params = {"file_id": file_id} if file_id else {}
        response = requests.post(url, json=data, params=params)
        return response.json()
    
    def store_child_data(self, cache_id, data_key, data, data_type="json", 
                         data_file_id=None, namespace="default"):
        """Store child data under a cache entry"""
        path = f"{data_key}/{data_file_id}" if data_file_id else ""
        url = f"{self.base_url}/{namespace}/cache/{cache_id}/data/store/{data_type}/{path}"
        
        if data_type == "json":
            response = requests.post(url, json=data)
        else:
            response = requests.post(url, data=data)
        return response.json()
    
    def retrieve_by_hash(self, cache_hash, namespace="default"):
        response = requests.get(
            f"{self.base_url}/{namespace}/retrieve/hash/{cache_hash}"
        )
        return response.json()
    
    def delete_by_id(self, cache_id, namespace="default"):
        response = requests.delete(
            f"{self.base_url}/{namespace}/delete/{cache_id}"
        )
        return response.json()
    
    # ZIP Operations
    def create_zip(self, path, file_id, strategy="temporal_latest", namespace="default"):
        """Create empty ZIP file"""
        url = f"{self.base_url}/{namespace}/{strategy}/zip/create/{path}/{file_id}"
        response = requests.post(url)
        return response.json()
    
    def zip_add_file(self, cache_id, file_path, content, namespace="default"):
        """Add file to ZIP (returns new cache_id)"""
        url = f"{self.base_url}/{namespace}/zip/{cache_id}/file/add/from/string/{file_path}"
        response = requests.post(url, data=content)
        return response.json()
    
    def zip_batch_operations(self, cache_id, operations, atomic=True, namespace="default"):
        """Perform batch operations on ZIP"""
        url = f"{self.base_url}/{namespace}/zip/{cache_id}/batch/operations"
        payload = {
            "cache_id": cache_id,
            "namespace": namespace,
            "operations": operations,
            "atomic": atomic
        }
        response = requests.post(url, json=payload)
        return response.json()
```

### Key-Based File Organization Example
```python
# Organize cache by date and category
def cache_daily_report(client, date, category, report_data):
    path = f"reports/{date.year}/{date.month:02d}/{date.day:02d}/{category}"
    file_id = f"{category}-{date.isoformat()}"
    
    return client.store_key_based_json(
        data=report_data,
        path=path,
        namespace="analytics",
        file_id=file_id
    )

# Result: Creates file at:
# data/key-based/reports/2025/01/16/sales/sales-2025-01-16.json
```

### Child Data Organization Example
```python
def cache_document_with_analysis(client, document, analysis_results):
    # Store main document
    store_result = client.store_json(
        data=document,
        strategy="temporal_latest",
        namespace="documents"
    )
    cache_id = store_result["cache_id"]
    
    # Store analysis as child data
    client.store_child_data(
        cache_id=cache_id,
        data_key="analysis/sentiment",
        data=analysis_results["sentiment"],
        data_type="json",
        data_file_id="sentiment-v1"
    )
    
    client.store_child_data(
        cache_id=cache_id,
        data_key="analysis/keywords",
        data=analysis_results["keywords"],
        data_type="json",
        data_file_id="keywords-v1"
    )
    
    return cache_id

# Result structure:
# refs/by-id/{cache_id}.json          # Main document reference
# data/temporal-latest/{hash}.json    # Main document content
# data/temporal-latest/data/analysis/sentiment/sentiment-v1.json
# data/temporal-latest/data/analysis/keywords/keywords-v1.json
```

### ZIP File Management Example
```python
def create_deployment_package(client, project_name, version, files):
    # Create empty ZIP
    zip_result = client.create_zip(
        path=f"deployments/{project_name}",
        file_id=f"v{version}",
        namespace="releases"
    )
    zip_id = zip_result["cache_id"]
    
    # Batch add all files
    operations = []
    for file_path, content in files.items():
        operations.append({
            "action": "add",
            "path": file_path,
            "content": content,
            "condition": "always"
        })
    
    # Add files atomically
    batch_result = client.zip_batch_operations(
        cache_id=zip_id,
        operations=operations,
        atomic=True,
        namespace="releases"
    )
    
    return batch_result["cache_id"]  # New immutable version

# Later: Update deployment package (creates new version)
def update_config_in_package(client, original_zip_id, new_config):
    result = client.zip_batch_operations(
        cache_id=original_zip_id,
        operations=[
            {
                "action": "remove",
                "pattern": "*.old",
                "condition": "if_exists"
            },
            {
                "action": "replace",
                "path": "config/settings.json",
                "content": json.dumps(new_config),
                "condition": "always"
            }
        ],
        atomic=True
    )
    
    return {
        "new_version": result["cache_id"],
        "original": result["original_cache_id"],
        "changes": result["operation_results"]
    }
```

### Handling Binary Data with Compression
```python
import gzip
import requests

def cache_compressed_file(file_path, namespace="files"):
    with open(file_path, 'rb') as f:
        content = f.read()
    
    # Compress before sending
    compressed = gzip.compress(content)
    
    response = requests.post(
        f"https://cache.dev.mgraph.ai/{namespace}/temporal_versioned/store/binary",
        data=compressed,
        headers={"Content-Encoding": "gzip"}
    )
    
    return response.json()
```

### Multi-Storage Environment Example
```python
# Development: Use memory storage
# export CACHE__SERVICE__STORAGE_MODE=memory

# Production: Use S3 storage (auto-detected from AWS credentials)
# export AWS_REGION=us-east-1
# export CACHE__SERVICE__BUCKET_NAME=my-cache-bucket

# Testing: Use SQLite storage
# export CACHE__SERVICE__STORAGE_MODE=sqlite
# export CACHE__SERVICE__SQLITE_PATH=/tmp/cache.db

# All use the same API, storage is abstracted
```

## Enums Reference

### Storage Modes (`Enum__Cache__Storage_Mode`)
- `MEMORY`: In-memory storage (fast, ephemeral)
- `S3`: AWS S3 storage (production)
- `LOCAL_DISK`: File system storage (development)
- `SQLITE`: SQLite database (testing)
- `ZIP`: ZIP file storage (archival)

### Store Strategies (`Enum__Cache__Store__Strategy`)
- `DIRECT`: Simple hash-based storage
- `TEMPORAL`: Time-organized storage
- `TEMPORAL_LATEST`: Temporal with latest pointer
- `TEMPORAL_VERSIONED`: Full versioning
- `KEY_BASED`: Semantic path-based storage

### Data Types (`Enum__Cache__Data_Type`)
- `STRING`: Plain text data
- `JSON`: Structured JSON data
- `BINARY`: Binary data (files, images, etc.)

### ZIP Operations (`Enum__Cache__Zip__Operation`)
- `LIST`: List files in ZIP
- `GET`: Get file from ZIP
- `ADD`: Add file to ZIP
- `REMOVE`: Remove file from ZIP
- `REPLACE`: Replace file in ZIP

## Key Differences from v0.5.30

### Major Additions
1. **Child Data Files**: Hierarchical data organization under cache entries
2. **ZIP Operations**: Full ZIP file manipulation with immutability
3. **Multi-Storage Support**: Flexible storage backend selection
4. **Batch Operations**: Atomic multi-operation support for ZIPs
5. **Test Fixtures**: Automated test data management
6. **Enhanced Schemas**: More Type_Safe classes for better validation

### API Changes
- `semantic_file` strategy renamed to `key_based`
- New `/data/store/*` endpoints for child data
- New `/zip/*` endpoints for ZIP operations
- New `/server/*` endpoints for server operations
- Enhanced error responses with Type_Safe schemas

### Implementation Improvements
- Content-based ZIP hashing
- Better path organization with constants
- Improved namespace isolation
- More comprehensive metadata tracking
- Stronger Type_Safe validation throughout

This briefing reflects the codebase at v0.5.68 and provides comprehensive guidance for LLM interactions with the service.
