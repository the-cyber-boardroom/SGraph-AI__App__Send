# Issues-FS — Memory-FS Abstraction Layer

**Document:** issues-fs__memory-fs-abstraction-layer
**Version:** v0.41.0
**Date:** 2026-02-09
**Status:** Active

---

## Overview

Issues-FS uses **Memory-FS** as its storage abstraction layer. This decouples all application code from specific storage implementations, allowing the same codebase to run against in-memory storage (for tests), local disk (for development/Git workflows), SQLite (for embedded use), or ZIP archives (for export/backup) — without changing a single line of application logic.

---

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Services Layer                        │
│  Node__Service │ Type__Service │ Link__Service │ ...    │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│                  Graph__Repository                       │
│         (calls storage_fs directly)                      │
└────────────────────────┬────────────────────────────────┘
                         │
┌────────────────────────▼────────────────────────────────┐
│                     Memory-FS                            │
│                    ┌──────────┐                          │
│                    │ Memory_FS │◄── Holds storage_fs    │
│                    └─────┬────┘                          │
│                          │                               │
│            ┌─────────────┼─────────────┐                │
│            │             │             │                 │
│     ┌──────▼──────┐ ┌───▼────┐ ┌──────▼──────┐        │
│     │ Storage_FS  │ │Storage │ │ Storage_FS  │        │
│     │ __Memory    │ │_FS     │ │ __Sqlite    │        │
│     │             │ │__Local │ │             │        │
│     │ (in-memory) │ │_Disk   │ │ (database)  │        │
│     └─────────────┘ └────────┘ └─────────────┘        │
│                                 ┌─────────────┐        │
│                                 │ Storage_FS  │        │
│                                 │ __Zip       │        │
│                                 │ (archive)   │        │
│                                 └─────────────┘        │
└─────────────────────────────────────────────────────────┘
```

---

## How Issues-FS Uses Memory-FS

### Direct Storage_FS Usage (Single-File Mode)

Issues-FS does **not** use Memory-FS's full file management layer (which creates 3 files per logical file: `.json`, `.json.config`, `.json.metadata`). Instead, it accesses `storage_fs` directly — writing and reading raw files (like `issue.json`) as single storage entries. This is significantly more efficient:

- **Standard Memory-FS file**: 3 storage entries per file (content + config + metadata)
- **Issues-FS approach**: 1 storage entry per file (content only)

This is possible because Issues-FS manages its own file layout (path conventions, JSON serialization) through `Path__Handler__Graph_Node` and `Graph__Repository`, and only needs the raw file I/O abstraction from `Storage_FS`.

### The Storage_FS Interface

All `Graph__Repository` operations use these `storage_fs` methods:

```python
self.storage_fs.file__save(path, content_bytes)    # Write file
self.storage_fs.file__str(path)                    # Read file as string
self.storage_fs.file__bytes(path)                  # Read file as bytes
self.storage_fs.file__exists(path)                 # Check if file exists
self.storage_fs.file__delete(path)                 # Delete file
self.storage_fs.files__paths()                     # List all file paths
self.storage_fs.clear()                            # Clear all storage
```

Every storage backend implements this same interface. Application code never needs to know which backend is active.

---

## Factory Pattern

`Graph__Repository__Factory` creates repositories with the appropriate backend:

```python
class Graph__Repository__Factory(Type_Safe):

    @classmethod
    def create_memory(cls) -> Graph__Repository:           # In-memory (tests)
        memory_fs = Memory_FS__In_Memory()
        ...

    @classmethod
    def create_local_disk(cls, root_path) -> Graph__Repository:  # Local disk
        memory_fs            = Memory_FS()
        memory_fs.storage_fs = Storage_FS__Local_Disk(root_path=root_path)
        ...

    @classmethod
    def create_sqlite(cls, db_path) -> Graph__Repository:  # SQLite
        memory_fs            = Memory_FS()
        memory_fs.storage_fs = Storage_FS__Sqlite(db_path=db_path)
        ...

    @classmethod
    def create_zip(cls, zip_path) -> Graph__Repository:    # ZIP archive
        memory_fs            = Memory_FS()
        memory_fs.storage_fs = Storage_FS__Zip(zip_path=zip_path)
        ...
```

### Backend Selection at Runtime

The FastAPI service selects the backend via environment variable:

```
ISSUES__IN_MEMORY=true   →  Storage_FS__Memory   (default, for demos)
ISSUES__IN_MEMORY=false  →  Storage_FS__Local_Disk (for production/Git)
```

---

## Storage Backends

### 1. In-Memory (`Memory_FS__In_Memory` / `Storage_FS__Memory`)

- All data stored in a Python dict
- Zero disk I/O
- Data lost when process exits
- Used by all tests (via `Graph__Repository__Factory.create_memory()`)
- Fast, isolated, no cleanup needed

### 2. Local Disk (`Storage_FS__Local_Disk`)

- Files stored as real files on the local filesystem
- Root path configurable (e.g., `/path/to/.issues/`)
- Git-compatible — changes tracked as regular file diffs
- Used for development and production Git workflows
- The default backend for real deployments

### 3. SQLite (`Storage_FS__Sqlite`)

- All files stored in a single SQLite database
- Portable — one `.db` file contains everything
- Good for embedded/self-contained deployments
- No directory structure on disk

### 4. ZIP (`Storage_FS__Zip`)

- All files stored in a single ZIP archive
- Used for export/backup/archival workflows
- Portable and compressible
- Read/write access to ZIP contents

---

## Why This Matters

### For Testing

Every test creates a fresh in-memory repository in `setUp`. Tests are fast (no disk I/O), isolated (no shared state), and require no cleanup:

```python
@classmethod
def setUpClass(cls):
    cls.repository    = Graph__Repository__Factory.create_memory()
    cls.type_service  = Type__Service(repository=cls.repository)
    cls.node_service  = Node__Service(repository=cls.repository)
```

### For Git Workflows

Local disk mode stores issues as plain JSON files in `.issues/` — fully version-controlled, diffable, mergeable:

```
.issues/
├── config/
│   ├── node-types.json
│   └── link-types.json
├── data/
│   ├── bug/
│   │   └── Bug-1/
│   │       └── issue.json
│   └── task/
│       └── Task-1/
│           └── issue.json
└── indexes/
    └── global-index.json
```

### For Portability

SQLite and ZIP modes package everything into a single file — easy to share, back up, or deploy without requiring a specific directory structure.

---

## Single-File Mode Explained

Memory-FS's file management layer normally creates **three files** for every logical file:

| File | Purpose |
|------|---------|
| `file.json` | The actual content |
| `file.json.config` | File type, encoding, timestamps |
| `file.json.metadata` | Content hash, size, checksums |

This is the `Memory_FS__File__Type__Json` (standard) mode.

Memory-FS also provides `Memory_FS__File__Type__Json__Single` — a "single-file" mode that creates **only the content file**, skipping config and metadata. This gives a 66% reduction in storage entries.

**Issues-FS goes further** — it bypasses Memory-FS's file management layer entirely and accesses `storage_fs` directly. This means:

- No config files, no metadata files
- No file-type resolution overhead
- Direct path-to-content mapping
- Maximum efficiency — each `issue.json` is exactly one storage entry

This is the most efficient way to use Memory-FS: treat it purely as a **storage abstraction** (pluggable backends) without using its file management features (types, config, metadata).

---

## Key Files

| File | Role |
|------|------|
| `Graph__Repository.py` | Data access layer — all `storage_fs` calls |
| `Graph__Repository__Factory.py` | Factory for creating repos with different backends |
| `Path__Handler__Graph_Node.py` | Path convention/generation for issue files |
| `Enum__Graph__Storage__Backend.py` | Enum of supported backends |
| `Issues_FS__Service__Fast_API.py` | Runtime backend selection |

---

## For LLM Agents

When writing code that reads or writes data in Issues-FS:

1. **Always go through `Graph__Repository`** — never access `storage_fs` directly from services
2. **Use the factory for tests** — `Graph__Repository__Factory.create_memory()` gives you an isolated repo
3. **Never assume a specific backend** — code must work with any `Storage_FS` implementation
4. **Paths are virtual** — they may map to files on disk, rows in SQLite, or entries in a ZIP
5. **The `storage_fs` interface is the contract** — `file__save`, `file__str`, `file__exists`, `file__delete`, `files__paths`
