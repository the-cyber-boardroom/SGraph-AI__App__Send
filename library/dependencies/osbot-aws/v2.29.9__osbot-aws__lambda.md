# OSBot-AWS Lambda: LLM Briefing Document

## Why OSBot-AWS Lambda?

The native boto3 Lambda API requires extensive boilerplate: packaging code, uploading to S3, configuring IAM roles, managing layers, and handling async updates. OSBot-AWS simplifies this dramatically:

**1. Deploy in 3 Lines**
```python
# boto3 native - dozens of lines for packaging, S3 upload, role setup, create_function call...

# OSBot-AWS Deploy_Lambda - just point at your handler
from osbot_aws.deploy.Deploy_Lambda import Deploy_Lambda

deploy = Deploy_Lambda(handler=my_module.run)
deploy.deploy()                                     # Packages, uploads, creates/updates - done
```

**2. Automatic Packaging**
```python
# Automatically finds and packages your handler's module
deploy.add_function_source_code()

# Add additional modules with one line each
deploy.add_osbot_utils()
deploy.add_module('requests')
```

**3. Instant Layer Creation from Pip Packages**
```python
# Auto-create Lambda layer from pip packages
deploy.set_packages_using_layer(['pandas', 'numpy', 'requests'])
```

**4. Simple Invocation with Logs**
```python
result = deploy.invoke({'key': 'value'})
result = deploy.invoke_return_logs({'key': 'value'})  # Includes execution logs
```

## Overview

The Lambda module in OSBot-AWS provides comprehensive Lambda function management including:

| Class | Purpose |
|-------|---------|
| `Deploy_Lambda` | **High-level deployment helper** - easiest way to deploy |
| `Lambda` | Core Lambda operations (create, invoke, update, configure) |
| `Lambda_Layer` | Lambda layer management |
| `Lambda__Dependencies` | S3-based dependency loading for Lambda functions |
| `Lambda__with_temp_role` | Lambda with auto-created IAM roles for testing |

**When to use which:**
- **`Deploy_Lambda`** - Use for 90% of deployments. Handles packaging, S3, roles automatically.
- **`Lambda`** - Use when you need fine-grained control, custom packaging, or working with existing functions.

---

## Deploy_Lambda: The Easy Way

`Deploy_Lambda` is the recommended approach for most Lambda deployments. It handles packaging, S3 upload, IAM roles, and updates automatically.

### Basic Usage

```python
from osbot_aws.deploy.Deploy_Lambda import Deploy_Lambda

# Point at your handler function
def my_handler(event, context):
    return {'statusCode': 200, 'body': 'Hello!'}

deploy = Deploy_Lambda(handler=my_handler)
deploy.deploy()                                     # Creates or updates the function
```

### With Custom Name and Stage

```python
deploy = Deploy_Lambda(
    handler     = my_handler,
    lambda_name = 'my-api-function',
    stage       = 'prod'                            # Results in: my-api-function__prod
)
```

### Adding Source Code

```python
deploy = Deploy_Lambda(handler=my_handler)

# Automatically adds handler's module
deploy.add_function_source_code()

# Add specific modules
deploy.add_module('my_utils')
deploy.add_modules(['module1', 'module2'])

# Add OSBot packages (commonly needed)
deploy.add_osbot_utils()
deploy.add_osbot_aws()

# Add files/folders directly
deploy.add_file('/path/to/config.json', folder='config')
deploy.add_folder('/path/to/lib', ignore=['*.pyc', '__pycache__'])
```

### Adding Layers

```python
# Add existing layer ARN
deploy.add_layer('arn:aws:lambda:us-east-1:123456789012:layer:my-layer:1')
deploy.add_layers([layer_arn_1, layer_arn_2])

# Or auto-create layer from pip packages (creates once, reuses)
deploy.set_packages_using_layer(
    packages                       = ['pandas', 'numpy', 'requests'],
    skip_layer_creation_if_exists = True
)
```

### Environment Variables

```python
deploy.set_env_variable('API_KEY', 'secret-value')
deploy.set_env_variables({
    'DEBUG': 'true',
    'DATABASE_URL': 'postgresql://...'
})
```

### Invocation

```python
# Simple invoke
result = deploy.invoke({'user_id': '123'})

# Async invoke (returns immediately)
deploy.invoke_async({'user_id': '123'})

# Invoke with execution logs
result = deploy.invoke_return_logs({'user_id': '123'})
# Returns: {'status': 'ok', 'return_value': {...}, 'execution_logs': '...'}
```

### Lifecycle Methods

```python
deploy.exists()                                     # True if function exists
deploy.info()                                       # Function configuration
deploy.delete()                                     # Delete function
deploy.function_url()                               # Get function URL if configured
deploy.files()                                      # List files in deployment package
```

### Context Manager Support

```python
with Deploy_Lambda(handler=my_handler) as deploy:
    deploy.add_osbot_utils()
    deploy.deploy()
    result = deploy.invoke({'test': True})
```

### Container Image Deployment

```python
deploy = Deploy_Lambda(handler='my-function')
deploy.set_container_image('123456789012.dkr.ecr.us-east-1.amazonaws.com/my-repo:latest')
deploy.deploy()
```

### Complete Deploy_Lambda Example

```python
from osbot_aws.deploy.Deploy_Lambda import Deploy_Lambda

# Your Lambda handler
def process_order(event, context):
    order_id = event.get('order_id')
    # Process order...
    return {'processed': order_id}

# Deploy with all options
with Deploy_Lambda(handler=process_order, lambda_name='order-processor') as deploy:
    # Add dependencies
    deploy.add_osbot_utils()
    deploy.add_module('my_order_lib')
    
    # Add heavy packages as a layer
    deploy.set_packages_using_layer(['pandas', 'boto3'])
    
    # Configure environment
    deploy.set_env_variables({
        'STAGE': 'production',
        'LOG_LEVEL': 'INFO'
    })
    
    # Deploy and test
    success = deploy.deploy()
    
    if success:
        result = deploy.invoke({'order_id': 'ORD-12345'})
        print(f"Result: {result}")
```

### Testing Base Class

For test suites, use `TestCase__Lambda__Deploy`:

```python
from osbot_aws.testing.TestCase__Lambda__Deploy import TestCase__Lambda__Deploy

def my_handler(event, context):
    return {'result': event.get('input', 0) * 2}

class Test_My_Lambda(TestCase__Lambda__Deploy):
    handler = my_handler                            # Set your handler
    
    def test_deploy_and_invoke(self):
        self.deploy()                               # Deploys the function
        result = self.invoke({'input': 21})
        assert result['result'] == 42
```

---

## Core Lambda Class

For lower-level control or when you need direct access to Lambda APIs, use the `Lambda` class directly.

### Import and Initialization

```python
from osbot_aws.aws.lambda_.Lambda import Lambda

# Initialize with function name
lambda_func = Lambda('my-function')

# Or with full configuration
lambda_func = Lambda(name='my-function')
lambda_func.set_role(role_arn)
lambda_func.set_s3_bucket('my-bucket')
lambda_func.set_s3_key('lambdas/my-function.zip')
```

### Custom Session (LocalStack support)

```python
from osbot_aws.aws.lambda_.Lambda import Lambda
from osbot_aws.aws.session.Session__Kwargs__Lambda import Session__Kwargs__Lambda

session_kwargs = Session__Kwargs__Lambda(
    endpoint_url = 'http://localhost:4566',
    region_name  = 'us-east-1'
)
lambda_func = Lambda('my-function', session_kwargs__lambda=session_kwargs)
```

---

## Function Lifecycle

### Create Function

**From S3 (zip package):**
```python
lambda_func = Lambda('my-function')
lambda_func.runtime      = 'python3.11'
lambda_func.handler      = 'my_function.run'
lambda_func.memory       = 512                  # MB (max: 10240)
lambda_func.timeout      = 60                   # seconds (max: 900)
lambda_func.role         = 'arn:aws:iam::...:role/lambda-role'
lambda_func.s3_bucket    = 'my-bucket'
lambda_func.s3_key       = 'lambdas/my-function.zip'
lambda_func.architecture = 'x86_64'             # or 'arm64'

result = lambda_func.create()
# Returns: {'status': 'ok', 'name': 'my-function', 'data': {...}}
```

**From container image:**
```python
lambda_func = Lambda('my-function')
lambda_func.image_uri = '123456789012.dkr.ecr.us-east-1.amazonaws.com/my-repo:latest'
lambda_func.role      = 'arn:aws:iam::...:role/lambda-role'

result = lambda_func.create()
```

### Method Chaining Configuration

```python
result = (Lambda('my-function')
          .set_role('arn:aws:iam::...:role/lambda-role')
          .set_s3_bucket('my-bucket')
          .set_s3_key('lambdas/my-function.zip')
          .set_handler('handler.main')
          .set_trace_mode('Active')             # Enable X-Ray
          .set_env_variable('DEBUG', 'true')
          .add_layer('arn:aws:lambda:...:layer:my-layer:1')
          .create())
```

### Check Existence

```python
exists = lambda_func.exists()                   # True/False
exists = lambda_func.exists('other-function')   # Check specific function
```

### Delete Function

```python
deleted = lambda_func.delete(delete_log_group=True)  # Also deletes CloudWatch logs
```

---

## Update Functions

### Full Update (upload + code + config)

```python
result = lambda_func.update()
# Uploads to S3, updates code, updates configuration
# Returns: {'status': 'ok', 'name': '...', 'data': {...}}
```

### Update Code Only

```python
lambda_func.update_lambda_code()

# Update container image
lambda_func.update_lambda_image_uri('new-image-uri')
```

### Update Configuration Only

```python
lambda_func.update_lambda_configuration()

# Or directly via boto3
lambda_func.configuration_update(
    MemorySize=1024,
    Timeout=120,
    Environment={'Variables': {'KEY': 'value'}}
)
```

---

## Invoke Functions

### Synchronous Invocation

**Simple invoke (returns payload):**
```python
result = lambda_func.invoke({'key': 'value'})
# Returns the Lambda function's return value directly
# Or: {'error': 'error message'} on failure
```

**Full invoke with metadata:**
```python
result = lambda_func.invoke_raw({'key': 'value'})
# Returns: {
#     'status': 'ok',
#     'name': 'my-function',
#     'data': {...},           # Lambda return value
#     'response': {...}        # Full boto3 response
# }
```

**Invoke with execution logs:**
```python
result = lambda_func.invoke_return_logs({'key': 'value'})
# Returns: {
#     'status': 'ok',
#     'name': 'my-function',
#     'return_value': {...},
#     'execution_logs': '...',  # CloudWatch logs from execution
#     'request_id': '...'
# }
```

### Asynchronous Invocation

```python
response = lambda_func.invoke_async({'key': 'value'})
# Returns immediately, Lambda executes in background
```

### Dry Run (validate only)

```python
response = lambda_func.invoke_dry_run({'key': 'value'})
# Validates permissions without executing
```

### Helper Functions

```python
from osbot_aws.aws.lambda_.Lambda import invoke_lambda, invoke_lambda_async

result = invoke_lambda('my-function', {'key': 'value'})
invoke_lambda_async('my-function', {'key': 'value'})
```

---

## Function Configuration

### Get Configuration

```python
config = lambda_func.configuration()
# Returns function configuration (without ResponseMetadata)
```

### Get Full Info

```python
info = lambda_func.info()
# Returns: {'Configuration': {...}, 'Code': {...}, ...}
```

### Environment Variables

```python
# Set single variable
lambda_func.set_env_variable('KEY', 'value')

# Set all variables
lambda_func.set_env_variables({'KEY1': 'val1', 'KEY2': 'val2'})

# Update via configuration
lambda_func.configuration_update(
    Environment={'Variables': {'KEY': 'value'}}
)
```

### Layers

```python
# Add single layer
lambda_func.add_layer('arn:aws:lambda:...:layer:my-layer:1')

# Add multiple layers
lambda_func.add_layers([
    'arn:aws:lambda:...:layer:layer1:1',
    'arn:aws:lambda:...:layer:layer2:1'
])

# Set all layers
lambda_func.set_layers(['arn:aws:lambda:...:layer:my-layer:1'])
```

---

## Function URLs

### Create Function URL

```python
# Basic URL (requires IAM auth)
result = lambda_func.function_url_create(
    auth_type   = 'AWS_IAM',            # or 'NONE' for public
    invoke_mode = 'BUFFERED'            # or 'RESPONSE_STREAM'
)
```

**Public URL (no auth):**
```python
result = lambda_func.function_url_create_with_public_access(invoke_mode='BUFFERED')
# Creates URL and sets policy for public access
```

### Get Function URL

```python
url    = lambda_func.function_url()             # Just the URL string
info   = lambda_func.function_url_info()        # Full configuration
exists = lambda_func.function_url_exists()      # True/False
```

### Update Function URL

```python
lambda_func.function_url_update(
    auth_type   = 'NONE',
    invoke_mode = 'RESPONSE_STREAM'
)
```

### Delete Function URL

```python
lambda_func.function_url_delete()
```

---

## Permissions & Policies

### Add Permission

```python
result = lambda_func.permission_add(
    function_arn = lambda_func.function_arn(),
    statement_id = 'AllowS3Invoke',
    action       = 'lambda:InvokeFunction',
    principal    = 's3.amazonaws.com',
    source_arn   = 'arn:aws:s3:::my-bucket'
)
```

### Delete Permission

```python
lambda_func.permission_delete(
    function_name = lambda_func.function_arn(),
    statement_id  = 'AllowS3Invoke'
)
```

### Get Policy & Statements

```python
policy     = lambda_func.policy()               # Full policy document
statements = lambda_func.permissions()          # List of statements

# Indexed access
by_sid = lambda_func.policy_statements(index_by='Sid')
```

### Clear All Permissions

```python
lambda_func.policy_statements_clear()
```

---

## Event Source Mappings

```python
# Create mapping (e.g., SQS trigger)
mapping = lambda_func.event_source_create(
    event_source_arn = 'arn:aws:sqs:...:my-queue',
    function_name    = 'my-function'
)

# List mappings
mappings = lambda_func.event_sources()

# Delete mapping
lambda_func.event_source_delete(event_source_uuid='...')
```

---

## Aliases

```python
# Create alias
lambda_func.alias_create(
    function_name    = 'my-function',
    function_version = '1',
    name             = 'prod',
    description      = 'Production alias'
)

# Get alias
alias = lambda_func.alias('my-function', 'prod')

# List aliases
aliases = lambda_func.aliases('my-function')

# Delete alias
lambda_func.alias_delete('my-function', 'prod')
```

---

## List Functions

```python
# All functions
functions = lambda_func.functions()

# Indexed by name
by_name = lambda_func.functions(index_by='FunctionName')

# Just names
names = lambda_func.functions_names()
```

---

## CloudWatch Logs

```python
log_group = lambda_func.log_group()
# Returns Logs object for '/aws/lambda/{function_name}'
```

---

## Wait Operations

```python
# Wait for function to be active
result = lambda_func.wait_for_state_active(max_wait_count=40, wait_interval=1)

# Wait for any state
result = lambda_func.wait_for_state('Active')

# Wait for update to complete (used internally)
status = lambda_func.wait_for_function_update_to_complete(max_attempts=40, wait_time=0.1)
```

---

## Lambda Layers

### Lambda_Layer Class

```python
from osbot_aws.aws.lambda_.Lambda_Layer import Lambda_Layer

layer = Lambda_Layer(
    layer_name   = 'my-layer',
    runtimes     = ['python3.11', 'python3.10'],
    description  = 'My custom layer',
    license_info = 'MIT'
)
```

### Create Layer

**From folder:**
```python
layer.create_from_folder('/path/to/layer/contents')
```

**From folder via S3 (for large layers):**
```python
layer_arn = layer.create_from_folder_via_s3('/path/to/layer/contents')
```

**From pip package:**
```python
result = layer.create_from_pip('requests')
```

**From zip bytes:**
```python
layer.create_from_zip_bytes(zip_bytes)
```

### Layer Operations

```python
# Check existence
exists = layer.exists()

# Get info
info    = layer.info()
latest  = layer.latest()
version = layer.latest_version()
arn     = layer.arn_latest()

# List versions
versions = layer.versions()

# Delete
layer.delete()                          # All versions
layer.delete_version(1)                 # Specific version

# Download code
zip_path = layer.code_zip()             # Downloads to temp file
```

### List All Layers

```python
all_layers = layer.layers()
by_name    = layer.layers(index_by='LayerName')
```

---

## Lambda Dependencies

For loading Python packages inside Lambda functions at runtime from S3:

### Inside Lambda Function

```python
from osbot_aws.aws.lambda_.dependencies.Lambda__Dependency__Inside_Lambda import Lambda__Dependency__Inside_Lambda

# Load a package from S3 into the Lambda environment
Lambda__Dependency__Inside_Lambda(package_name='pandas').load()

# Now you can import pandas
import pandas as pd
```

### Using boto3 Helper (in Lambda code)

```python
from osbot_aws.aws.lambda_.boto3__lambda import load_dependency, load_dependencies

# Load single package
load_dependency('requests')

# Load multiple packages
load_dependencies(['requests', 'pandas', 'numpy'])
```

### Upload Dependencies to S3

```python
from osbot_aws.aws.lambda_.dependencies.Lambda__Dependency import Lambda__Dependency

dep = Lambda__Dependency('pandas')

# Install locally
dep.dependency__local.install()

# Upload to S3
zip_bytes = dep.dependency__local.files__zipped()
dep.dependency__s3.upload(zip_bytes)
```

---

## Lambda with Temporary Role

For testing with auto-created IAM roles:

```python
from osbot_aws.aws.lambda_.Lambda__with_temp_role import Lambda__with_temp_role

# Automatically creates IAM role with Lambda and S3 permissions
lambda_func = Lambda__with_temp_role('my-test-function')
lambda_func.create()

# Reset credentials if needed
lambda_func.temp_role__iam_reset_credentials()
```

---

## Account Settings

```python
settings = lambda_func.account_settings()
# Returns Lambda service quotas and limits
```

---

## Complete Example: Deploy Lambda Function

```python
from osbot_aws.aws.lambda_.Lambda import Lambda
from osbot_aws.aws.iam.IAM_Role import IAM_Role
from osbot_aws.aws.s3.S3 import S3
from osbot_utils.utils.Zip import zip_folder

# 1. Create IAM role
role = IAM_Role('my-lambda-role')
role.create_for__lambda()

# 2. Upload code to S3
s3 = S3()
code_folder = '/path/to/lambda/code'
s3.folder_upload(code_folder, 'my-bucket', 'lambdas/my-function.zip')

# 3. Create Lambda function
lambda_func = Lambda('my-function')
lambda_func.runtime   = 'python3.11'
lambda_func.handler   = 'handler.main'
lambda_func.role      = role.arn()
lambda_func.s3_bucket = 'my-bucket'
lambda_func.s3_key    = 'lambdas/my-function.zip'
lambda_func.memory    = 512
lambda_func.timeout   = 60

result = lambda_func.create()

# 4. Wait for active
lambda_func.wait_for_state_active()

# 5. Create public URL
lambda_func.function_url_create_with_public_access()

# 6. Test invocation
response = lambda_func.invoke({'test': 'data'})
print(f"Response: {response}")
print(f"URL: {lambda_func.function_url()}")
```

---

## Complete Example: Lambda with Layers

```python
from osbot_aws.aws.lambda_.Lambda import Lambda
from osbot_aws.aws.lambda_.Lambda_Layer import Lambda_Layer

# Create layer from pip package
layer = Lambda_Layer('requests-layer')
layer.create_from_pip('requests')

# Create Lambda with layer
lambda_func = Lambda('my-function')
lambda_func.add_layer(layer.arn_latest())

# Or add multiple layers
lambda_func.add_layers([
    layer.arn_latest(),
    'arn:aws:lambda:us-east-1:123456789012:layer:other-layer:1'
])

lambda_func.update()
```

---

## Shell Access (Advanced)

For interactive shell access in Lambda:

```python
# Get shell client
shell = lambda_func.shell()

# Execute Python code (requires @lambda_shell decorator on Lambda)
result = lambda_func.shell_python_exec(
    code     = 'import os; print(os.environ)',
    auth_key = 'secret-auth-key'
)
```

---

## Key Constants

```python
# Default settings in Lambda class
lambda_func.architecture = 'x86_64'     # or 'arm64'
lambda_func.runtime      = 'python3.11'
lambda_func.memory       = 512          # MB
lambda_func.timeout      = 60           # seconds
lambda_func.trace_mode   = 'PassThrough' # X-Ray disabled
```

---

## Error Handling

```python
# Create returns status dict
result = lambda_func.create()
if result.get('status') == 'error':
    print(f"Error: {result.get('error')}")
    print(f"Data: {result.get('data')}")

# Invoke errors
response = lambda_func.invoke({'key': 'value'})
if 'error' in response:
    print(f"Invocation error: {response['error']}")
```