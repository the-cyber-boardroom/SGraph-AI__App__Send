# SGraph Send v0.3.5 — Architect

**Role:** Architecture ownership — API contracts, data models, component boundaries, storage abstraction.

> For system topology diagrams see [Cartographer](v0.3.5__cartographer.md). For security boundaries see [AppSec](v0.3.5__appsec.md). For implementation patterns see [Dev](v0.3.5__dev.md).

---

## Two-Lambda Architecture

SGraph Send runs as two independent Lambda functions, each with its own Function URL (direct HTTPS, no API Gateway):

### User Lambda (Public)

Handles file transfer lifecycle. No global auth — per-route token validation.

**Class:** `Fast_API__SGraph__App__Send__User(Serverless__Fast_API)`

**Services initialised on setup:**
- `send_config: Send__Config` — storage backend factory (auto-detects MEMORY vs S3)
- `transfer_service: Transfer__Service` — transfer lifecycle management
- `send_cache_client: Send__Cache__Client` — analytics recording (optional)
- `admin_service_client: Admin__Service__Client` — inter-Lambda token validation (optional)

### Admin Lambda (Authenticated)

Handles token lifecycle and analytics. Global API key auth enabled.

**Class:** `Fast_API__SGraph__App__Send__Admin(Serverless__Fast_API)`

**Services initialised on setup:**
- `send_cache_client: Send__Cache__Client` — cache service (IN_MEMORY mode)
- `service_tokens: Service__Tokens` — token lifecycle management

### Separation Rationale

1. **Security** — admin endpoints behind separate auth boundary
2. **Scaling** — public file transfer scales independently from admin operations
3. **Deployment** — can update admin without affecting public traffic (and vice versa)
4. **Cost** — different concurrency/memory profiles

---

## API Contracts

### User Lambda Routes (`/transfers`)

| Method | Path | Purpose | Auth | Request | Response |
|--------|------|---------|------|---------|----------|
| POST | `/transfers/create` | Initiate transfer | Token | `{file_size_bytes, content_type_hint}` | `{transfer_id, upload_url}` |
| POST | `/transfers/upload/{transfer_id}` | Upload encrypted payload | Token | Raw bytes | `{status}` |
| POST | `/transfers/complete/{transfer_id}` | Mark ready for download | Token | — | `{transfer_id, download_url, transparency}` |
| GET | `/transfers/info/{transfer_id}` | Get transfer metadata | None | — | `{transfer_id, status, file_size_bytes, created_at, download_count}` |
| GET | `/transfers/download/{transfer_id}` | Download encrypted payload | None | — | Raw bytes |
| GET | `/transfers/check-token/{token_name}` | Lookup token (no consume) | None | — | Token info |
| POST | `/transfers/validate-token/{token_name}` | Lookup + consume use | None | — | Token info + usage |

**Token validation (two-tier fallback):**
1. If `admin_service_client` configured → validates via Admin Lambda HTTP call
2. Otherwise → falls back to env var `SGRAPH_SEND__ACCESS_TOKEN` (dev mode)

### Admin Lambda Routes (`/tokens` + `/health`)

| Method | Path | Purpose |
|--------|------|---------|
| POST | `/tokens/create` | Create token with usage limit |
| GET | `/tokens/lookup/{token_name}` | Find token by name |
| POST | `/tokens/use/{token_name}` | Record usage + consume |
| POST | `/tokens/revoke/{token_name}` | Revoke token |
| GET | `/tokens/list` | List all tokens |
| GET | `/health/pulse` | Traffic pulse (5-min window) |

### Standard Routes (Both Lambdas)

Both Lambdas include `Routes__Info` (`/info/health` → `{"status": "ok"}`) and `Routes__Set_Cookie` from `osbot-fast-api`.

---

## Data Model

### Transfer Storage Layout

```
transfers/{transfer_id}/
  ├── meta.json          # Transfer metadata (Type_Safe schema)
  └── payload            # Encrypted file bytes (opaque ciphertext)
```

**meta.json schema:**
```python
class Schema__Transfer__Meta(Type_Safe):
    transfer_id    : str              # Cryptographic random (12 chars)
    status         : str              # pending | completed | expired
    file_size_bytes: int              # Size of encrypted payload
    content_type   : str              # Hint only (e.g. "application/octet-stream")
    created_at     : int              # Timestamp (integer milliseconds)
    sender_ip_hash : str              # SHA-256 of sender IP
    download_count : int              # Incremented on each download
```

### Token Storage (via Cache Service)

Tokens are stored in MGraph-AI Cache Service with KEY_BASED strategy:

```python
class Schema__Token(Type_Safe):
    token_name   : str              # Human-readable name
    token_hash   : str              # SHA-256 of token_name (lookup key)
    usage_limit  : int              # Max uses (default 50)
    usage_count  : int              # Current uses
    status       : str              # active | revoked | exhausted
    created_by   : str              # Admin identifier
    created_at   : int              # Timestamp
    metadata     : dict             # Arbitrary metadata
```

### Analytics Events (via Cache Service)

Raw events stored with TEMPORAL strategy:

```
analytics/data/temporal/{year}/{month}/{day}/{hour}/{event_id}.json
```

**Event schema:**
```python
{
    'event_id'              : str,   # Unique event identifier
    'event_type'            : str,   # file_upload | file_download | api_call | page_view
    'path'                  : str,   # HTTP path
    'method'                : str,   # HTTP method
    'status_code'           : int,   # Response status
    'duration_ms'           : float, # Request duration
    'ip_hash'               : str,   # SHA-256 of client IP
    'user_agent_normalised' : str,   # Browser family
    'content_bytes'         : int,   # Response size
    'transfer_id'           : str,   # If applicable
    'token_id'              : str,   # If applicable
}
```

### ID Formats

| Type | Format | Example |
|------|--------|---------|
| Transfer_Id | Random GUID (12 chars) | `a3f8c1d2e4b7` |
| Token hash | SHA-256 of token_name | `e3b0c44298fc...` |
| Event_Id | UUID4 | `550e8400-e29b-...` |
| IP hash | SHA-256 of raw IP | `2cf24dba5fb0...` |

---

## Storage Abstraction (Memory-FS)

All file operations go through the `Storage_FS` interface from the `memory-fs` package. Application code never knows which backend is active.

```python
# Interface (used by all services)
storage.file__save(path, data)     # Write bytes or string
storage.file__bytes(path)          # Read bytes
storage.file__json(path)           # Read and parse JSON
storage.file__exists(path)         # Check existence
storage.file__delete(path)         # Delete
storage.files__paths()             # List all paths
```

**Pluggable backends:**

| Backend | Class | Use Case |
|---------|-------|----------|
| Memory | `Storage_FS__Memory` | Unit tests, local dev |
| S3 | `Storage_FS__S3` | Production (Lambda) |
| Disk | `Storage_FS` | CLI, containers |
| SQLite | `Storage_FS__SQLite` | Embedded |
| Zip | `Storage_FS__Zip` | Archives |

**Auto-detection (`Send__Config`):**
1. Check env var `SEND__STORAGE_MODE` (explicit override)
2. Check AWS credentials via `aws_config.aws_configured()`
3. Default to MEMORY

**S3 bucket naming:**
```
{account_id}--sgraph-send-transfers--{region}
```

---

## Inter-Lambda Communication

The User Lambda calls the Admin Lambda for token validation using the **Service Registry** pattern from `osbot-fast-api`:

```
User Lambda ──HTTP──▶ Admin Lambda
(token check)         (token lookup/use)
```

**Setup modes:**
- **REMOTE** (production): HTTP calls via `Admin__Service__Client__Requests`
- **IN_MEMORY** (tests): Direct function calls, no HTTP

**Configuration (3 env vars):**
- `SGRAPH_SEND__ADMIN__BASE_URL` — Admin Lambda Function URL
- `SGRAPH_SEND__ADMIN__API_KEY__NAME` — Auth header name
- `SGRAPH_SEND__ADMIN__API_KEY__VALUE` — Auth header value

If these env vars are absent, the User Lambda degrades gracefully (falls back to local token validation via `SGRAPH_SEND__ACCESS_TOKEN`).

---

## Client-Side Encryption

Encryption happens exclusively in the browser using the Web Crypto API:

1. **Key generation:** `crypto.subtle.generateKey('AES-GCM', 256)` → 256-bit AES key
2. **Encryption:** `crypto.subtle.encrypt({name: 'AES-GCM', iv}, key, plaintext)` → IV + ciphertext + auth tag
3. **Key sharing:** Key exported as base64url (44 chars), placed in URL hash-fragment (`#key=...`)
4. **Decryption:** Receiver extracts key from hash-fragment, calls `crypto.subtle.decrypt()`

**URL format:** `https://send.sgraph.ai/send/v0/v0.1/v0.1.4/download.html#id={transfer_id}&key={base64url_key}`

The hash-fragment (`#...`) is never sent to the server (RFC 3986). The server sees only encrypted bytes.

---

## Cache Service Architecture

Analytics and token state use the MGraph-AI Cache Service (via `Send__Cache__Client`):

| Namespace | Strategy | Content |
|-----------|----------|---------|
| `analytics` | TEMPORAL | Raw events, aggregated metrics |
| `tokens` | KEY_BASED | Token metadata, usage events |
| `costs` | KEY_BASED | AWS cost data (planned) |
| `transfers` | KEY_BASED | Per-transfer analytics (planned) |

**Execution mode:** IN_MEMORY (runs inside the Lambda process, backed by S3 via Cache Service bucket).

---

## Architectural Decisions Pending

| ID | Question | Impact |
|----|----------|--------|
| AD-1 | Large file transfer approach (chunked uploads vs streaming) | Explorer |
| AD-2 | Unencrypted mode (pluggable encryption, encrypted-by-default) | Explorer |
| AD-3 | CloudFront distribution (CDN, caching, WAF integration) | Villager |
| AD-4 | Container deployment (Docker/Fargate/GCP) entry points | Villager |

---

## Document Lineage

This document consolidates content from:
- `team/roles/architect/v0.1.2/v0.1.2__fastapi-service-plan-revised.md`
- `team/roles/architect/v0.1.2/v0.1.2__data-model-and-storage.md`
- `team/roles/architect/reviews/26-02-14/v0.2.41__review__osbot-ecosystem-architecture-assessment.md`
- `team/roles/architect/reviews/26-02-14/v0.3.0__response-to-daily-brief__14-feb.md`
- `team/roles/architect/reviews/26-02-14/v0.3.2__action-plan__explorer-next-steps.md`
